<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
  </head>
  <body>
    <div class="content"></div>
<script type="text/javascript">
!function(){var e={346:function(){const e=document.querySelector("head");e&&[16,32,96,160,196].forEach((t=>{const n=document.createElement("link");n.setAttribute("rel","icon"),n.setAttribute("href",`https://kitware.github.io/vtk-js/icon/favicon-${t}x${t}.png`),n.setAttribute("sizes",`${t}x${t}`),n.setAttribute("type","image/png"),e.appendChild(n)}))},422:function(e,t,n){"use strict";n.r(t),n.d(t,{initLocalFileLoader:function(){return CC},load:function(){return xC}});var r={};n.r(r),n.d(r,{add:function(){return Q},adjoint:function(){return v},clone:function(){return u},copy:function(){return d},create:function(){return c},determinant:function(){return T},equals:function(){return re},exactEquals:function(){return ne},frob:function(){return Z},fromQuat:function(){return k},fromQuat2:function(){return D},fromRotation:function(){return P},fromRotationTranslation:function(){return V},fromRotationTranslationScale:function(){return F},fromRotationTranslationScaleOrigin:function(){return _},fromScaling:function(){return O},fromTranslation:function(){return w},fromValues:function(){return p},fromXRotation:function(){return R},fromYRotation:function(){return M},fromZRotation:function(){return E},frustum:function(){return G},getRotation:function(){return N},getScaling:function(){return B},getTranslation:function(){return L},identity:function(){return g},invert:function(){return h},lookAt:function(){return q},mul:function(){return oe},multiply:function(){return y},multiplyScalar:function(){return ee},multiplyScalarAndAdd:function(){return te},ortho:function(){return K},orthoNO:function(){return j},orthoZO:function(){return $},perspective:function(){return z},perspectiveFromFieldOfView:function(){return H},perspectiveNO:function(){return U},perspectiveZO:function(){return W},rotate:function(){return C},rotateX:function(){return S},rotateY:function(){return A},rotateZ:function(){return I},scale:function(){return x},set:function(){return f},str:function(){return Y},sub:function(){return ae},subtract:function(){return J},targetTo:function(){return X},translate:function(){return b},transpose:function(){return m}});var o={};n.r(o),n.d(o,{add:function(){return Me},adjoint:function(){return me},clone:function(){return le},copy:function(){return ce},create:function(){return ie},determinant:function(){return he},equals:function(){return Be},exactEquals:function(){return Le},frob:function(){return Re},fromMat2d:function(){return Ae},fromMat4:function(){return se},fromQuat:function(){return Ie},fromRotation:function(){return Ce},fromScaling:function(){return Se},fromTranslation:function(){return xe},fromValues:function(){return ue},identity:function(){return pe},invert:function(){return ge},mul:function(){return Ne},multiply:function(){return ve},multiplyScalar:function(){return Ve},multiplyScalarAndAdd:function(){return De},normalFromMat4:function(){return we},projection:function(){return Oe},rotate:function(){return ye},scale:function(){return be},set:function(){return de},str:function(){return Pe},sub:function(){return Fe},subtract:function(){return Ee},translate:function(){return Te},transpose:function(){return fe}}),n(346);var a=1e-6,i="undefined"!=typeof Float32Array?Float32Array:Array;Math.random;var s=Math.PI/180;function l(e){return e*s}function c(){var e=new i(16);return i!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function u(e){var t=new i(16);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}function d(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function p(e,t,n,r,o,a,s,l,c,u,d,p,f,g,m,h){var v=new i(16);return v[0]=e,v[1]=t,v[2]=n,v[3]=r,v[4]=o,v[5]=a,v[6]=s,v[7]=l,v[8]=c,v[9]=u,v[10]=d,v[11]=p,v[12]=f,v[13]=g,v[14]=m,v[15]=h,v}function f(e,t,n,r,o,a,i,s,l,c,u,d,p,f,g,m,h){return e[0]=t,e[1]=n,e[2]=r,e[3]=o,e[4]=a,e[5]=i,e[6]=s,e[7]=l,e[8]=c,e[9]=u,e[10]=d,e[11]=p,e[12]=f,e[13]=g,e[14]=m,e[15]=h,e}function g(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function m(e,t){if(e===t){var n=t[1],r=t[2],o=t[3],a=t[6],i=t[7],s=t[11];e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=n,e[6]=t[9],e[7]=t[13],e[8]=r,e[9]=a,e[11]=t[14],e[12]=o,e[13]=i,e[14]=s}else e[0]=t[0],e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=t[1],e[5]=t[5],e[6]=t[9],e[7]=t[13],e[8]=t[2],e[9]=t[6],e[10]=t[10],e[11]=t[14],e[12]=t[3],e[13]=t[7],e[14]=t[11],e[15]=t[15];return e}function h(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15],T=n*s-r*i,y=n*l-o*i,b=n*c-a*i,x=r*l-o*s,C=r*c-a*s,S=o*c-a*l,A=u*m-d*g,I=u*h-p*g,w=u*v-f*g,O=d*h-p*m,P=d*v-f*m,R=p*v-f*h,M=T*R-y*P+b*O+x*w-C*I+S*A;return M?(M=1/M,e[0]=(s*R-l*P+c*O)*M,e[1]=(o*P-r*R-a*O)*M,e[2]=(m*S-h*C+v*x)*M,e[3]=(p*C-d*S-f*x)*M,e[4]=(l*w-i*R-c*I)*M,e[5]=(n*R-o*w+a*I)*M,e[6]=(h*b-g*S-v*y)*M,e[7]=(u*S-p*b+f*y)*M,e[8]=(i*P-s*w+c*A)*M,e[9]=(r*w-n*P-a*A)*M,e[10]=(g*C-m*b+v*T)*M,e[11]=(d*b-u*C-f*T)*M,e[12]=(s*I-i*O-l*A)*M,e[13]=(n*O-r*I+o*A)*M,e[14]=(m*y-g*x-h*T)*M,e[15]=(u*x-d*y+p*T)*M,e):null}function v(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15];return e[0]=s*(p*v-f*h)-d*(l*v-c*h)+m*(l*f-c*p),e[1]=-(r*(p*v-f*h)-d*(o*v-a*h)+m*(o*f-a*p)),e[2]=r*(l*v-c*h)-s*(o*v-a*h)+m*(o*c-a*l),e[3]=-(r*(l*f-c*p)-s*(o*f-a*p)+d*(o*c-a*l)),e[4]=-(i*(p*v-f*h)-u*(l*v-c*h)+g*(l*f-c*p)),e[5]=n*(p*v-f*h)-u*(o*v-a*h)+g*(o*f-a*p),e[6]=-(n*(l*v-c*h)-i*(o*v-a*h)+g*(o*c-a*l)),e[7]=n*(l*f-c*p)-i*(o*f-a*p)+u*(o*c-a*l),e[8]=i*(d*v-f*m)-u*(s*v-c*m)+g*(s*f-c*d),e[9]=-(n*(d*v-f*m)-u*(r*v-a*m)+g*(r*f-a*d)),e[10]=n*(s*v-c*m)-i*(r*v-a*m)+g*(r*c-a*s),e[11]=-(n*(s*f-c*d)-i*(r*f-a*d)+u*(r*c-a*s)),e[12]=-(i*(d*h-p*m)-u*(s*h-l*m)+g*(s*p-l*d)),e[13]=n*(d*h-p*m)-u*(r*h-o*m)+g*(r*p-o*d),e[14]=-(n*(s*h-l*m)-i*(r*h-o*m)+g*(r*l-o*s)),e[15]=n*(s*p-l*d)-i*(r*p-o*d)+u*(r*l-o*s),e}function T(e){var t=e[0],n=e[1],r=e[2],o=e[3],a=e[4],i=e[5],s=e[6],l=e[7],c=e[8],u=e[9],d=e[10],p=e[11],f=e[12],g=e[13],m=e[14],h=e[15];return(t*i-n*a)*(d*h-p*m)-(t*s-r*a)*(u*h-p*g)+(t*l-o*a)*(u*m-d*g)+(n*s-r*i)*(c*h-p*f)-(n*l-o*i)*(c*m-d*f)+(r*l-o*s)*(c*g-u*f)}function y(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=t[9],f=t[10],g=t[11],m=t[12],h=t[13],v=t[14],T=t[15],y=n[0],b=n[1],x=n[2],C=n[3];return e[0]=y*r+b*s+x*d+C*m,e[1]=y*o+b*l+x*p+C*h,e[2]=y*a+b*c+x*f+C*v,e[3]=y*i+b*u+x*g+C*T,y=n[4],b=n[5],x=n[6],C=n[7],e[4]=y*r+b*s+x*d+C*m,e[5]=y*o+b*l+x*p+C*h,e[6]=y*a+b*c+x*f+C*v,e[7]=y*i+b*u+x*g+C*T,y=n[8],b=n[9],x=n[10],C=n[11],e[8]=y*r+b*s+x*d+C*m,e[9]=y*o+b*l+x*p+C*h,e[10]=y*a+b*c+x*f+C*v,e[11]=y*i+b*u+x*g+C*T,y=n[12],b=n[13],x=n[14],C=n[15],e[12]=y*r+b*s+x*d+C*m,e[13]=y*o+b*l+x*p+C*h,e[14]=y*a+b*c+x*f+C*v,e[15]=y*i+b*u+x*g+C*T,e}function b(e,t,n){var r,o,a,i,s,l,c,u,d,p,f,g,m=n[0],h=n[1],v=n[2];return t===e?(e[12]=t[0]*m+t[4]*h+t[8]*v+t[12],e[13]=t[1]*m+t[5]*h+t[9]*v+t[13],e[14]=t[2]*m+t[6]*h+t[10]*v+t[14],e[15]=t[3]*m+t[7]*h+t[11]*v+t[15]):(r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=t[9],f=t[10],g=t[11],e[0]=r,e[1]=o,e[2]=a,e[3]=i,e[4]=s,e[5]=l,e[6]=c,e[7]=u,e[8]=d,e[9]=p,e[10]=f,e[11]=g,e[12]=r*m+s*h+d*v+t[12],e[13]=o*m+l*h+p*v+t[13],e[14]=a*m+c*h+f*v+t[14],e[15]=i*m+u*h+g*v+t[15]),e}function x(e,t,n){var r=n[0],o=n[1],a=n[2];return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e[4]=t[4]*o,e[5]=t[5]*o,e[6]=t[6]*o,e[7]=t[7]*o,e[8]=t[8]*a,e[9]=t[9]*a,e[10]=t[10]*a,e[11]=t[11]*a,e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function C(e,t,n,r){var o,i,s,l,c,u,d,p,f,g,m,h,v,T,y,b,x,C,S,A,I,w,O,P,R=r[0],M=r[1],E=r[2],V=Math.hypot(R,M,E);return V<a?null:(R*=V=1/V,M*=V,E*=V,o=Math.sin(n),s=1-(i=Math.cos(n)),l=t[0],c=t[1],u=t[2],d=t[3],p=t[4],f=t[5],g=t[6],m=t[7],h=t[8],v=t[9],T=t[10],y=t[11],b=R*R*s+i,x=M*R*s+E*o,C=E*R*s-M*o,S=R*M*s-E*o,A=M*M*s+i,I=E*M*s+R*o,w=R*E*s+M*o,O=M*E*s-R*o,P=E*E*s+i,e[0]=l*b+p*x+h*C,e[1]=c*b+f*x+v*C,e[2]=u*b+g*x+T*C,e[3]=d*b+m*x+y*C,e[4]=l*S+p*A+h*I,e[5]=c*S+f*A+v*I,e[6]=u*S+g*A+T*I,e[7]=d*S+m*A+y*I,e[8]=l*w+p*O+h*P,e[9]=c*w+f*O+v*P,e[10]=u*w+g*O+T*P,e[11]=d*w+m*O+y*P,t!==e&&(e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e)}function S(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[4],i=t[5],s=t[6],l=t[7],c=t[8],u=t[9],d=t[10],p=t[11];return t!==e&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[4]=a*o+c*r,e[5]=i*o+u*r,e[6]=s*o+d*r,e[7]=l*o+p*r,e[8]=c*o-a*r,e[9]=u*o-i*r,e[10]=d*o-s*r,e[11]=p*o-l*r,e}function A(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[0],i=t[1],s=t[2],l=t[3],c=t[8],u=t[9],d=t[10],p=t[11];return t!==e&&(e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=a*o-c*r,e[1]=i*o-u*r,e[2]=s*o-d*r,e[3]=l*o-p*r,e[8]=a*r+c*o,e[9]=i*r+u*o,e[10]=s*r+d*o,e[11]=l*r+p*o,e}function I(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[0],i=t[1],s=t[2],l=t[3],c=t[4],u=t[5],d=t[6],p=t[7];return t!==e&&(e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=a*o+c*r,e[1]=i*o+u*r,e[2]=s*o+d*r,e[3]=l*o+p*r,e[4]=c*o-a*r,e[5]=u*o-i*r,e[6]=d*o-s*r,e[7]=p*o-l*r,e}function w(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=t[0],e[13]=t[1],e[14]=t[2],e[15]=1,e}function O(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=t[1],e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=t[2],e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function P(e,t,n){var r,o,i,s=n[0],l=n[1],c=n[2],u=Math.hypot(s,l,c);return u<a?null:(s*=u=1/u,l*=u,c*=u,r=Math.sin(t),i=1-(o=Math.cos(t)),e[0]=s*s*i+o,e[1]=l*s*i+c*r,e[2]=c*s*i-l*r,e[3]=0,e[4]=s*l*i-c*r,e[5]=l*l*i+o,e[6]=c*l*i+s*r,e[7]=0,e[8]=s*c*i+l*r,e[9]=l*c*i-s*r,e[10]=c*c*i+o,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e)}function R(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=r,e[6]=n,e[7]=0,e[8]=0,e[9]=-n,e[10]=r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function M(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=0,e[2]=-n,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=n,e[9]=0,e[10]=r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function E(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=n,e[2]=0,e[3]=0,e[4]=-n,e[5]=r,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function V(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=r+r,l=o+o,c=a+a,u=r*s,d=r*l,p=r*c,f=o*l,g=o*c,m=a*c,h=i*s,v=i*l,T=i*c;return e[0]=1-(f+m),e[1]=d+T,e[2]=p-v,e[3]=0,e[4]=d-T,e[5]=1-(u+m),e[6]=g+h,e[7]=0,e[8]=p+v,e[9]=g-h,e[10]=1-(u+f),e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e}function D(e,t){var n=new i(3),r=-t[0],o=-t[1],a=-t[2],s=t[3],l=t[4],c=t[5],u=t[6],d=t[7],p=r*r+o*o+a*a+s*s;return p>0?(n[0]=2*(l*s+d*r+c*a-u*o)/p,n[1]=2*(c*s+d*o+u*r-l*a)/p,n[2]=2*(u*s+d*a+l*o-c*r)/p):(n[0]=2*(l*s+d*r+c*a-u*o),n[1]=2*(c*s+d*o+u*r-l*a),n[2]=2*(u*s+d*a+l*o-c*r)),V(e,t,n),e}function L(e,t){return e[0]=t[12],e[1]=t[13],e[2]=t[14],e}function B(e,t){var n=t[0],r=t[1],o=t[2],a=t[4],i=t[5],s=t[6],l=t[8],c=t[9],u=t[10];return e[0]=Math.hypot(n,r,o),e[1]=Math.hypot(a,i,s),e[2]=Math.hypot(l,c,u),e}function N(e,t){var n=new i(3);B(n,t);var r=1/n[0],o=1/n[1],a=1/n[2],s=t[0]*r,l=t[1]*o,c=t[2]*a,u=t[4]*r,d=t[5]*o,p=t[6]*a,f=t[8]*r,g=t[9]*o,m=t[10]*a,h=s+d+m,v=0;return h>0?(v=2*Math.sqrt(h+1),e[3]=.25*v,e[0]=(p-g)/v,e[1]=(f-c)/v,e[2]=(l-u)/v):s>d&&s>m?(v=2*Math.sqrt(1+s-d-m),e[3]=(p-g)/v,e[0]=.25*v,e[1]=(l+u)/v,e[2]=(f+c)/v):d>m?(v=2*Math.sqrt(1+d-s-m),e[3]=(f-c)/v,e[0]=(l+u)/v,e[1]=.25*v,e[2]=(p+g)/v):(v=2*Math.sqrt(1+m-s-d),e[3]=(l-u)/v,e[0]=(f+c)/v,e[1]=(p+g)/v,e[2]=.25*v),e}function F(e,t,n,r){var o=t[0],a=t[1],i=t[2],s=t[3],l=o+o,c=a+a,u=i+i,d=o*l,p=o*c,f=o*u,g=a*c,m=a*u,h=i*u,v=s*l,T=s*c,y=s*u,b=r[0],x=r[1],C=r[2];return e[0]=(1-(g+h))*b,e[1]=(p+y)*b,e[2]=(f-T)*b,e[3]=0,e[4]=(p-y)*x,e[5]=(1-(d+h))*x,e[6]=(m+v)*x,e[7]=0,e[8]=(f+T)*C,e[9]=(m-v)*C,e[10]=(1-(d+g))*C,e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e}function _(e,t,n,r,o){var a=t[0],i=t[1],s=t[2],l=t[3],c=a+a,u=i+i,d=s+s,p=a*c,f=a*u,g=a*d,m=i*u,h=i*d,v=s*d,T=l*c,y=l*u,b=l*d,x=r[0],C=r[1],S=r[2],A=o[0],I=o[1],w=o[2],O=(1-(m+v))*x,P=(f+b)*x,R=(g-y)*x,M=(f-b)*C,E=(1-(p+v))*C,V=(h+T)*C,D=(g+y)*S,L=(h-T)*S,B=(1-(p+m))*S;return e[0]=O,e[1]=P,e[2]=R,e[3]=0,e[4]=M,e[5]=E,e[6]=V,e[7]=0,e[8]=D,e[9]=L,e[10]=B,e[11]=0,e[12]=n[0]+A-(O*A+M*I+D*w),e[13]=n[1]+I-(P*A+E*I+L*w),e[14]=n[2]+w-(R*A+V*I+B*w),e[15]=1,e}function k(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=n+n,s=r+r,l=o+o,c=n*i,u=r*i,d=r*s,p=o*i,f=o*s,g=o*l,m=a*i,h=a*s,v=a*l;return e[0]=1-d-g,e[1]=u+v,e[2]=p-h,e[3]=0,e[4]=u-v,e[5]=1-c-g,e[6]=f+m,e[7]=0,e[8]=p+h,e[9]=f-m,e[10]=1-c-d,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function G(e,t,n,r,o,a,i){var s=1/(n-t),l=1/(o-r),c=1/(a-i);return e[0]=2*a*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=2*a*l,e[6]=0,e[7]=0,e[8]=(n+t)*s,e[9]=(o+r)*l,e[10]=(i+a)*c,e[11]=-1,e[12]=0,e[13]=0,e[14]=i*a*2*c,e[15]=0,e}function U(e,t,n,r,o){var a,i=1/Math.tan(t/2);return e[0]=i/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=i,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=o&&o!==1/0?(a=1/(r-o),e[10]=(o+r)*a,e[14]=2*o*r*a):(e[10]=-1,e[14]=-2*r),e}Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)});var z=U;function W(e,t,n,r,o){var a,i=1/Math.tan(t/2);return e[0]=i/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=i,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=o&&o!==1/0?(a=1/(r-o),e[10]=o*a,e[14]=o*r*a):(e[10]=-1,e[14]=-r),e}function H(e,t,n,r){var o=Math.tan(t.upDegrees*Math.PI/180),a=Math.tan(t.downDegrees*Math.PI/180),i=Math.tan(t.leftDegrees*Math.PI/180),s=Math.tan(t.rightDegrees*Math.PI/180),l=2/(i+s),c=2/(o+a);return e[0]=l,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=c,e[6]=0,e[7]=0,e[8]=-(i-s)*l*.5,e[9]=(o-a)*c*.5,e[10]=r/(n-r),e[11]=-1,e[12]=0,e[13]=0,e[14]=r*n/(n-r),e[15]=0,e}function j(e,t,n,r,o,a,i){var s=1/(t-n),l=1/(r-o),c=1/(a-i);return e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*l,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=2*c,e[11]=0,e[12]=(t+n)*s,e[13]=(o+r)*l,e[14]=(i+a)*c,e[15]=1,e}var K=j;function $(e,t,n,r,o,a,i){var s=1/(t-n),l=1/(r-o),c=1/(a-i);return e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*l,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=c,e[11]=0,e[12]=(t+n)*s,e[13]=(o+r)*l,e[14]=a*c,e[15]=1,e}function q(e,t,n,r){var o,i,s,l,c,u,d,p,f,m,h=t[0],v=t[1],T=t[2],y=r[0],b=r[1],x=r[2],C=n[0],S=n[1],A=n[2];return Math.abs(h-C)<a&&Math.abs(v-S)<a&&Math.abs(T-A)<a?g(e):(d=h-C,p=v-S,f=T-A,o=b*(f*=m=1/Math.hypot(d,p,f))-x*(p*=m),i=x*(d*=m)-y*f,s=y*p-b*d,(m=Math.hypot(o,i,s))?(o*=m=1/m,i*=m,s*=m):(o=0,i=0,s=0),l=p*s-f*i,c=f*o-d*s,u=d*i-p*o,(m=Math.hypot(l,c,u))?(l*=m=1/m,c*=m,u*=m):(l=0,c=0,u=0),e[0]=o,e[1]=l,e[2]=d,e[3]=0,e[4]=i,e[5]=c,e[6]=p,e[7]=0,e[8]=s,e[9]=u,e[10]=f,e[11]=0,e[12]=-(o*h+i*v+s*T),e[13]=-(l*h+c*v+u*T),e[14]=-(d*h+p*v+f*T),e[15]=1,e)}function X(e,t,n,r){var o=t[0],a=t[1],i=t[2],s=r[0],l=r[1],c=r[2],u=o-n[0],d=a-n[1],p=i-n[2],f=u*u+d*d+p*p;f>0&&(u*=f=1/Math.sqrt(f),d*=f,p*=f);var g=l*p-c*d,m=c*u-s*p,h=s*d-l*u;return(f=g*g+m*m+h*h)>0&&(g*=f=1/Math.sqrt(f),m*=f,h*=f),e[0]=g,e[1]=m,e[2]=h,e[3]=0,e[4]=d*h-p*m,e[5]=p*g-u*h,e[6]=u*m-d*g,e[7]=0,e[8]=u,e[9]=d,e[10]=p,e[11]=0,e[12]=o,e[13]=a,e[14]=i,e[15]=1,e}function Y(e){return"mat4("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+", "+e[6]+", "+e[7]+", "+e[8]+", "+e[9]+", "+e[10]+", "+e[11]+", "+e[12]+", "+e[13]+", "+e[14]+", "+e[15]+")"}function Z(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8],e[9],e[10],e[11],e[12],e[13],e[14],e[15])}function Q(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e[4]=t[4]+n[4],e[5]=t[5]+n[5],e[6]=t[6]+n[6],e[7]=t[7]+n[7],e[8]=t[8]+n[8],e[9]=t[9]+n[9],e[10]=t[10]+n[10],e[11]=t[11]+n[11],e[12]=t[12]+n[12],e[13]=t[13]+n[13],e[14]=t[14]+n[14],e[15]=t[15]+n[15],e}function J(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e[4]=t[4]-n[4],e[5]=t[5]-n[5],e[6]=t[6]-n[6],e[7]=t[7]-n[7],e[8]=t[8]-n[8],e[9]=t[9]-n[9],e[10]=t[10]-n[10],e[11]=t[11]-n[11],e[12]=t[12]-n[12],e[13]=t[13]-n[13],e[14]=t[14]-n[14],e[15]=t[15]-n[15],e}function ee(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*n,e[5]=t[5]*n,e[6]=t[6]*n,e[7]=t[7]*n,e[8]=t[8]*n,e[9]=t[9]*n,e[10]=t[10]*n,e[11]=t[11]*n,e[12]=t[12]*n,e[13]=t[13]*n,e[14]=t[14]*n,e[15]=t[15]*n,e}function te(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e[3]=t[3]+n[3]*r,e[4]=t[4]+n[4]*r,e[5]=t[5]+n[5]*r,e[6]=t[6]+n[6]*r,e[7]=t[7]+n[7]*r,e[8]=t[8]+n[8]*r,e[9]=t[9]+n[9]*r,e[10]=t[10]+n[10]*r,e[11]=t[11]+n[11]*r,e[12]=t[12]+n[12]*r,e[13]=t[13]+n[13]*r,e[14]=t[14]+n[14]*r,e[15]=t[15]+n[15]*r,e}function ne(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]&&e[9]===t[9]&&e[10]===t[10]&&e[11]===t[11]&&e[12]===t[12]&&e[13]===t[13]&&e[14]===t[14]&&e[15]===t[15]}function re(e,t){var n=e[0],r=e[1],o=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=e[9],f=e[10],g=e[11],m=e[12],h=e[13],v=e[14],T=e[15],y=t[0],b=t[1],x=t[2],C=t[3],S=t[4],A=t[5],I=t[6],w=t[7],O=t[8],P=t[9],R=t[10],M=t[11],E=t[12],V=t[13],D=t[14],L=t[15];return Math.abs(n-y)<=a*Math.max(1,Math.abs(n),Math.abs(y))&&Math.abs(r-b)<=a*Math.max(1,Math.abs(r),Math.abs(b))&&Math.abs(o-x)<=a*Math.max(1,Math.abs(o),Math.abs(x))&&Math.abs(i-C)<=a*Math.max(1,Math.abs(i),Math.abs(C))&&Math.abs(s-S)<=a*Math.max(1,Math.abs(s),Math.abs(S))&&Math.abs(l-A)<=a*Math.max(1,Math.abs(l),Math.abs(A))&&Math.abs(c-I)<=a*Math.max(1,Math.abs(c),Math.abs(I))&&Math.abs(u-w)<=a*Math.max(1,Math.abs(u),Math.abs(w))&&Math.abs(d-O)<=a*Math.max(1,Math.abs(d),Math.abs(O))&&Math.abs(p-P)<=a*Math.max(1,Math.abs(p),Math.abs(P))&&Math.abs(f-R)<=a*Math.max(1,Math.abs(f),Math.abs(R))&&Math.abs(g-M)<=a*Math.max(1,Math.abs(g),Math.abs(M))&&Math.abs(m-E)<=a*Math.max(1,Math.abs(m),Math.abs(E))&&Math.abs(h-V)<=a*Math.max(1,Math.abs(h),Math.abs(V))&&Math.abs(v-D)<=a*Math.max(1,Math.abs(v),Math.abs(D))&&Math.abs(T-L)<=a*Math.max(1,Math.abs(T),Math.abs(L))}var oe=y,ae=J;function ie(){var e=new i(9);return i!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[5]=0,e[6]=0,e[7]=0),e[0]=1,e[4]=1,e[8]=1,e}function se(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[4],e[4]=t[5],e[5]=t[6],e[6]=t[8],e[7]=t[9],e[8]=t[10],e}function le(e){var t=new i(9);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t}function ce(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e}function ue(e,t,n,r,o,a,s,l,c){var u=new i(9);return u[0]=e,u[1]=t,u[2]=n,u[3]=r,u[4]=o,u[5]=a,u[6]=s,u[7]=l,u[8]=c,u}function de(e,t,n,r,o,a,i,s,l,c){return e[0]=t,e[1]=n,e[2]=r,e[3]=o,e[4]=a,e[5]=i,e[6]=s,e[7]=l,e[8]=c,e}function pe(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function fe(e,t){if(e===t){var n=t[1],r=t[2],o=t[5];e[1]=t[3],e[2]=t[6],e[3]=n,e[5]=t[7],e[6]=r,e[7]=o}else e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8];return e}function ge(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=u*i-s*c,p=-u*a+s*l,f=c*a-i*l,g=n*d+r*p+o*f;return g?(g=1/g,e[0]=d*g,e[1]=(-u*r+o*c)*g,e[2]=(s*r-o*i)*g,e[3]=p*g,e[4]=(u*n-o*l)*g,e[5]=(-s*n+o*a)*g,e[6]=f*g,e[7]=(-c*n+r*l)*g,e[8]=(i*n-r*a)*g,e):null}function me(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8];return e[0]=i*u-s*c,e[1]=o*c-r*u,e[2]=r*s-o*i,e[3]=s*l-a*u,e[4]=n*u-o*l,e[5]=o*a-n*s,e[6]=a*c-i*l,e[7]=r*l-n*c,e[8]=n*i-r*a,e}function he(e){var t=e[0],n=e[1],r=e[2],o=e[3],a=e[4],i=e[5],s=e[6],l=e[7],c=e[8];return t*(c*a-i*l)+n*(-c*o+i*s)+r*(l*o-a*s)}function ve(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=n[0],f=n[1],g=n[2],m=n[3],h=n[4],v=n[5],T=n[6],y=n[7],b=n[8];return e[0]=p*r+f*i+g*c,e[1]=p*o+f*s+g*u,e[2]=p*a+f*l+g*d,e[3]=m*r+h*i+v*c,e[4]=m*o+h*s+v*u,e[5]=m*a+h*l+v*d,e[6]=T*r+y*i+b*c,e[7]=T*o+y*s+b*u,e[8]=T*a+y*l+b*d,e}function Te(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=n[0],f=n[1];return e[0]=r,e[1]=o,e[2]=a,e[3]=i,e[4]=s,e[5]=l,e[6]=p*r+f*i+c,e[7]=p*o+f*s+u,e[8]=p*a+f*l+d,e}function ye(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=Math.sin(n),f=Math.cos(n);return e[0]=f*r+p*i,e[1]=f*o+p*s,e[2]=f*a+p*l,e[3]=f*i-p*r,e[4]=f*s-p*o,e[5]=f*l-p*a,e[6]=c,e[7]=u,e[8]=d,e}function be(e,t,n){var r=n[0],o=n[1];return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=o*t[3],e[4]=o*t[4],e[5]=o*t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e}function xe(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=t[0],e[7]=t[1],e[8]=1,e}function Ce(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=n,e[2]=0,e[3]=-n,e[4]=r,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function Se(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=t[1],e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function Ae(e,t){return e[0]=t[0],e[1]=t[1],e[2]=0,e[3]=t[2],e[4]=t[3],e[5]=0,e[6]=t[4],e[7]=t[5],e[8]=1,e}function Ie(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=n+n,s=r+r,l=o+o,c=n*i,u=r*i,d=r*s,p=o*i,f=o*s,g=o*l,m=a*i,h=a*s,v=a*l;return e[0]=1-d-g,e[3]=u-v,e[6]=p+h,e[1]=u+v,e[4]=1-c-g,e[7]=f-m,e[2]=p-h,e[5]=f+m,e[8]=1-c-d,e}function we(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15],T=n*s-r*i,y=n*l-o*i,b=n*c-a*i,x=r*l-o*s,C=r*c-a*s,S=o*c-a*l,A=u*m-d*g,I=u*h-p*g,w=u*v-f*g,O=d*h-p*m,P=d*v-f*m,R=p*v-f*h,M=T*R-y*P+b*O+x*w-C*I+S*A;return M?(M=1/M,e[0]=(s*R-l*P+c*O)*M,e[1]=(l*w-i*R-c*I)*M,e[2]=(i*P-s*w+c*A)*M,e[3]=(o*P-r*R-a*O)*M,e[4]=(n*R-o*w+a*I)*M,e[5]=(r*w-n*P-a*A)*M,e[6]=(m*S-h*C+v*x)*M,e[7]=(h*b-g*S-v*y)*M,e[8]=(g*C-m*b+v*T)*M,e):null}function Oe(e,t,n){return e[0]=2/t,e[1]=0,e[2]=0,e[3]=0,e[4]=-2/n,e[5]=0,e[6]=-1,e[7]=1,e[8]=1,e}function Pe(e){return"mat3("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+", "+e[6]+", "+e[7]+", "+e[8]+")"}function Re(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8])}function Me(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e[4]=t[4]+n[4],e[5]=t[5]+n[5],e[6]=t[6]+n[6],e[7]=t[7]+n[7],e[8]=t[8]+n[8],e}function Ee(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e[4]=t[4]-n[4],e[5]=t[5]-n[5],e[6]=t[6]-n[6],e[7]=t[7]-n[7],e[8]=t[8]-n[8],e}function Ve(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*n,e[5]=t[5]*n,e[6]=t[6]*n,e[7]=t[7]*n,e[8]=t[8]*n,e}function De(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e[3]=t[3]+n[3]*r,e[4]=t[4]+n[4]*r,e[5]=t[5]+n[5]*r,e[6]=t[6]+n[6]*r,e[7]=t[7]+n[7]*r,e[8]=t[8]+n[8]*r,e}function Le(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]}function Be(e,t){var n=e[0],r=e[1],o=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=t[0],f=t[1],g=t[2],m=t[3],h=t[4],v=t[5],T=t[6],y=t[7],b=t[8];return Math.abs(n-p)<=a*Math.max(1,Math.abs(n),Math.abs(p))&&Math.abs(r-f)<=a*Math.max(1,Math.abs(r),Math.abs(f))&&Math.abs(o-g)<=a*Math.max(1,Math.abs(o),Math.abs(g))&&Math.abs(i-m)<=a*Math.max(1,Math.abs(i),Math.abs(m))&&Math.abs(s-h)<=a*Math.max(1,Math.abs(s),Math.abs(h))&&Math.abs(l-v)<=a*Math.max(1,Math.abs(l),Math.abs(v))&&Math.abs(c-T)<=a*Math.max(1,Math.abs(c),Math.abs(T))&&Math.abs(u-y)<=a*Math.max(1,Math.abs(u),Math.abs(y))&&Math.abs(d-b)<=a*Math.max(1,Math.abs(d),Math.abs(b))}var Ne=ve,Fe=Ee,_e=n(730),ke=n.n(_e),Ge=n(59);const Ue=n.n(Ge)()(),ze={vtkObject:()=>null};function We(e){if(null==e)return e;if(e.isA)return e;if(!e.vtkClass)return Ue.console&&Ue.console.error&&Ue.console.error("Invalid VTK object"),null;const t=ze[e.vtkClass];if(!t)return Ue.console&&Ue.console.error&&Ue.console.error(`No vtk class found for Object of type ${e.vtkClass}`),null;const n={...e};Object.keys(n).forEach((e=>{n[e]&&"object"==typeof n[e]&&n[e].vtkClass&&(n[e]=We(n[e]))}));const r=t(n);return r&&r.modified&&r.modified(),r}We.register=function(e,t){ze[e]=t};class He extends Array{push(){for(let e=0;e<arguments.length;e++)this.includes(arguments[e])||super.push(arguments[e]);return this.length}}let je=0;const Ke=e=>{throw new Error(`Named parameter '${e}' is missing`)},$e=Symbol("void"),qe={};function Xe(){}["log","debug","info","warn","error","time","timeEnd","group","groupEnd"].forEach((e=>{qe[e]=Xe})),Ue.console=console.hasOwnProperty("log")?console:qe;const Ye={debug:Xe,error:Ue.console.error||Xe,info:Ue.console.info||Xe,log:Ue.console.log||Xe,warn:Ue.console.warn||Xe};function Ze(e,t){Ye[e]&&(Ye[e]=t||Xe)}function Qe(){Ye.log(...arguments)}function Je(){Ye.info(...arguments)}function et(){Ye.debug(...arguments)}function tt(){Ye.error(...arguments)}function nt(){Ye.warn(...arguments)}const rt={};function ot(e){rt[e]||(Ye.error(e),rt[e]=!0)}const at=Object.create(null);at.Float32Array=Float32Array,at.Float64Array=Float64Array,at.Uint8Array=Uint8Array,at.Int8Array=Int8Array,at.Uint16Array=Uint16Array,at.Int16Array=Int16Array,at.Uint32Array=Uint32Array,at.Int32Array=Int32Array,at.Uint8ClampedArray=Uint8ClampedArray;try{at.BigInt64Array=BigInt64Array,at.BigUint64Array=BigUint64Array}catch{}function it(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return new(at[e]||Float64Array)(...n)}function st(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return(at[e]||Float64Array).from(...n)}function lt(e){return e.charAt(0).toUpperCase()+e.slice(1)}function ct(e){return lt("_"===e[0]?e.slice(1):e)}function ut(e){return e.charAt(0).toLowerCase()+e.slice(1)}function dt(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1e3;const r=["TB","GB","MB","KB"];let o=Number(e),a="B";for(;o>n;)o/=n,a=r.pop();return`${o.toFixed(t)} ${a}`}function pt(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:" ";const n=[];let r=e;for(;r>1e3;)n.push(("000"+r%1e3).slice(-3)),r=Math.floor(r/1e3);return r>0&&n.push(r),n.reverse(),n.join(t)}function ft(e){Object.keys(e).forEach((t=>{Array.isArray(e[t])&&(e[t]=[].concat(e[t]))}))}function gt(e){return e&&e.isA?e.getState():e}function mt(e){setTimeout(e,0)}function ht(e,t){const n=performance.now();e.finally((()=>{const e=performance.now()-n;t(e)}))}function vt(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};ft(t);const n=[];if(Number.isInteger(t.mtime)||(t.mtime=++je),"classHierarchy"in t){if(!(t.classHierarchy instanceof He)){const e=new He;for(let n=0;n<t.classHierarchy.length;n++)e.push(t.classHierarchy[n]);t.classHierarchy=e}}else t.classHierarchy=new He("vtkObject");function r(e){n[e]=null}return e.isDeleted=()=>!!t.deleted,e.modified=r=>{t.deleted?tt("instance deleted - cannot call any method"):r&&r<e.getMTime()||(t.mtime=++je,n.forEach((t=>t&&t(e))))},e.onModified=e=>{if(t.deleted)return tt("instance deleted - cannot call any method"),null;const o=n.length;return n.push(e),function(e){return Object.freeze({unsubscribe:function(){r(e)}})}(o)},e.getMTime=()=>t.mtime,e.isA=e=>{let n=t.classHierarchy.length;for(;n--;)if(t.classHierarchy[n]===e)return!0;return!1},e.getClassName=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.classHierarchy[t.classHierarchy.length-1-e]},e.set=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=arguments.length>1&&void 0!==arguments[1]&&arguments[1],o=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=!1;return Object.keys(n).forEach((i=>{const s=o?null:e[`set${lt(i)}`];s&&Array.isArray(n[i])&&s.length>1?a=s(...n[i])||a:s?a=s(n[i])||a:(-1!==["mtime"].indexOf(i)||r||nt(`Warning: Set value to model directly ${i}, ${n[i]}`),a=t[i]!==n[i]||a,t[i]=n[i])})),a},e.get=function(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];if(!n.length)return t;const o={};return n.forEach((e=>{o[e]=t[e]})),o},e.getReferenceByName=e=>t[e],e.delete=()=>{Object.keys(t).forEach((e=>delete t[e])),n.forEach(((e,t)=>r(t))),t.deleted=!0},e.getState=()=>{if(t.deleted)return null;const n={...t,vtkClass:e.getClassName()};Object.keys(n).forEach((e=>{null===n[e]||void 0===n[e]||"_"===e[0]?delete n[e]:n[e].isA?n[e]=n[e].getState():Array.isArray(n[e])?n[e]=n[e].map(gt):function(e){return Object.values(at).some((t=>e instanceof t))}(n[e])&&(n[e]=Array.from(n[e]))}));const r={};return Object.keys(n).sort().forEach((e=>{r[e]=n[e]})),r.mtime&&delete r.mtime,r},e.shallowCopy=function(n){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(n.getClassName()!==e.getClassName())throw new Error(`Cannot ShallowCopy ${n.getClassName()} into ${e.getClassName()}`);const o=n.get(),a=Object.keys(t).sort();Object.keys(o).sort().forEach((e=>{const n=a.indexOf(e);-1===n?r&&et(`add ${e} in shallowCopy`):a.splice(n,1),t[e]=o[e]})),a.length&&r&&et(`Untouched keys: ${a.join(", ")}`),e.modified()},e.toJSON=function(){return e.getState()},e}const Tt={object(e,t,n){return function(){return{...t[n.name]}}}};function yt(e,t,n){n.forEach((n=>{if("object"==typeof n){const r=Tt[n.type];e[`get${ct(n.name)}`]=r?r(e,t,n):()=>t[n.name]}else e[`get${ct(n)}`]=()=>t[n]}))}const bt={enum(e,t,n){const r=`_on${ct(n.name)}Changed`;return o=>{if("string"==typeof o){if(void 0!==n.enum[o])return t[n.name]!==n.enum[o]&&(t[n.name]=n.enum[o],e.modified(),!0);throw tt(`Set Enum with invalid argument ${n}, ${o}`),new RangeError("Set Enum with invalid string argument")}if("number"==typeof o){if(t[n.name]!==o){if(-1!==Object.keys(n.enum).map((e=>n.enum[e])).indexOf(o)){const a=t[n.name];return t[n.name]=o,t[r]?.(e,t,o,a),e.modified(),!0}throw tt(`Set Enum outside numeric range ${n}, ${o}`),new RangeError("Set Enum outside numeric range")}return!1}throw tt(`Set Enum with invalid argument (String/Number) ${n}, ${o}`),new TypeError("Set Enum with invalid argument (String/Number)")}},object(e,t,n){1===n.params?.length&&nt('Setter of type "object" with a single "param" field is not supported');const r=`_on${ct(n.name)}Changed`;return function(){for(var o=arguments.length,a=new Array(o),i=0;i<o;i++)a[i]=arguments[i];let s;if(s=a.length>1&&n.params?.length?n.params.reduce(((e,t,n)=>Object.assign(e,{[t]:a[n]})),{}):a[0],!ke()(t[n.name],s)){const o=t[n.name];return t[n.name]=s,t[r]?.(e,t,s,o),e.modified(),!0}return!1}}};function xt(e){if("object"==typeof e){const t=bt[e.type];if(t)return(n,r)=>t(n,r,e);throw tt(`No setter for field ${e}`),new TypeError("No setter for field")}return function(t,n){const r=`_on${ct(e)}Changed`;return function(o){if(n.deleted)return tt("instance deleted - cannot call any method"),!1;if(n[e]!==o){const a=n[e.name];return n[e]=o,n[r]?.(t,n,o,a),t.modified(),!0}return!1}}}function Ct(e,t,n){n.forEach((n=>{"object"==typeof n?e[`set${ct(n.name)}`]=xt(n)(e,t):e[`set${ct(n)}`]=xt(n)(e,t)}))}function St(e,t,n){yt(e,t,n),Ct(e,t,n)}function At(e,t,n){n.forEach((n=>{e[`get${ct(n)}`]=()=>t[n]?Array.from(t[n]):t[n],e[`get${ct(n)}ByReference`]=()=>t[n]}))}function It(e,t,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:void 0;n.forEach((n=>{if(t[n]&&r&&t[n].length!==r)throw new RangeError(`Invalid initial number of values for array (${n})`);const a=`_on${ct(n)}Changed`;e[`set${ct(n)}`]=function(){if(t.deleted)return tt("instance deleted - cannot call any method"),!1;for(var i=arguments.length,s=new Array(i),l=0;l<i;l++)s[l]=arguments[l];let c,u=s,d=!1;if(1===u.length&&(null==u[0]||u[0].length>=0)&&(u=u[0],d=!0),null==u)c=t[n]!==u;else{if(r&&u.length!==r){if(!(u.length<r&&void 0!==o))throw new RangeError(`Invalid number of values for array setter (${n})`);for(u=Array.from(u),d=!1;u.length<r;)u.push(o)}c=null==t[n]||t[n].length!==u.length;for(let e=0;!c&&e<u.length;++e)c=t[n][e]!==u[e];c&&d&&(u=Array.from(u))}if(c){const r=t[n.name];t[n]=u,t[a]?.(e,t,u,r),e.modified()}return c},e[`set${ct(n)}From`]=e=>{const r=t[n];e.forEach(((e,t)=>{r[t]=e}))}}))}function wt(e,t,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:void 0;At(e,t,n),It(e,t,n,r,o)}function Ot(e,t,n){for(let e=0;e<n.length;e++){const r=n[e];void 0!==t[r]&&(t[`_${r}`]=t[r],delete t[r])}}function Pt(e,t,n,r){function o(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;t.deleted?tt("instance deleted - cannot call any method"):r>=t.numberOfInputs?tt(`algorithm ${e.getClassName()} only has ${t.numberOfInputs} input ports. To add more input ports, use addInputData()`):(t.inputData[r]!==n||t.inputConnection[r])&&(t.inputData[r]=n,t.inputConnection[r]=null,e.modified&&e.modified())}function a(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(t.deleted)tt("instance deleted - cannot call any method");else{if(r>=t.numberOfInputs){let n=`algorithm ${e.getClassName()} only has `;return n+=`${t.numberOfInputs}`,n+=" input ports. To add more input ports, use addInputConnection()",void tt(n)}t.inputData[r]=null,t.inputConnection[r]=n}}function i(){let e=t.numberOfInputs;for(;e&&!t.inputData[e-1]&&!t.inputConnection[e-1];)e--;return e===t.numberOfInputs&&t.numberOfInputs++,e}function s(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.deleted?(tt("instance deleted - cannot call any method"),null):(e.shouldUpdate()&&e.update(),t.output[n])}if(t.inputData?t.inputData=t.inputData.map(We):t.inputData=[],t.inputConnection?t.inputConnection=t.inputConnection.map(We):t.inputConnection=[],t.output?t.output=t.output.map(We):t.output=[],t.inputArrayToProcess?t.inputArrayToProcess=t.inputArrayToProcess.map(We):t.inputArrayToProcess=[],t.numberOfInputs=n,e.shouldUpdate=()=>{const n=e.getMTime();let o=1/0,a=r;for(;a--;){if(!t.output[a]||t.output[a].isDeleted())return!0;const e=t.output[a].getMTime();if(e<n)return!0;e<o&&(o=e)}for(a=t.numberOfInputs;a--;)if(t.inputConnection[a]?.filter.shouldUpdate()||e.getInputData(a)?.getMTime()>o)return!0;return!1},t.numberOfInputs){let n=t.numberOfInputs;for(;n--;)t.inputData.push(null),t.inputConnection.push(null);e.setInputData=o,e.setInputConnection=a,e.addInputData=function(e){t.deleted?tt("instance deleted - cannot call any method"):o(e,i())},e.addInputConnection=function(e){t.deleted?tt("instance deleted - cannot call any method"):a(e,i())},e.getInputData=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.inputConnection[e]&&(t.inputData[e]=t.inputConnection[e]()),t.inputData[e]},e.getInputConnection=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.inputConnection[e]}}r&&(e.getOutputData=s,e.getOutputPort=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const n=()=>s(t);return n.filter=e,n}),e.update=()=>{const n=[];if(t.numberOfInputs){let r=0;for(;r<t.numberOfInputs;)n[r]=e.getInputData(r),r++}e.requestData&&e.shouldUpdate()&&e.requestData(n,t.output)},e.getNumberOfInputPorts=()=>t.numberOfInputs,e.getNumberOfOutputPorts=()=>r||t.output.length,e.getInputArrayToProcess=e=>{const n=t.inputArrayToProcess[e],r=t.inputData[e];return n&&r?r[`get${n.fieldAssociation}`]().getArray(n.arrayName):null},e.setInputArrayToProcess=function(e,n,r){let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"Scalars";for(;t.inputArrayToProcess.length<e;)t.inputArrayToProcess.push(null);t.inputArrayToProcess[e]={arrayName:n,fieldAssociation:r,attributeType:o}}}const Rt=Symbol("Event abort");function Mt(e,t,n){const r=[],o=e.delete;let a=1;function i(e){for(let t=0;t<r.length;++t){const[n]=r[t];if(n===e)return void r.splice(t,1)}}e[`invoke${ct(n)}`]=function(){if(t.deleted)return void tt("instance deleted - cannot call any method");const n=r.slice();for(let t=0;t<n.length;++t){const[,r,o]=n[t];if(r)if(o<0)setTimeout((()=>r.apply(e,arguments)),1-o);else if(r.apply(e,arguments)===Rt)break}},e[`on${ct(n)}`]=function(e){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!e.apply)return console.error(`Invalid callback for event ${n}`),null;if(t.deleted)return tt("instance deleted - cannot call any method"),null;const s=a++;return r.push([s,e,o]),r.sort(((e,t)=>t[2]-e[2])),function(e){return Object.freeze({unsubscribe:function(){i(e)}})}(s)},e.delete=()=>{o(),r.forEach((e=>{let[t]=e;return i(t)}))}}function Et(e,t){const n=function(){const t={};return e(t,{},arguments.length>0&&void 0!==arguments[0]?arguments[0]:{}),Object.freeze(t)};return t&&We.register(t,n),n}function Vt(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return function(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];return t.filter((e=>!!e)).map((e=>e(...n)))}}function Dt(e){return e&&e.isA&&e.isA("vtkObject")}function Lt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[];if(Dt(e)){if(r.indexOf(e)>=0)return n;r.push(e);const o=t(e);void 0!==o&&n.push(o);const a=e.get();Object.keys(a).forEach((e=>{const o=a[e];Array.isArray(o)?o.forEach((e=>{Lt(e,t,n,r)})):Lt(o,t,n,r)}))}return n}function Bt(e,t,n){var r=this;let o;const a=function(){for(var a=arguments.length,i=new Array(a),s=0;s<a;s++)i[s]=arguments[s];const l=r,c=n&&!o;clearTimeout(o),o=setTimeout((()=>{o=null,n||e.apply(l,i)}),t),c&&e.apply(l,i)};return a.cancel=()=>clearTimeout(o),a}function Nt(e,t){let n=!1,r=null;function o(){n=!1,null!==r&&(a(...r),r=null)}function a(){for(var a=arguments.length,i=new Array(a),s=0;s<a;s++)i[s]=arguments[s];n?r=i:(n=!0,e(...i),setTimeout(o,t))}return a}function Ft(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};t.keystore=Object.assign(t.keystore||{},n),e.setKey=(e,n)=>{t.keystore[e]=n},e.getKey=e=>t.keystore[e],e.getAllKeys=()=>Object.keys(t.keystore),e.deleteKey=e=>delete t.keystore[e],e.clearKeystore=()=>e.getAllKeys().forEach((e=>delete t.keystore[e]))}let _t=1;const kt="__root__";function Gt(e,t){Ft(e,t);const n=e.delete;t.proxyId=""+_t++,t.ui=JSON.parse(JSON.stringify(t.ui||[])),yt(e,t,["proxyId","proxyGroup","proxyName"]),St(e,t,["proxyManager"]);const r={},o={};function a(e,t){o[t]||(o[t]=[]);const n=o[t];for(let t=0;t<e.length;t++)n.push(e[t].name),r[e[t].name]=e[t],e[t].children&&e[t].children.length&&a(e[t].children,e[t].name)}function i(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:kt;const r=[],a=t.proxyId,s=function(){return o[arguments.length>0&&void 0!==arguments[0]?arguments[0]:kt]}(n)||[];for(let t=0;t<s.length;t++){const n=s[t],o=e[`get${ct(n)}`],l={id:a,name:n,value:o?o():void 0},c=i(n);c.length&&(l.children=c),r.push(l)}return r}a(t.ui,kt),e.updateUI=n=>{t.ui=JSON.parse(JSON.stringify(n||[])),Object.keys(r).forEach((e=>delete r[e])),Object.keys(o).forEach((e=>delete o[e])),a(t.ui,kt),e.modified()},e.updateProxyProperty=(e,t)=>{const n=r[e];n?Object.assign(n,t):r[e]={...t}},e.activate=()=>{if(t.proxyManager){const n=`setActive${ct(e.getProxyGroup().slice(0,-1))}`;t.proxyManager[n]&&t.proxyManager[n](e)}},t.propertyLinkSubscribers={},e.registerPropertyLinkForGC=(e,n)=>{n in t.propertyLinkSubscribers||(t.propertyLinkSubscribers[n]=[]),t.propertyLinkSubscribers[n].push(e)},e.gcPropertyLinks=n=>{const r=t.propertyLinkSubscribers[n]||[];for(;r.length;)r.pop().unbind(e)},t.propertyLinkMap={},e.getPropertyLink=function(e){let n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(t.propertyLinkMap[e])return t.propertyLinkMap[e];let r=null;const o=[];let a=0,i=!1;function s(n){let s=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(i)return null;const l=[];let c=null;for(a=o.length;a--;){const e=o[a];e.instance===n?c=e:l.push(e)}if(!c)return null;const u=c.instance[`get${ct(c.propertyName)}`]();if(!function(e,t){if(e===t)return!0;if(Array.isArray(e)&&Array.isArray(t)){if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}return!1}(u,r)||s){for(r=u,i=!0;l.length;){const e=l.pop();e.instance.set({[e.propertyName]:r})}i=!1}return t.propertyLinkMap[e].persistent&&(t.propertyLinkMap[e].value=u),u}function l(e,t){const n=[];for(a=o.length;a--;){const r=o[a];r.instance!==e||r.propertyName!==t&&void 0!==t||(r.subscription.unsubscribe(),n.push(a))}for(;n.length;)o.splice(n.pop(),1)}const c={bind:function(n,r){let a=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const i=n.onModified(s),c=o[0];return o.push({instance:n,propertyName:r,subscription:i}),a&&(t.propertyLinkMap[e].persistent&&void 0!==t.propertyLinkMap[e].value?n.set({[r]:t.propertyLinkMap[e].value}):c&&s(c.instance,!0)),{unsubscribe:()=>l(n,r)}},unbind:l,unsubscribe:function(){for(;o.length;)o.pop().subscription.unsubscribe()},persistent:n};return t.propertyLinkMap[e]=c,c},e.listPropertyNames=()=>i().map((e=>e.name)),e.getPropertyByName=e=>i().find((t=>t.name===e)),e.getPropertyDomainByName=e=>(r[e]||{}).domain,e.getProxySection=()=>({id:t.proxyId,name:t.proxyGroup,ui:t.ui,properties:i()}),e.delete=()=>{const r=Object.keys(t.propertyLinkMap);let o=r.length;for(;o--;)t.propertyLinkMap[r[o]].unsubscribe();Object.keys(t.propertyLinkSubscribers).forEach(e.gcPropertyLinks),n()},e.getState=()=>null,mt((function(){if(t.links)for(let n=0;n<t.links.length;n++){const{link:r,property:o,persistent:a,updateOnBind:i,type:s}=t.links[n];if("application"===s){const n=t.proxyManager.getPropertyLink(r,a);e.registerPropertyLinkForGC(n,"application"),n.bind(e,o,i)}}}))}function Ut(e,t,n){const r=e.delete,o=[],a=Object.keys(n);let i=a.length;for(;i--;){const r=a[i],{modelKey:s,property:l,modified:c=!0}=n[r],u=ct(l),d=ct(r);e[`get${d}`]=t[s][`get${u}`],e[`set${d}`]=t[s][`set${u}`],c&&o.push(t[s].onModified(e.modified))}e.delete=()=>{for(;o.length;)o.pop().unsubscribe();r()}}function zt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};function o(e){const n=Object.keys(e);let r=n.length;for(;r--;){const o=n[r];t[o].set(e[o])}}t.this=e;const a=Object.keys(r);let i=a.length;for(;i--;){const s=a[i];t[s]=r[s];const l=n[s];e[`set${ct(s)}`]=n=>{n!==t[s]&&(t[s]=n,o(l[n]),e.modified())}}a.length&&yt(e,t,a)}function Wt(e){let t=0,n=0,r=0,o=0;return"detail"in e&&(n=e.detail),"wheelDelta"in e&&(n=-e.wheelDelta/120),"wheelDeltaY"in e&&(n=-e.wheelDeltaY/120),"wheelDeltaX"in e&&(t=-e.wheelDeltaX/120),"axis"in e&&e.axis===e.HORIZONTAL_AXIS&&(t=n,n=0),r=10*t,o=10*n,"deltaY"in e&&(o=e.deltaY),"deltaX"in e&&(r=e.deltaX),(r||o)&&e.deltaMode&&(1===e.deltaMode?(r*=40,o*=40):(r*=800,o*=800)),r&&!t&&(t=r<1?-1:1),o&&!n&&(n=o<1?-1:1),{spinX:t,spinY:n||t,pixelX:r,pixelY:o||r}}var Ht={algo:Pt,capitalize:lt,chain:Vt,debounce:Bt,enumToString:function(e,t){return Object.keys(e).find((n=>e[n]===t))},event:Mt,EVENT_ABORT:Rt,formatBytesToProperUnit:dt,formatNumbersWithThousandSeparator:pt,get:yt,getArray:At,getCurrentGlobalMTime:function(){return je},getStateArrayMapFunc:gt,isVtkObject:Dt,keystore:Ft,measurePromiseExecution:ht,moveToProtected:Ot,newInstance:Et,newTypedArray:it,newTypedArrayFrom:st,normalizeWheel:Wt,obj:vt,proxy:Gt,proxyPropertyMapping:Ut,proxyPropertyState:zt,safeArrays:ft,set:Ct,setArray:It,setGet:St,setGetArray:wt,setImmediate:mt,setLoggerFunction:Ze,throttle:Nt,traverseInstanceTree:Lt,TYPED_ARRAYS:at,uncapitalize:ut,VOID:$e,vtkDebugMacro:et,vtkErrorMacro:tt,vtkInfoMacro:Je,vtkLogMacro:Qe,vtkOnceErrorMacro:ot,vtkWarningMacro:nt,objectSetterMap:bt,requiredParam:Ke},jt=Object.freeze({__proto__:null,requiredParam:Ke,VOID:$e,setLoggerFunction:Ze,vtkLogMacro:Qe,vtkInfoMacro:Je,vtkDebugMacro:et,vtkErrorMacro:tt,vtkWarningMacro:nt,vtkOnceErrorMacro:ot,TYPED_ARRAYS:at,newTypedArray:it,newTypedArrayFrom:st,capitalize:lt,_capitalize:ct,uncapitalize:ut,formatBytesToProperUnit:dt,formatNumbersWithThousandSeparator:pt,setImmediateVTK:mt,measurePromiseExecution:ht,obj:vt,get:yt,set:Ct,setGet:St,getArray:At,setArray:It,setGetArray:wt,moveToProtected:Ot,algo:Pt,EVENT_ABORT:Rt,event:Mt,newInstance:Et,chain:Vt,isVtkObject:Dt,traverseInstanceTree:Lt,debounce:Bt,throttle:Nt,keystore:Ft,proxy:Gt,proxyPropertyMapping:Ut,proxyPropertyState:zt,normalizeWheel:Wt,default:Ht});const{vtkErrorMacro:Kt}=Ht,$t={renderable:null,myFactory:null,children:[],visited:!1};function qt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,$t,n),Ht.obj(e,t),Ht.event(e,t,"event"),t._renderableChildMap=new Map,Ht.get(e,t,["visited"]),Ht.setGet(e,t,["_parent","renderable","myFactory"]),Ht.getArray(e,t,["children"]),Ht.moveToProtected(e,t,["parent"]),function(e,t){t.classHierarchy.push("vtkViewNode"),e.build=e=>{},e.render=e=>{},e.traverse=n=>{const r=n.getTraverseOperation(),o=e[r];if(o)o(n);else{e.apply(n,!0);for(let e=0;e<t.children.length;e++)t.children[e].traverse(n);e.apply(n,!1)}},e.apply=(t,n)=>{const r=e[t.getOperation()];r&&r(n,t)},e.getViewNodeFor=n=>{if(t.renderable===n)return e;for(let e=0;e<t.children.length;++e){const r=t.children[e].getViewNodeFor(n);if(r)return r}},e.getFirstAncestorOfType=e=>t._parent?t._parent.isA(e)?t._parent:t._parent.getFirstAncestorOfType(e):null,e.getLastAncestorOfType=e=>t._parent?t._parent.getLastAncestorOfType(e)||(t._parent.isA(e)?t._parent:null):null,e.addMissingNode=n=>{if(!n)return;const r=t._renderableChildMap.get(n);if(void 0!==r)return r.setVisited(!0),r;const o=e.createViewNode(n);return o?(o.setParent(e),o.setVisited(!0),t._renderableChildMap.set(n,o),t.children.push(o),o):void 0},e.addMissingNodes=function(n){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(n&&n.length)for(let o=0;o<n.length;++o){const a=n[o],i=e.addMissingNode(a);if(r&&void 0!==i&&t.children[o]!==i)for(let e=o+1;e<t.children.length;++e)if(t.children[e]===i){t.children.splice(e,1),t.children.splice(o,0,i);break}}},e.addMissingChildren=n=>{if(n&&n.length)for(let r=0;r<n.length;++r){const o=n[r];if(-1===t.children.indexOf(o)){o.setParent(e),t.children.push(o);const n=o.getRenderable();n&&t._renderableChildMap.set(n,o)}o.setVisited(!0)}},e.removeNode=e=>{const n=t.children.findIndex((t=>t===e));if(n<0)return!1;const r=e.getRenderable();return r&&t._renderableChildMap.delete(r),e.delete(),t.children.splice(n,1),!0},e.prepareNodes=()=>{for(let e=0;e<t.children.length;++e)t.children[e].setVisited(!1)},e.setVisited=e=>{t.visited=e},e.removeUnusedNodes=()=>{let e=0;for(let n=0;n<t.children.length;++n){const r=t.children[n];if(r.getVisited())t.children[e++]=r,r.setVisited(!1);else{const e=r.getRenderable();e&&t._renderableChildMap.delete(e),r.delete()}}t.children.length=e},e.createViewNode=e=>{if(!t.myFactory)return Kt("Cannot create view nodes without my own factory"),null;const n=t.myFactory.createNode(e);return n&&n.setRenderable(e),n};const n=e.delete;e.delete=()=>{for(let e=0;e<t.children.length;e++)t.children[e].delete();n()}}(e,t)}var Xt={newInstance:Ht.newInstance(qt,"vtkViewNode"),extend:qt,PASS_TYPES:["Build","Render"]};const Yt={};function Zt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Yt,n),Ht.obj(e,t),function(e,t){t.overrides||(t.overrides={}),t.classHierarchy.push("vtkViewNodeFactory"),e.createNode=n=>{if(n.isDeleted())return null;let r=0,o=n.getClassName(r++),a=!1;const i=Object.keys(t.overrides);for(;o&&!a;)-1!==i.indexOf(o)?a=!0:o=n.getClassName(r++);if(!a)return null;const s=t.overrides[o]();return s.setMyFactory(e),s}}(e,t)}var Qt={newInstance:Ht.newInstance(Zt,"vtkViewNodeFactory"),extend:Zt};const Jt=Object.create(null);function en(e,t){Jt[e]=t}const tn={};function nn(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,tn,n),t.overrides=Jt,Qt.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkOpenGLViewNodeFactory")}(0,t)}var rn={newInstance:Ht.newInstance(nn,"vtkOpenGLViewNodeFactory"),extend:nn};const on={context:null,lastRenderer:null,keyMatrixTime:null,keyMatrices:null};const an=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,on,n),Xt.extend(e,t,n),t.keyMatrixTime={},vt(t.keyMatrixTime),t.keyMatrices={normalMatrix:new Float64Array(9),vcpc:new Float64Array(16),wcvc:new Float64Array(16),wcpc:new Float64Array(16)},St(e,t,["context","keyMatrixTime"]),function(e,t){t.classHierarchy.push("vtkOpenGLCamera"),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext())},e.opaquePass=e=>{if(e){const e=t._openGLRenderer.getTiledSizeAndOrigin();t.context.viewport(e.lowerLeftU,e.lowerLeftV,e.usize,e.vsize),t.context.scissor(e.lowerLeftU,e.lowerLeftV,e.usize,e.vsize)}},e.translucentPass=e.opaquePass,e.zBufferPass=e.opaquePass,e.opaqueZBufferPass=e.opaquePass,e.volumePass=e.opaquePass,e.getKeyMatrices=n=>{if(n!==t.lastRenderer||t._openGLRenderWindow.getMTime()>t.keyMatrixTime.getMTime()||e.getMTime()>t.keyMatrixTime.getMTime()||n.getMTime()>t.keyMatrixTime.getMTime()||t.renderable.getMTime()>t.keyMatrixTime.getMTime()){d(t.keyMatrices.wcvc,t.renderable.getViewMatrix()),se(t.keyMatrices.normalMatrix,t.keyMatrices.wcvc),ge(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix),m(t.keyMatrices.wcvc,t.keyMatrices.wcvc);const e=t._openGLRenderer.getAspectRatio();d(t.keyMatrices.vcpc,t.renderable.getProjectionMatrix(e,-1,1)),m(t.keyMatrices.vcpc,t.keyMatrices.vcpc),y(t.keyMatrices.wcpc,t.keyMatrices.vcpc,t.keyMatrices.wcvc),t.keyMatrixTime.modified(),t.lastRenderer=n}return t.keyMatrices}}(e,t)}));en("vtkCamera",an);const{vtkDebugMacro:sn}=jt,ln={context:null,_openGLRenderWindow:null,selector:null};const cn=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ln,n),Xt.extend(e,t,n),yt(e,t,["shaderCache"]),St(e,t,["selector"]),Ot(0,t,["openGLRenderWindow"]),function(e,t){t.classHierarchy.push("vtkOpenGLRenderer"),e.buildPass=n=>{if(n){if(!t.renderable)return;e.updateLights(),e.prepareNodes(),e.addMissingNode(t.renderable.getActiveCamera()),e.addMissingNodes(t.renderable.getViewPropsWithNestedProps(),!0),e.removeUnusedNodes()}},e.updateLights=()=>{let e=0;const n=t.renderable.getLightsByReference();for(let t=0;t<n.length;++t)n[t].getSwitch()>0&&e++;return e||(sn("No lights are on, creating one."),t.renderable.createLight()),e},e.zBufferPass=n=>{if(n){let n=0;const r=t.context;t.renderable.getTransparent()||(t.context.clearColor(1,0,0,1),n|=r.COLOR_BUFFER_BIT),t.renderable.getPreserveDepthBuffer()||(r.clearDepth(1),n|=r.DEPTH_BUFFER_BIT,t.context.depthMask(!0));const o=e.getTiledSizeAndOrigin();r.enable(r.SCISSOR_TEST),r.scissor(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.viewport(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.colorMask(!0,!0,!0,!0),n&&r.clear(n),r.enable(r.DEPTH_TEST)}},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.cameraPass=t=>{t&&e.clear()},e.getAspectRatio=()=>{const e=t._parent.getSizeByReference(),n=t.renderable.getViewportByReference();return e[0]*(n[2]-n[0])/((n[3]-n[1])*e[1])},e.getTiledSizeAndOrigin=()=>{const e=t.renderable.getViewportByReference(),n=[0,0,1,1],r=e[0]-n[0],o=e[1]-n[1],a=t._parent.normalizedDisplayToDisplay(r,o),i=Math.round(a[0]),s=Math.round(a[1]),l=e[2]-n[0],c=e[3]-n[1],u=t._parent.normalizedDisplayToDisplay(l,c);let d=Math.round(u[0])-i,p=Math.round(u[1])-s;return d<0&&(d=0),p<0&&(p=0),{usize:d,vsize:p,lowerLeftU:i,lowerLeftV:s}},e.clear=()=>{let n=0;const r=t.context;if(!t.renderable.getTransparent()){const e=t.renderable.getBackgroundByReference();r.clearColor(e[0],e[1],e[2],e[3]),n|=r.COLOR_BUFFER_BIT}t.renderable.getPreserveDepthBuffer()||(r.clearDepth(1),n|=r.DEPTH_BUFFER_BIT,r.depthMask(!0)),r.colorMask(!0,!0,!0,!0);const o=e.getTiledSizeAndOrigin();r.enable(r.SCISSOR_TEST),r.scissor(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.viewport(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),n&&r.clear(n),r.enable(r.DEPTH_TEST)},e.releaseGraphicsResources=()=>{null!==t.selector&&t.selector.releaseGraphicsResources(),t.renderable&&t.renderable.getViewProps().forEach((e=>{e.modified()}))},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))}}(e,t)}),"vtkOpenGLRenderer");en("vtkRenderer",cn);const un={context:null,keyMatrixTime:null,keyMatrices:null,activeTextures:null};const dn=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,un,n),Xt.extend(e,t,n),t.keyMatrixTime={},vt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={normalMatrix:pe(new Float64Array(9)),mcwc:g(new Float64Array(16))},St(e,t,["context"]),yt(e,t,["activeTextures"]),function(e,t){t.classHierarchy.push("vtkOpenGLActor"),e.buildPass=n=>{if(n){t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNodes(t.renderable.getTextures()),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes(),t.ogltextures=null,t.activeTextures=null;for(let e=0;e<t.children.length;e++){const n=t.children[e];n.isA("vtkOpenGLTexture")?(t.ogltextures||(t.ogltextures=[]),t.ogltextures.push(n)):t.oglmapper=n}}},e.traverseZBufferPass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseOpaqueZBufferPass=t=>e.traverseOpaquePass(t),e.traverseOpaquePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseTranslucentPass=n=>{!t.renderable||!t.renderable.getNestedVisibility()||t.renderable.getIsOpaque()||t._openGLRenderer.getSelector()&&!t.renderable.getNestedPickable()||(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.activateTextures=()=>{if(t.ogltextures){t.activeTextures=[];for(let e=0;e<t.ogltextures.length;e++){const n=t.ogltextures[e];n.render(),n.getHandle()&&t.activeTextures.push(n)}}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;t.renderable.getIsOpaque()?n.incrementOpaqueActorCount():n.incrementTranslucentActorCount()}},e.zBufferPass=(t,n)=>e.opaquePass(t,n),e.opaqueZBufferPass=(t,n)=>e.opaquePass(t,n),e.opaquePass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.translucentPass=(n,r)=>{if(n)t.context.depthMask(t._openGLRenderer.getSelector()&&t.renderable.getNestedPickable()),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(t.renderable.computeMatrix(),d(t.keyMatrices.mcwc,t.renderable.getMatrix()),m(t.keyMatrices.mcwc,t.keyMatrices.mcwc),t.renderable.getIsIdentity()?pe(t.keyMatrices.normalMatrix):(se(t.keyMatrices.normalMatrix,t.keyMatrices.mcwc),ge(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix),fe(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix)),t.keyMatrixTime.modified()),t.keyMatrices)}(e,t)}));en("vtkActor",dn);const pn={context:null,activeTextures:null};const fn=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,pn,n),Xt.extend(e,t,n),St(e,t,["context"]),yt(e,t,["activeTextures"]),function(e,t){t.classHierarchy.push("vtkOpenGLActor2D"),e.buildPass=n=>{if(n){if(!t.renderable)return;t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNodes(t.renderable.getTextures()),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes(),t.ogltextures=null,t.activeTextures=null;for(let e=0;e<t.children.length;e++){const n=t.children[e];n.isA("vtkOpenGLTexture")?(t.ogltextures||(t.ogltextures=[]),t.ogltextures.push(n)):t.oglmapper=n}}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementOverlayActorCount()}},e.traverseOpaquePass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseTranslucentPass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&!t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseOverlayPass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable)&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.activateTextures=()=>{if(t.ogltextures){t.activeTextures=[];for(let e=0;e<t.ogltextures.length;e++){const n=t.ogltextures[e];n.render(),n.getHandle()&&t.activeTextures.push(n)}}},e.opaquePass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.translucentPass=(n,r)=>{if(n)t.context.depthMask(!1),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.overlayPass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()}}(e,t)}));function gn(){var e=new i(3);return i!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function mn(e){var t=e[0],n=e[1],r=e[2];return Math.hypot(t,n,r)}function hn(e,t,n){var r=new i(3);return r[0]=e,r[1]=t,r[2]=n,r}function vn(e,t,n,r){return e[0]=t,e[1]=n,e[2]=r,e}function Tn(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e}function yn(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e}function bn(e,t,n){return e[0]=t[0]*n[0],e[1]=t[1]*n[1],e[2]=t[2]*n[2],e}function xn(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e}function Cn(e,t){return e[0]=1/t[0],e[1]=1/t[1],e[2]=1/t[2],e}function Sn(e,t){var n=t[0],r=t[1],o=t[2],a=n*n+r*r+o*o;return a>0&&(a=1/Math.sqrt(a)),e[0]=t[0]*a,e[1]=t[1]*a,e[2]=t[2]*a,e}function An(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function In(e,t,n){var r=t[0],o=t[1],a=t[2],i=n[0],s=n[1],l=n[2];return e[0]=o*l-a*s,e[1]=a*i-r*l,e[2]=r*s-o*i,e}function wn(e,t,n){var r=t[0],o=t[1],a=t[2],i=n[3]*r+n[7]*o+n[11]*a+n[15];return i=i||1,e[0]=(n[0]*r+n[4]*o+n[8]*a+n[12])/i,e[1]=(n[1]*r+n[5]*o+n[9]*a+n[13])/i,e[2]=(n[2]*r+n[6]*o+n[10]*a+n[14])/i,e}function On(e,t,n){var r=t[0],o=t[1],a=t[2];return e[0]=r*n[0]+o*n[3]+a*n[6],e[1]=r*n[1]+o*n[4]+a*n[7],e[2]=r*n[2]+o*n[5]+a*n[8],e}function Pn(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]}function Rn(e,t){var n=e[0],r=e[1],o=e[2],i=t[0],s=t[1],l=t[2];return Math.abs(n-i)<=a*Math.max(1,Math.abs(n),Math.abs(i))&&Math.abs(r-s)<=a*Math.max(1,Math.abs(r),Math.abs(s))&&Math.abs(o-l)<=a*Math.max(1,Math.abs(o),Math.abs(l))}en("vtkActor2D",fn);var Mn=yn,En=bn,Vn=(gn(),Math.sqrt(50)),Dn=Math.sqrt(10),Ln=Math.sqrt(2);function Bn(e,t,n){var r=(t-e)/Math.max(0,n),o=Math.floor(Math.log(r)/Math.LN10),a=r/Math.pow(10,o);return o>=0?(a>=Vn?10:a>=Dn?5:a>=Ln?2:1)*Math.pow(10,o):-Math.pow(10,-o)/(a>=Vn?10:a>=Dn?5:a>=Ln?2:1)}function Nn(e,t){return null==e||null==t?NaN:e<t?-1:e>t?1:e>=t?0:NaN}function Fn(e){let t=e,n=e,r=e;function o(e,t,o=0,a=e.length){if(o<a){if(0!==n(t,t))return a;do{const n=o+a>>>1;r(e[n],t)<0?o=n+1:a=n}while(o<a)}return o}return 1===e.length&&(t=(t,n)=>e(t)-n,n=Nn,r=(t,n)=>Nn(e(t),n)),{left:o,center:function(e,n,r=0,a=e.length){const i=o(e,n,r,a-1);return i>r&&t(e[i-1],n)>-t(e[i],n)?i-1:i},right:function(e,t,o=0,a=e.length){if(o<a){if(0!==n(t,t))return a;do{const n=o+a>>>1;r(e[n],t)<=0?o=n+1:a=n}while(o<a)}return o}}}const _n=Fn(Nn),kn=_n.right;_n.left,Fn((function(e){return null===e?NaN:+e})).center;var Gn=kn;function Un(e,t,n){e.prototype=t.prototype=n,n.constructor=e}function zn(e,t){var n=Object.create(e.prototype);for(var r in t)n[r]=t[r];return n}function Wn(){}var Hn=.7,jn=1/Hn,Kn="\\s*([+-]?\\d+)\\s*",$n="\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",qn="\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",Xn=/^#([0-9a-f]{3,8})$/,Yn=new RegExp(`^rgb\\(${Kn},${Kn},${Kn}\\)$`),Zn=new RegExp(`^rgb\\(${qn},${qn},${qn}\\)$`),Qn=new RegExp(`^rgba\\(${Kn},${Kn},${Kn},${$n}\\)$`),Jn=new RegExp(`^rgba\\(${qn},${qn},${qn},${$n}\\)$`),er=new RegExp(`^hsl\\(${$n},${qn},${qn}\\)$`),tr=new RegExp(`^hsla\\(${$n},${qn},${qn},${$n}\\)$`),nr={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074};function rr(){return this.rgb().formatHex()}function or(){return this.rgb().formatRgb()}function ar(e){var t,n;return e=(e+"").trim().toLowerCase(),(t=Xn.exec(e))?(n=t[1].length,t=parseInt(t[1],16),6===n?ir(t):3===n?new cr(t>>8&15|t>>4&240,t>>4&15|240&t,(15&t)<<4|15&t,1):8===n?sr(t>>24&255,t>>16&255,t>>8&255,(255&t)/255):4===n?sr(t>>12&15|t>>8&240,t>>8&15|t>>4&240,t>>4&15|240&t,((15&t)<<4|15&t)/255):null):(t=Yn.exec(e))?new cr(t[1],t[2],t[3],1):(t=Zn.exec(e))?new cr(255*t[1]/100,255*t[2]/100,255*t[3]/100,1):(t=Qn.exec(e))?sr(t[1],t[2],t[3],t[4]):(t=Jn.exec(e))?sr(255*t[1]/100,255*t[2]/100,255*t[3]/100,t[4]):(t=er.exec(e))?mr(t[1],t[2]/100,t[3]/100,1):(t=tr.exec(e))?mr(t[1],t[2]/100,t[3]/100,t[4]):nr.hasOwnProperty(e)?ir(nr[e]):"transparent"===e?new cr(NaN,NaN,NaN,0):null}function ir(e){return new cr(e>>16&255,e>>8&255,255&e,1)}function sr(e,t,n,r){return r<=0&&(e=t=n=NaN),new cr(e,t,n,r)}function lr(e,t,n,r){return 1===arguments.length?((o=e)instanceof Wn||(o=ar(o)),o?new cr((o=o.rgb()).r,o.g,o.b,o.opacity):new cr):new cr(e,t,n,null==r?1:r);var o}function cr(e,t,n,r){this.r=+e,this.g=+t,this.b=+n,this.opacity=+r}function ur(){return`#${gr(this.r)}${gr(this.g)}${gr(this.b)}`}function dr(){const e=pr(this.opacity);return`${1===e?"rgb(":"rgba("}${fr(this.r)}, ${fr(this.g)}, ${fr(this.b)}${1===e?")":`, ${e})`}`}function pr(e){return isNaN(e)?1:Math.max(0,Math.min(1,e))}function fr(e){return Math.max(0,Math.min(255,Math.round(e)||0))}function gr(e){return((e=fr(e))<16?"0":"")+e.toString(16)}function mr(e,t,n,r){return r<=0?e=t=n=NaN:n<=0||n>=1?e=t=NaN:t<=0&&(e=NaN),new vr(e,t,n,r)}function hr(e){if(e instanceof vr)return new vr(e.h,e.s,e.l,e.opacity);if(e instanceof Wn||(e=ar(e)),!e)return new vr;if(e instanceof vr)return e;var t=(e=e.rgb()).r/255,n=e.g/255,r=e.b/255,o=Math.min(t,n,r),a=Math.max(t,n,r),i=NaN,s=a-o,l=(a+o)/2;return s?(i=t===a?(n-r)/s+6*(n<r):n===a?(r-t)/s+2:(t-n)/s+4,s/=l<.5?a+o:2-a-o,i*=60):s=l>0&&l<1?0:i,new vr(i,s,l,e.opacity)}function vr(e,t,n,r){this.h=+e,this.s=+t,this.l=+n,this.opacity=+r}function Tr(e){return(e=(e||0)%360)<0?e+360:e}function yr(e){return Math.max(0,Math.min(1,e||0))}function br(e,t,n){return 255*(e<60?t+(n-t)*e/60:e<180?n:e<240?t+(n-t)*(240-e)/60:t)}function xr(e,t,n,r,o){var a=e*e,i=a*e;return((1-3*e+3*a-i)*t+(4-6*a+3*i)*n+(1+3*e+3*a-3*i)*r+i*o)/6}Un(Wn,ar,{copy(e){return Object.assign(new this.constructor,this,e)},displayable(){return this.rgb().displayable()},hex:rr,formatHex:rr,formatHex8:function(){return this.rgb().formatHex8()},formatHsl:function(){return hr(this).formatHsl()},formatRgb:or,toString:or}),Un(cr,lr,zn(Wn,{brighter(e){return e=null==e?jn:Math.pow(jn,e),new cr(this.r*e,this.g*e,this.b*e,this.opacity)},darker(e){return e=null==e?Hn:Math.pow(Hn,e),new cr(this.r*e,this.g*e,this.b*e,this.opacity)},rgb(){return this},clamp(){return new cr(fr(this.r),fr(this.g),fr(this.b),pr(this.opacity))},displayable(){return-.5<=this.r&&this.r<255.5&&-.5<=this.g&&this.g<255.5&&-.5<=this.b&&this.b<255.5&&0<=this.opacity&&this.opacity<=1},hex:ur,formatHex:ur,formatHex8:function(){return`#${gr(this.r)}${gr(this.g)}${gr(this.b)}${gr(255*(isNaN(this.opacity)?1:this.opacity))}`},formatRgb:dr,toString:dr})),Un(vr,(function(e,t,n,r){return 1===arguments.length?hr(e):new vr(e,t,n,null==r?1:r)}),zn(Wn,{brighter(e){return e=null==e?jn:Math.pow(jn,e),new vr(this.h,this.s,this.l*e,this.opacity)},darker(e){return e=null==e?Hn:Math.pow(Hn,e),new vr(this.h,this.s,this.l*e,this.opacity)},rgb(){var e=this.h%360+360*(this.h<0),t=isNaN(e)||isNaN(this.s)?0:this.s,n=this.l,r=n+(n<.5?n:1-n)*t,o=2*n-r;return new cr(br(e>=240?e-240:e+120,o,r),br(e,o,r),br(e<120?e+240:e-120,o,r),this.opacity)},clamp(){return new vr(Tr(this.h),yr(this.s),yr(this.l),pr(this.opacity))},displayable(){return(0<=this.s&&this.s<=1||isNaN(this.s))&&0<=this.l&&this.l<=1&&0<=this.opacity&&this.opacity<=1},formatHsl(){const e=pr(this.opacity);return`${1===e?"hsl(":"hsla("}${Tr(this.h)}, ${100*yr(this.s)}%, ${100*yr(this.l)}%${1===e?")":`, ${e})`}`}}));var Cr=e=>()=>e;function Sr(e,t){var n=t-e;return n?function(e,t){return function(n){return e+n*t}}(e,n):Cr(isNaN(e)?t:e)}var Ar=function e(t){var n=function(e){return 1==(e=+e)?Sr:function(t,n){return n-t?function(e,t,n){return e=Math.pow(e,n),t=Math.pow(t,n)-e,n=1/n,function(r){return Math.pow(e+r*t,n)}}(t,n,e):Cr(isNaN(t)?n:t)}}(t);function r(e,t){var r=n((e=lr(e)).r,(t=lr(t)).r),o=n(e.g,t.g),a=n(e.b,t.b),i=Sr(e.opacity,t.opacity);return function(t){return e.r=r(t),e.g=o(t),e.b=a(t),e.opacity=i(t),e+""}}return r.gamma=e,r}(1);function Ir(e){return function(t){var n,r,o=t.length,a=new Array(o),i=new Array(o),s=new Array(o);for(n=0;n<o;++n)r=lr(t[n]),a[n]=r.r||0,i[n]=r.g||0,s[n]=r.b||0;return a=e(a),i=e(i),s=e(s),r.opacity=1,function(e){return r.r=a(e),r.g=i(e),r.b=s(e),r+""}}}function wr(e,t){var n,r=t?t.length:0,o=e?Math.min(r,e.length):0,a=new Array(o),i=new Array(r);for(n=0;n<o;++n)a[n]=Lr(e[n],t[n]);for(;n<r;++n)i[n]=t[n];return function(e){for(n=0;n<o;++n)i[n]=a[n](e);return i}}function Or(e,t){var n=new Date;return e=+e,t=+t,function(r){return n.setTime(e*(1-r)+t*r),n}}function Pr(e,t){return e=+e,t=+t,function(n){return e*(1-n)+t*n}}function Rr(e,t){var n,r={},o={};for(n in null!==e&&"object"==typeof e||(e={}),null!==t&&"object"==typeof t||(t={}),t)n in e?r[n]=Lr(e[n],t[n]):o[n]=t[n];return function(e){for(n in r)o[n]=r[n](e);return o}}Ir((function(e){var t=e.length-1;return function(n){var r=n<=0?n=0:n>=1?(n=1,t-1):Math.floor(n*t),o=e[r],a=e[r+1],i=r>0?e[r-1]:2*o-a,s=r<t-1?e[r+2]:2*a-o;return xr((n-r/t)*t,i,o,a,s)}})),Ir((function(e){var t=e.length;return function(n){var r=Math.floor(((n%=1)<0?++n:n)*t),o=e[(r+t-1)%t],a=e[r%t],i=e[(r+1)%t],s=e[(r+2)%t];return xr((n-r/t)*t,o,a,i,s)}}));var Mr=/[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,Er=new RegExp(Mr.source,"g");function Vr(e,t){var n,r,o,a=Mr.lastIndex=Er.lastIndex=0,i=-1,s=[],l=[];for(e+="",t+="";(n=Mr.exec(e))&&(r=Er.exec(t));)(o=r.index)>a&&(o=t.slice(a,o),s[i]?s[i]+=o:s[++i]=o),(n=n[0])===(r=r[0])?s[i]?s[i]+=r:s[++i]=r:(s[++i]=null,l.push({i:i,x:Pr(n,r)})),a=Er.lastIndex;return a<t.length&&(o=t.slice(a),s[i]?s[i]+=o:s[++i]=o),s.length<2?l[0]?function(e){return function(t){return e(t)+""}}(l[0].x):function(e){return function(){return e}}(t):(t=l.length,function(e){for(var n,r=0;r<t;++r)s[(n=l[r]).i]=n.x(e);return s.join("")})}function Dr(e,t){t||(t=[]);var n,r=e?Math.min(t.length,e.length):0,o=t.slice();return function(a){for(n=0;n<r;++n)o[n]=e[n]*(1-a)+t[n]*a;return o}}function Lr(e,t){var n,r=typeof t;return null==t||"boolean"===r?Cr(t):("number"===r?Pr:"string"===r?(n=ar(t))?(t=n,Ar):Vr:t instanceof ar?Ar:t instanceof Date?Or:function(e){return ArrayBuffer.isView(e)&&!(e instanceof DataView)}(t)?Dr:Array.isArray(t)?wr:"function"!=typeof t.valueOf&&"function"!=typeof t.toString||isNaN(t)?Rr:Pr)(e,t)}function Br(e,t){return e=+e,t=+t,function(n){return Math.round(e*(1-n)+t*n)}}function Nr(e){return+e}var Fr=[0,1];function _r(e){return e}function kr(e,t){return(t-=e=+e)?function(n){return(n-e)/t}:function(e){return function(){return e}}(isNaN(t)?NaN:.5)}function Gr(e,t,n){var r=e[0],o=e[1],a=t[0],i=t[1];return o<r?(r=kr(o,r),a=n(i,a)):(r=kr(r,o),a=n(a,i)),function(e){return a(r(e))}}function Ur(e,t,n){var r=Math.min(e.length,t.length)-1,o=new Array(r),a=new Array(r),i=-1;for(e[r]<e[0]&&(e=e.slice().reverse(),t=t.slice().reverse());++i<r;)o[i]=kr(e[i],e[i+1]),a[i]=n(t[i],t[i+1]);return function(t){var n=Gn(e,t,1,r)-1;return a[n](o[n](t))}}function zr(e,t){switch(arguments.length){case 0:break;case 1:this.range(e);break;default:this.range(t).domain(e)}return this}var Wr,Hr=/^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;function jr(e){if(!(t=Hr.exec(e)))throw new Error("invalid format: "+e);var t;return new Kr({fill:t[1],align:t[2],sign:t[3],symbol:t[4],zero:t[5],width:t[6],comma:t[7],precision:t[8]&&t[8].slice(1),trim:t[9],type:t[10]})}function Kr(e){this.fill=void 0===e.fill?" ":e.fill+"",this.align=void 0===e.align?">":e.align+"",this.sign=void 0===e.sign?"-":e.sign+"",this.symbol=void 0===e.symbol?"":e.symbol+"",this.zero=!!e.zero,this.width=void 0===e.width?void 0:+e.width,this.comma=!!e.comma,this.precision=void 0===e.precision?void 0:+e.precision,this.trim=!!e.trim,this.type=void 0===e.type?"":e.type+""}function $r(e,t){if((n=(e=t?e.toExponential(t-1):e.toExponential()).indexOf("e"))<0)return null;var n,r=e.slice(0,n);return[r.length>1?r[0]+r.slice(2):r,+e.slice(n+1)]}function qr(e){return(e=$r(Math.abs(e)))?e[1]:NaN}function Xr(e,t){var n=$r(e,t);if(!n)return e+"";var r=n[0],o=n[1];return o<0?"0."+new Array(-o).join("0")+r:r.length>o+1?r.slice(0,o+1)+"."+r.slice(o+1):r+new Array(o-r.length+2).join("0")}jr.prototype=Kr.prototype,Kr.prototype.toString=function(){return this.fill+this.align+this.sign+this.symbol+(this.zero?"0":"")+(void 0===this.width?"":Math.max(1,0|this.width))+(this.comma?",":"")+(void 0===this.precision?"":"."+Math.max(0,0|this.precision))+(this.trim?"~":"")+this.type};var Yr={"%":(e,t)=>(100*e).toFixed(t),b:e=>Math.round(e).toString(2),c:e=>e+"",d:function(e){return Math.abs(e=Math.round(e))>=1e21?e.toLocaleString("en").replace(/,/g,""):e.toString(10)},e:(e,t)=>e.toExponential(t),f:(e,t)=>e.toFixed(t),g:(e,t)=>e.toPrecision(t),o:e=>Math.round(e).toString(8),p:(e,t)=>Xr(100*e,t),r:Xr,s:function(e,t){var n=$r(e,t);if(!n)return e+"";var r=n[0],o=n[1],a=o-(Wr=3*Math.max(-8,Math.min(8,Math.floor(o/3))))+1,i=r.length;return a===i?r:a>i?r+new Array(a-i+1).join("0"):a>0?r.slice(0,a)+"."+r.slice(a):"0."+new Array(1-a).join("0")+$r(e,Math.max(0,t+a-1))[0]},X:e=>Math.round(e).toString(16).toUpperCase(),x:e=>Math.round(e).toString(16)};function Zr(e){return e}var Qr,Jr,eo,to=Array.prototype.map,no=["y","z","a","f","p","n","","m","","k","M","G","T","P","E","Z","Y"];function ro(e){var t=e.domain;return e.ticks=function(e){var n=t();return function(e,t,n){var r,o,a,i,s=-1;if(n=+n,(e=+e)==(t=+t)&&n>0)return[e];if((r=t<e)&&(o=e,e=t,t=o),0===(i=Bn(e,t,n))||!isFinite(i))return[];if(i>0){let n=Math.round(e/i),r=Math.round(t/i);for(n*i<e&&++n,r*i>t&&--r,a=new Array(o=r-n+1);++s<o;)a[s]=(n+s)*i}else{i=-i;let n=Math.round(e*i),r=Math.round(t*i);for(n/i<e&&++n,r/i>t&&--r,a=new Array(o=r-n+1);++s<o;)a[s]=(n+s)/i}return r&&a.reverse(),a}(n[0],n[n.length-1],null==e?10:e)},e.tickFormat=function(e,n){var r=t();return function(e,t,n,r){var o,a=function(e,t,n){var r=Math.abs(t-e)/Math.max(0,n),o=Math.pow(10,Math.floor(Math.log(r)/Math.LN10)),a=r/o;return a>=Vn?o*=10:a>=Dn?o*=5:a>=Ln&&(o*=2),t<e?-o:o}(e,t,n);switch((r=jr(null==r?",f":r)).type){case"s":var i=Math.max(Math.abs(e),Math.abs(t));return null!=r.precision||isNaN(o=function(e,t){return Math.max(0,3*Math.max(-8,Math.min(8,Math.floor(qr(t)/3)))-qr(Math.abs(e)))}(a,i))||(r.precision=o),eo(r,i);case"":case"e":case"g":case"p":case"r":null!=r.precision||isNaN(o=function(e,t){return e=Math.abs(e),t=Math.abs(t)-e,Math.max(0,qr(t)-qr(e))+1}(a,Math.max(Math.abs(e),Math.abs(t))))||(r.precision=o-("e"===r.type));break;case"f":case"%":null!=r.precision||isNaN(o=function(e){return Math.max(0,-qr(Math.abs(e)))}(a))||(r.precision=o-2*("%"===r.type))}return Jr(r)}(r[0],r[r.length-1],null==e?10:e,n)},e.nice=function(n){null==n&&(n=10);var r,o,a=t(),i=0,s=a.length-1,l=a[i],c=a[s],u=10;for(c<l&&(o=l,l=c,c=o,o=i,i=s,s=o);u-- >0;){if((o=Bn(l,c,n))===r)return a[i]=l,a[s]=c,t(a);if(o>0)l=Math.floor(l/o)*o,c=Math.ceil(c/o)*o;else{if(!(o<0))break;l=Math.ceil(l*o)/o,c=Math.floor(c*o)/o}r=o}return e},e}function oo(){var e=function(){var e,t,n,r,o,a,i=Fr,s=Fr,l=Lr,c=_r;function u(){var e,t,n,l=Math.min(i.length,s.length);return c!==_r&&(e=i[0],t=i[l-1],e>t&&(n=e,e=t,t=n),c=function(n){return Math.max(e,Math.min(t,n))}),r=l>2?Ur:Gr,o=a=null,d}function d(t){return null==t||isNaN(t=+t)?n:(o||(o=r(i.map(e),s,l)))(e(c(t)))}return d.invert=function(n){return c(t((a||(a=r(s,i.map(e),Pr)))(n)))},d.domain=function(e){return arguments.length?(i=Array.from(e,Nr),u()):i.slice()},d.range=function(e){return arguments.length?(s=Array.from(e),u()):s.slice()},d.rangeRound=function(e){return s=Array.from(e),l=Br,u()},d.clamp=function(e){return arguments.length?(c=!!e||_r,u()):c!==_r},d.interpolate=function(e){return arguments.length?(l=e,u()):l},d.unknown=function(e){return arguments.length?(n=e,d):n},function(n,r){return e=n,t=r,u()}}()(_r,_r);return e.copy=function(){return t=e,oo().domain(t.domain()).range(t.range()).interpolate(t.interpolate()).clamp(t.clamp()).unknown(t.unknown());var t},zr.apply(e,arguments),ro(e)}Qr=function(e){var t,n,r=void 0===e.grouping||void 0===e.thousands?Zr:(t=to.call(e.grouping,Number),n=e.thousands+"",function(e,r){for(var o=e.length,a=[],i=0,s=t[0],l=0;o>0&&s>0&&(l+s+1>r&&(s=Math.max(1,r-l)),a.push(e.substring(o-=s,o+s)),!((l+=s+1)>r));)s=t[i=(i+1)%t.length];return a.reverse().join(n)}),o=void 0===e.currency?"":e.currency[0]+"",a=void 0===e.currency?"":e.currency[1]+"",i=void 0===e.decimal?".":e.decimal+"",s=void 0===e.numerals?Zr:function(e){return function(t){return t.replace(/[0-9]/g,(function(t){return e[+t]}))}}(to.call(e.numerals,String)),l=void 0===e.percent?"%":e.percent+"",c=void 0===e.minus?"":e.minus+"",u=void 0===e.nan?"NaN":e.nan+"";function d(e){var t=(e=jr(e)).fill,n=e.align,d=e.sign,p=e.symbol,f=e.zero,g=e.width,m=e.comma,h=e.precision,v=e.trim,T=e.type;"n"===T?(m=!0,T="g"):Yr[T]||(void 0===h&&(h=12),v=!0,T="g"),(f||"0"===t&&"="===n)&&(f=!0,t="0",n="=");var y="$"===p?o:"#"===p&&/[boxX]/.test(T)?"0"+T.toLowerCase():"",b="$"===p?a:/[%p]/.test(T)?l:"",x=Yr[T],C=/[defgprs%]/.test(T);function S(e){var o,a,l,p=y,S=b;if("c"===T)S=x(e)+S,e="";else{var A=(e=+e)<0||1/e<0;if(e=isNaN(e)?u:x(Math.abs(e),h),v&&(e=function(e){e:for(var t,n=e.length,r=1,o=-1;r<n;++r)switch(e[r]){case".":o=t=r;break;case"0":0===o&&(o=r),t=r;break;default:if(!+e[r])break e;o>0&&(o=0)}return o>0?e.slice(0,o)+e.slice(t+1):e}(e)),A&&0==+e&&"+"!==d&&(A=!1),p=(A?"("===d?d:c:"-"===d||"("===d?"":d)+p,S=("s"===T?no[8+Wr/3]:"")+S+(A&&"("===d?")":""),C)for(o=-1,a=e.length;++o<a;)if(48>(l=e.charCodeAt(o))||l>57){S=(46===l?i+e.slice(o+1):e.slice(o))+S,e=e.slice(0,o);break}}m&&!f&&(e=r(e,1/0));var I=p.length+e.length+S.length,w=I<g?new Array(g-I+1).join(t):"";switch(m&&f&&(e=r(w+e,w.length?g-S.length:1/0),w=""),n){case"<":e=p+e+S+w;break;case"=":e=p+w+e+S;break;case"^":e=w.slice(0,I=w.length>>1)+p+e+S+w.slice(I);break;default:e=w+p+e+S}return s(e)}return h=void 0===h?6:/[gprs]/.test(T)?Math.max(1,Math.min(21,h)):Math.max(0,Math.min(20,h)),S.toString=function(){return e+""},S}return{format:d,formatPrefix:function(e,t){var n=d(((e=jr(e)).type="f",e)),r=3*Math.max(-8,Math.min(8,Math.floor(qr(t)/3))),o=Math.pow(10,-r),a=no[8+r/3];return function(e){return n(o*e)+a}}}}({thousands:",",grouping:[3],currency:["$",""]}),Jr=Qr.format,eo=Qr.formatPrefix;var ao=n(318),io=n.n(ao);const so=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],lo=[1,0,0,0,1,0,0,0,1],co=1e-6,uo=1e-12,{vtkErrorMacro:po,vtkWarningMacro:fo}=Ht;let go=0;function mo(e){return()=>po(`vtkMath::${e} - NOT IMPLEMENTED`)}function ho(e,t,n,r){let o;for(let a=0;a<t;a++)o=e[n*t+a],e[n*t+a]=e[r*t+a],e[r*t+a]=o}function vo(e,t,n,r){let o;for(let a=0;a<t;a++)o=e[a*t+n],e[a*t+n]=e[a*t+r],e[a*t+r]=o}function To(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:3;const t=Array(e);for(let n=0;n<e;++n)t[n]=0;return t}function yo(e){return e/180*Math.PI}function bo(e){return 180*e/Math.PI}const{round:xo,floor:Co,ceil:So,min:Ao,max:Io}=Math;const wo=mo("ceilLog2"),Oo=mo("factorial");function Po(e){let t=1;for(;t<e;)t*=2;return t}function Ro(e){return e===Po(e)}const Mo=mo("gaussian");function Eo(e,t,n){return n[0]=e[0]+t[0],n[1]=e[1]+t[1],n[2]=e[2]+t[2],n}function Vo(e,t,n){return n[0]=e[0]-t[0],n[1]=e[1]-t[1],n[2]=e[2]-t[2],n}function Do(e,t){return e[0]*=t,e[1]*=t,e[2]*=t,e}function Lo(e,t){return e[0]*=t,e[1]*=t,e}function Bo(e,t,n,r){return r[0]=e[0]+t[0]*n,r[1]=e[1]+t[1]*n,r[2]=e[2]+t[2]*n,r}function No(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function Fo(e,t,n){const r=e[1]*t[2]-e[2]*t[1],o=e[2]*t[0]-e[0]*t[2],a=e[0]*t[1]-e[1]*t[0];return n[0]=r,n[1]=o,n[2]=a,n}function _o(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;switch(t){case 1:return Math.abs(e);case 2:return Math.sqrt(e[0]*e[0]+e[1]*e[1]);case 3:return Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]);default:{let n=0;for(let r=0;r<t;r++)n+=e[r]*e[r];return Math.sqrt(n)}}}function ko(e){const t=_o(e);return 0!==t&&(e[0]/=t,e[1]/=t,e[2]/=t),t}function Go(e,t){return e[0]*t[0]+e[1]*t[1]}function Uo(e,t){return(e[0]-t[0])*(e[0]-t[0])+(e[1]-t[1])*(e[1]-t[1])+(e[2]-t[2])*(e[2]-t[2])}function zo(e){return Math.sqrt(e[0]*e[0]+e[1]*e[1])}function Wo(e){const t=zo(e);return 0!==t&&(e[0]/=t,e[1]/=t),t}function Ho(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return 2===t.length?t[0][0]*t[1][1]-t[1][0]*t[0][1]:4===t.length?t[0]*t[3]-t[1]*t[2]:Number.NaN}function jo(e,t,n){const r=e[0]*t[0]+e[1]*t[1]+e[2]*t[2],o=e[3]*t[0]+e[4]*t[1]+e[5]*t[2],a=e[6]*t[0]+e[7]*t[1]+e[8]*t[2];n[0]=r,n[1]=o,n[2]=a}function Ko(e,t,n){const r=[...e],o=[...t];for(let e=0;e<3;e++)n[e]=r[0]*o[e]+r[1]*o[e+3]+r[2]*o[e+6],n[e+3]=r[3]*o[e]+r[4]*o[e+3]+r[5]*o[e+6],n[e+6]=r[6]*o[e]+r[7]*o[e+3]+r[8]*o[e+6]}function $o(e,t){let n;n=e[3],t[3]=e[1],t[1]=n,n=e[6],t[6]=e[2],t[2]=n,n=e[7],t[7]=e[5],t[5]=n,t[0]=e[0],t[4]=e[4],t[8]=e[8]}function qo(e){return e[0]*e[4]*e[8]+e[3]*e[7]*e[2]+e[6]*e[1]*e[5]-e[0]*e[7]*e[5]-e[3]*e[1]*e[8]-e[6]*e[4]*e[2]}function Xo(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:co;return e.length===t.length&&e.every((function(e,r){return Math.abs(e-t[r])<=n}))}const Yo=Xo;function Zo(e){for(let t=0;t<3;t++)e[3*t]=e[3*t+1]=e[3*t+2]=0,e[3*t+t]=1}function Qo(e,t){for(let n=0;n<e;n++){for(let r=0;r<e;r++)t[n*e+r]=0;t[n*e+n]=1}return t}function Jo(e,t){const n=e[0]*e[0],r=e[0]*e[1],o=e[0]*e[2],a=e[0]*e[3],i=e[1]*e[1],s=e[2]*e[2],l=e[3]*e[3],c=e[1]*e[2],u=e[1]*e[3],d=e[2]*e[3],p=i+s+l;let f=1/(n+p);const g=(n-p)*f;f*=2,t[0]=i*f+g,t[3]=(c+a)*f,t[6]=(u-o)*f,t[1]=(c-a)*f,t[4]=s*f+g,t[7]=(d+r)*f,t[2]=(u+o)*f,t[5]=(d-r)*f,t[8]=l*f+g}function ea(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!`${e}`.includes("e"))return+`${Math.round(`${e}e+${t}`)}e-${t}`;const n=`${e}`.split("e");let r="";return+n[1]+t>0&&(r="+"),+`${Math.round(`${+n[0]}e${r}${+n[1]+t}`)}e-${t}`}function ta(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[0,0,0],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return t[0]=ea(e[0],n),t[1]=ea(e[1],n),t[2]=ea(e[2],n),t}function na(e,t,n,r){let o,a,i,s,l,c,u,d,p,f,g,m,h,v,T,y;const b=To(t),x=To(t),C=(e,t,n)=>{v=e[t],h=e[n],e[t]=v-m*(h+v*f),e[n]=h+m*(v-h*f)};for(Qo(t,r),l=0;l<t;l++)b[l]=n[l]=e[l+l*t],x[l]=0;for(o=0;o<20;o++){for(g=0,l=0;l<t-1;l++)for(s=l+1;s<t;s++)g+=Math.abs(e[l*t+s]);if(0===g)break;for(u=o<3?.2*g/(t*t):0,l=0;l<t-1;l++)for(s=l+1;s<t;s++)if(v=100*Math.abs(e[l*t+s]),o>3&&Math.abs(n[l])+v===Math.abs(n[l])&&Math.abs(n[s])+v===Math.abs(n[s]))e[l*t+s]=0;else if(Math.abs(e[l*t+s])>u){for(h=n[s]-n[l],Math.abs(h)+v===Math.abs(h)?p=e[l*t+s]/h:(d=.5*h/e[l*t+s],p=1/(Math.abs(d)+Math.sqrt(1+d*d)),d<0&&(p=-p)),T=1/Math.sqrt(1+p*p),m=p*T,f=m/(1+T),h=p*e[l*t+s],x[l]-=h,x[s]+=h,n[l]-=h,n[s]+=h,e[l*t+s]=0,a=0;a<=l-1;a++)C(e,a*t+l,a*t+s);for(a=l+1;a<=s-1;a++)C(e,l*t+a,a*t+s);for(a=s+1;a<t;a++)C(e,l*t+a,s*t+a);for(a=0;a<t;a++)C(r,a*t+l,a*t+s)}for(l=0;l<t;l++)b[l]+=x[l],n[l]=b[l],x[l]=0}if(o>=20)return fo("vtkMath::Jacobi: Error extracting eigenfunctions"),0;for(a=0;a<t-1;a++){for(i=a,y=n[i],o=a+1;o<t;o++)(n[o]>=y||Math.abs(n[o]-y)<uo)&&(i=o,y=n[i]);i!==a&&(n[i]=n[a],n[a]=y,vo(r,t,a,i))}const S=(t>>1)+(1&t);for(c=0,o=0;o<t*t;o++)r[o]>=0&&c++;if(c<S)for(o=0;o<t;o++)r[o*t+a]*=-1;return 1}function ra(e,t){const n=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];n[0]=e[0]+e[4]+e[8],n[5]=e[0]-e[4]-e[8],n[10]=-e[0]+e[4]-e[8],n[15]=-e[0]-e[4]+e[8],n[1]=n[4]=e[7]-e[5],n[2]=n[8]=e[2]-e[6],n[3]=n[12]=e[3]-e[1],n[6]=n[9]=e[3]+e[1],n[7]=n[13]=e[2]+e[6],n[11]=n[14]=e[7]+e[5];const r=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];na([...n],4,[0,0,0,0],r),t[0]=r[0],t[1]=r[4],t[2]=r[8],t[3]=r[12]}function oa(e,t){for(let n=0;n<9;n++)t[n]=e[n];const n=To(3),r=To(3);let o;for(let e=0;e<3;e++){const r=Math.abs(t[3*e]),a=Math.abs(t[3*e+1]),i=Math.abs(t[3*e+2]);o=a>r?a:r,o=i>o?i:o,n[e]=1,0!==o&&(n[e]/=o)}const a=Math.abs(t[0])*n[0],i=Math.abs(t[3])*n[1],s=Math.abs(t[6])*n[2];r[0]=0,o=a,i>=o&&(o=i,r[0]=1),s>=o&&(r[0]=2),0!==r[0]&&(vo(t,3,r[0],0),n[r[0]]=n[0]);const l=Math.abs(t[4])*n[1],c=Math.abs(t[7])*n[2];r[1]=1,o=l,c>=o&&(r[1]=2,vo(t,3,1,2)),r[2]=2;let u=0;if(qo(t)<0){u=1;for(let e=0;e<9;e++)t[e]=-t[e]}const d=To(4);if(ra(t,d),Jo(d,t),u)for(let e=0;e<9;e++)t[e]=-t[e];1!==r[1]&&vo(t,3,r[1],1),0!==r[0]&&vo(t,3,r[0],0)}function aa(e,t,n){let r,o,a,i,s,l;if(na([...e],3,t,n),t[0]!==t[1]||t[0]!==t[2]){for($o(n,n),r=0;r<3;r++)if(t[(r+1)%3]===t[(r+2)%3]){for(l=Math.abs(n[3*r]),i=0,o=1;o<3;o++)l<(s=Math.abs(n[3*r+o]))&&(l=s,i=o);i!==r&&(s=t[i],t[i]=t[r],t[r]=s,ho(n,3,r,i)),n[3*i+i]<0&&(n[3*i]=-n[3*i],n[3*i+1]=-n[3*i+1],n[3*i+2]=-n[3*i+2]),o=(i+1)%3,a=(i+2)%3,n[3*o]=0,n[3*o+1]=0,n[3*o+2]=0,n[3*o+o]=1;const e=Fo([n[3*i],n[3*i+1],n[3*i+2]],[n[3*o],n[3*o+1],n[3*o+2]],[]);ko(e);const c=Fo(e,[n[3*i],n[3*i+1],n[3*i+2]],[]);for(let t=0;t<3;t++)n[3*a+t]=e[t],n[3*o+t]=c[t];return void $o(n,n)}for(l=Math.abs(n[0]),i=0,r=1;r<3;r++)l<(s=Math.abs(n[3*r]))&&(l=s,i=r);if(0!==i){const e=t[i];t[i]=t[0],t[0]=e,ho(n,3,i,0)}if(Math.abs(n[4])<Math.abs(n[7])){const e=t[2];t[2]=t[1],t[1]=e,ho(n,3,1,2)}for(r=0;r<2;r++)n[3*r+r]<0&&(n[3*r]=-n[3*r],n[3*r+1]=-n[3*r+1],n[3*r+2]=-n[3*r+2]);qo(n)<0&&(n[6]=-n[6],n[7]=-n[7],n[8]=-n[8]),$o(n,n)}else Zo(n)}function ia(e,t,n){let r,o,a,i,s,l,c,u=0;const d=To(n);for(r=0;r<n;r++){for(i=0,o=0;o<n;o++)(c=Math.abs(e[r*n+o]))>i&&(i=c);if(0===i)return fo("Unable to factor linear system"),0;d[r]=1/i}for(o=0;o<n;o++){for(r=0;r<o;r++){for(s=e[r*n+o],a=0;a<r;a++)s-=e[r*n+a]*e[a*n+o];e[r*n+o]=s}for(i=0,r=o;r<n;r++){for(s=e[r*n+o],a=0;a<o;a++)s-=e[r*n+a]*e[a*n+o];e[r*n+o]=s,(l=d[r]*Math.abs(s))>=i&&(i=l,u=r)}if(o!==u){for(a=0;a<n;a++)l=e[u*n+a],e[u*n+a]=e[o*n+a],e[o*n+a]=l;d[u]=d[o]}if(t[o]=u,Math.abs(e[o*n+o])<=uo)return fo("Unable to factor linear system"),0;if(o!==n-1)for(l=1/e[o*n+o],r=o+1;r<n;r++)e[r*n+o]*=l}return 1}function sa(e,t,n,r){let o,a,i,s,l;for(i=-1,o=0;o<r;o++){if(s=t[o],l=n[s],n[s]=n[o],i>=0)for(a=i;a<=o-1;a++)l-=e[o*r+a]*n[a];else 0!==l&&(i=o);n[o]=l}for(o=r-1;o>=0;o--){for(l=n[o],a=o+1;a<r;a++)l-=e[o*r+a]*n[a];n[o]=l/e[o*r+o]}}function la(e,t,n){if(2===n){const n=To(2),r=Ho(e[0],e[1],e[2],e[3]);return 0===r?0:(n[0]=(e[3]*t[0]-e[1]*t[1])/r,n[1]=(-e[2]*t[0]+e[0]*t[1])/r,t[0]=n[0],t[1]=n[1],1)}if(1===n)return 0===e[0]?0:(t[0]/=e[0],1);const r=To(n);return 0===ia(e,r,n)?0:(sa(e,r,t,n),1)}function ca(e,t,n){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const o=(arguments.length>3&&void 0!==arguments[3]?arguments[3]:null)||To(n),a=r||To(n);if(0===ia(e,o,n))return null;for(let r=0;r<n;r++){for(let e=0;e<n;e++)a[e]=0;a[r]=1,sa(e,o,a,n);for(let e=0;e<n;e++)t[e*n+r]=a[e]}return t}function ua(e,t,n,r){if(e<n)return fo("Insufficient number of samples. Underdetermined."),0;let o,a,i;const s=To(n*n),l=To(n),c=To(n*n);for(i=0;i<e;i++)for(o=0;o<n;o++)for(a=o;a<n;a++)s[o*n+a]+=t[i*n+o]*t[i*n+a];for(o=0;o<n;o++)for(a=0;a<o;a++)s[o*n+a]=s[a*n+o];for(na(s,n,l,c),o=0;o<n;o++)r[o]=c[o*n+n-1];return 1}function da(e,t){let n,r;const[o,a,i]=e,s=1/6;let l=o,c=o;a>l?l=a:a<c&&(c=a),i>l?l=i:i<c&&(c=i);const u=l;r=u>0?(l-c)/l:0,r>0?(n=o===l?s*(a-i)/(l-c):a===l?1/3+s*(i-o)/(l-c):2/3+s*(o-a)/(l-c),n<0&&(n+=1)):n=0,t[0]=n,t[1]=r,t[2]=u}function pa(e,t){const[n,r,o]=e,a=1/3,i=1/6,s=2/3,l=5/6;let c,u,d;n>i&&n<=a?(u=1,c=(a-n)/i,d=0):n>a&&n<=.5?(u=1,d=(n-a)/i,c=0):n>.5&&n<=s?(d=1,u=(s-n)/i,c=0):n>s&&n<=l?(d=1,c=(n-s)/i,u=0):n>l&&n<=1?(c=1,d=(1-n)/i,u=0):(c=1,u=n/i,d=0),c=r*c+(1-r),u=r*u+(1-r),d=r*d+(1-r),c*=o,u*=o,d*=o,t[0]=c,t[1]=u,t[2]=d}function fa(e,t){const[n,r,o]=e;let a=(n+16)/116,i=r/500+a,s=a-o/200;a**3>.008856?a**=3:a=(a-16/116)/7.787,i**3>.008856?i**=3:i=(i-16/116)/7.787,s**3>.008856?s**=3:s=(s-16/116)/7.787,t[0]=.9505*i,t[1]=1*a,t[2]=1.089*s}function ga(e,t){const[n,r,o]=e;let a=n/.9505,i=r/1,s=o/1.089;a>.008856?a**=1/3:a=7.787*a+16/116,i>.008856?i**=1/3:i=7.787*i+16/116,s>.008856?s**=1/3:s=7.787*s+16/116,t[0]=116*i-16,t[1]=500*(a-i),t[2]=200*(i-s)}function ma(e,t){const[n,r,o]=e;let a=3.2406*n+-1.5372*r+-.4986*o,i=-.9689*n+1.8758*r+.0415*o,s=.0557*n+-.204*r+1.057*o;a>.0031308?a=1.055*a**(1/2.4)-.055:a*=12.92,i>.0031308?i=1.055*i**(1/2.4)-.055:i*=12.92,s>.0031308?s=1.055*s**(1/2.4)-.055:s*=12.92;let l=a;l<i&&(l=i),l<s&&(l=s),l>1&&(a/=l,i/=l,s/=l),a<0&&(a=0),i<0&&(i=0),s<0&&(s=0),t[0]=a,t[1]=i,t[2]=s}function ha(e,t){let[n,r,o]=e;n>.04045?n=((n+.055)/1.055)**2.4:n/=12.92,r>.04045?r=((r+.055)/1.055)**2.4:r/=12.92,o>.04045?o=((o+.055)/1.055)**2.4:o/=12.92,t[0]=.4124*n+.3576*r+.1805*o,t[1]=.2126*n+.7152*r+.0722*o,t[2]=.0193*n+.1192*r+.9505*o}function va(e,t){const n=[0,0,0];ha(e,n),ga(n,t)}function Ta(e,t){const n=[0,0,0];fa(e,n),ma(n,t)}function ya(e){return e[0]=1,e[1]=-1,e[2]=1,e[3]=-1,e[4]=1,e[5]=-1,e}function ba(e){return!(e[1]-e[0]<0)}function xa(e,t,n){return e<t?t:e>n?n:e}function Ca(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[0,0,0];return r[0]=xa(e[0],t[0],n[0]),r[1]=xa(e[1],t[1],n[1]),r[2]=xa(e[2],t[2],n[2]),r}const Sa=mo("GetScalarTypeFittingRange"),Aa=mo("GetAdjustedScalarRange");const Ia=e=>!Number.isFinite(e),{isFinite:wa,isNaN:Oa}=Number,Pa=Oa;function Ra(){return[].concat([Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE])}function Ma(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;const n=new Array(t),r=new Array(t);for(let e=0;e<t;++e)n[e]=e,r[e]=e;for(let o=t-1;o>0;o--){let a=-1/0,i=0,s=0;for(let l=0;l<=o;++l){const c=n[l];for(let n=0;n<=o;++n){const o=r[n],u=Math.abs(e[c+t*o]);u>a&&(a=u,i=l,s=n)}}[n[o],n[i]]=[n[i],n[o]],[r[o],r[s]]=[r[s],r[o]]}const o=new Array(t*t).fill(0);for(let a=0;a<t;++a){const i=n[a]+t*r[a];o[i]=e[i]<0?-1:1}return o}function Ea(e){const t=Math.floor(255*e);return t>15?t.toString(16):`0${t.toString(16)}`}function Va(e){return Math.round(255*e)}var Da,La={Pi:()=>Math.PI,ldexp:function(e,t){return t>1023?e*2**1023*2**(t-1023):t<-1074?5e-324*e*2**(t+1074):e*2**t},radiansFromDegrees:yo,degreesFromRadians:bo,round:xo,floor:Co,ceil:So,ceilLog2:wo,min:Ao,max:Io,arrayMin:function(e){let t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,n=1/0;for(let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,o=e.length;r<o;r+=t)e[r]<n&&(n=e[r]);return n},arrayMax:function(e){let t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,n=-1/0;for(let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,o=e.length;r<o;r+=t)n<e[r]&&(n=e[r]);return n},arrayRange:function(e){let t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,n=1/0,r=-1/0;for(let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,a=e.length;o<a;o+=t)e[o]<n&&(n=e[o]),r<e[o]&&(r=e[o]);return[n,r]},isPowerOfTwo:Ro,nearestPowerOfTwo:Po,factorial:Oo,binomial:function(e,t){let n=1;for(let r=1;r<=t;++r)n*=(e-r+1)/r;return Math.floor(n)},beginCombination:function(e,t){if(e<t)return 0;const n=To(t);for(let e=0;e<t;++e)n[e]=e;return n},nextCombination:function(e,t,n){let r=0;for(let o=t-1;o>=0;--o)if(n[o]<e-t+o){let e=n[o]+1;for(;o<t;)n[o++]=e++;r=1;break}return r},randomSeed:function(e){io()(`${e}`,{global:!0}),go=e},getSeed:function(){return go},random:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e+((arguments.length>1&&void 0!==arguments[1]?arguments[1]:1)-e)*Math.random()},gaussian:Mo,add:Eo,subtract:Vo,multiplyScalar:Do,multiplyScalar2D:Lo,multiplyAccumulate:Bo,multiplyAccumulate2D:function(e,t,n,r){return r[0]=e[0]+t[0]*n,r[1]=e[1]+t[1]*n,r},dot:No,outer:function(e,t,n){n[0]=e[0]*t[0],n[1]=e[0]*t[1],n[2]=e[0]*t[2],n[3]=e[1]*t[0],n[4]=e[1]*t[1],n[5]=e[1]*t[2],n[6]=e[2]*t[0],n[7]=e[2]*t[1],n[8]=e[2]*t[2]},cross:Fo,norm:_o,normalize:ko,perpendiculars:function(e,t,n,r){const o=e[0]*e[0],a=e[1]*e[1],i=e[2]*e[2],s=Math.sqrt(o+a+i);let l,c,u;o>a&&o>i?(l=0,c=1,u=2):a>i?(l=1,c=2,u=0):(l=2,c=0,u=1);const d=e[l]/s,p=e[c]/s,f=e[u]/s,g=Math.sqrt(d*d+f*f);if(0!==r){const e=Math.sin(r),o=Math.cos(r);t&&(t[l]=(f*o-d*p*e)/g,t[c]=e*g,t[u]=(-d*o-p*f*e)/g),n&&(n[l]=(-f*e-d*p*o)/g,n[c]=o*g,n[u]=(d*e-p*f*o)/g)}else t&&(t[l]=f/g,t[c]=0,t[u]=-d/g),n&&(n[l]=-d*p/g,n[c]=g,n[u]=-p*f/g)},projectVector:function(e,t,n){const r=No(t,t);if(0===r)return n[0]=0,n[1]=0,n[2]=0,!1;const o=No(e,t)/r;for(let e=0;e<3;e++)n[e]=t[e];return Do(n,o),!0},projectVector2D:function(e,t,n){const r=Go(t,t);if(0===r)return n[0]=0,n[1]=0,!1;const o=Go(e,t)/r;for(let e=0;e<2;e++)n[e]=t[e];return Lo(n,o),!0},distance2BetweenPoints:Uo,angleBetweenVectors:function(e,t){const n=[0,0,0];return Fo(e,t,n),Math.atan2(_o(n),No(e,t))},gaussianAmplitude:function(e,t,n){const r=Math.abs(e-n);return 1/Math.sqrt(2*Math.PI*t)*Math.exp(-(r**2)/(2*t))},gaussianWeight:function(e,t,n){const r=Math.abs(e-n);return Math.exp(-(r**2)/(2*t))},dot2D:Go,outer2D:function(e,t,n){n[0]=e[0]*t[0],n[1]=e[0]*t[1],n[2]=e[1]*t[0],n[3]=e[1]*t[1]},norm2D:zo,normalize2D:Wo,determinant2x2:Ho,LUFactor3x3:function(e,t){let n,r,o;const a=[0,0,0];for(let t=0;t<3;t++)o=Math.abs(e[3*t]),(r=Math.abs(e[3*t+1]))>o&&(o=r),(r=Math.abs(e[3*t+2]))>o&&(o=r),a[t]=1/o;o=a[0]*Math.abs(e[0]),n=0,(r=a[1]*Math.abs(e[3]))>=o&&(o=r,n=1),(r=a[2]*Math.abs(e[6]))>=o&&(n=2),0!==n&&(ho(e,3,n,0),a[n]=a[0]),t[0]=n,e[3]/=e[0],e[6]/=e[0],e[4]-=e[3]*e[1],e[7]-=e[6]*e[1],o=a[1]*Math.abs(e[4]),n=1,(r=a[2]*Math.abs(e[7]))>=o&&(n=2,ho(e,3,1,2),a[2]=a[1]),t[1]=n,e[7]/=e[4],e[5]-=e[3]*e[2],e[8]-=e[6]*e[2]+e[7]*e[5],t[2]=2},LUSolve3x3:function(e,t,n){let r=n[t[0]];n[t[0]]=n[0],n[0]=r,r=n[t[1]],n[t[1]]=n[1],n[1]=r-e[3]*n[0],r=n[t[2]],n[t[2]]=n[2],n[2]=r-e[6]*n[0]-e[7]*n[1],n[2]/=e[8],n[1]=(n[1]-e[5]*n[2])/e[4],n[0]=(n[0]-e[1]*n[1]-e[2]*n[2])/e[0]},linearSolve3x3:function(e,t,n){const r=e[0],o=e[1],a=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=+Ho(s,u,l,d),f=-Ho(i,c,l,d),g=+Ho(i,c,s,u),m=-Ho(o,u,a,d),h=+Ho(r,c,a,d),v=-Ho(r,c,o,u),T=+Ho(o,s,a,l),y=-Ho(r,i,a,l),b=+Ho(r,i,o,s),x=r*p+o*f+a*g,C=p*t[0]+m*t[1]+T*t[2],S=f*t[0]+h*t[1]+y*t[2],A=g*t[0]+v*t[1]+b*t[2];n[0]=C/x,n[1]=S/x,n[2]=A/x},multiply3x3_vect3:jo,multiply3x3_mat3:Ko,multiplyMatrix:function(e,t,n,r,o,a,i){r!==o&&po("Number of columns of A must match number of rows of B.");const s=[...e],l=[...t];for(let e=0;e<n;e++)for(let t=0;t<a;t++){i[e*a+t]=0;for(let n=0;n<r;n++)i[e*a+t]+=s[e*r+n]*l[t+a*n]}},transpose3x3:$o,invert3x3:function(e,t){const n=e[0],r=e[1],o=e[2],a=e[3],i=e[4],s=e[5],l=e[6],c=e[7],u=e[8],d=+Ho(i,c,s,u),p=-Ho(a,l,s,u),f=+Ho(a,l,i,c),g=-Ho(r,c,o,u),m=+Ho(n,l,o,u),h=-Ho(n,l,r,c),v=+Ho(r,i,o,s),T=-Ho(n,a,o,s),y=+Ho(n,a,r,i),b=n*d+r*p+o*f;0===b&&fo("Matrix has 0 determinant"),t[0]=d/b,t[3]=p/b,t[6]=f/b,t[1]=g/b,t[4]=m/b,t[7]=h/b,t[2]=v/b,t[5]=T/b,t[8]=y/b},identity3x3:Zo,identity:Qo,isIdentity:function(e){return Yo(e,so,arguments.length>1&&void 0!==arguments[1]?arguments[1]:co)},isIdentity3x3:function(e){return Yo(e,lo,arguments.length>1&&void 0!==arguments[1]?arguments[1]:co)},determinant3x3:qo,quaternionToMatrix3x3:Jo,areEquals:Xo,areMatricesEqual:Yo,roundNumber:ea,roundVector:ta,matrix3x3ToQuaternion:ra,multiplyQuaternion:function(e,t,n){const r=e[0]*t[0],o=e[0]*t[1],a=e[0]*t[2],i=e[0]*t[3],s=e[1]*t[0],l=e[1]*t[1],c=e[1]*t[2],u=e[1]*t[3],d=e[2]*t[0],p=e[2]*t[1],f=e[2]*t[2],g=e[2]*t[3],m=e[3]*t[0],h=e[3]*t[1],v=e[3]*t[2],T=e[3]*t[3];n[0]=r-l-f-T,n[1]=o+s+g-v,n[2]=a-u+d+h,n[3]=i+c-p+m},orthogonalize3x3:oa,diagonalize3x3:aa,singularValueDecomposition3x3:function(e,t,n,r){let o;const a=[...e],i=qo(a);if(i<0)for(o=0;o<9;o++)a[o]=-a[o];oa(a,t),$o(a,a),Ko(a,t,r),aa(r,n,r),Ko(t,r,t),$o(r,r),i<0&&(n[0]=-n[0],n[1]=-n[1],n[2]=-n[2])},solveLinearSystem:la,invertMatrix:ca,luFactorLinearSystem:ia,luSolveLinearSystem:sa,estimateMatrixCondition:function(e,t){let n=+Number.MAX_VALUE,r=-Number.MAX_VALUE;for(let n=0;n<t;n++)for(let o=n;o<t;o++)Math.abs(e[n*t+o])>r&&(r=Math.abs(e[n*t+o]));for(let r=0;r<t;r++)Math.abs(e[r*t+r])<n&&(n=Math.abs(e[r*t+r]));return 0===n?Number.MAX_VALUE:r/n},jacobi:function(e,t,n){return na(e,3,t,n)},jacobiN:na,solveHomogeneousLeastSquares:ua,solveLeastSquares:function(e,t,n,r,o,a){let i=!(arguments.length>6&&void 0!==arguments[6])||arguments[6];if(e<n||e<o)return fo("Insufficient number of samples. Underdetermined."),0;const s=To(o);let l,c,u,d,p=1,f=0,g=0;if(i){for(u=0;u<o;u++)s[u]=1;for(c=0;c<e;c++)for(u=0;u<o;u++)Math.abs(r[c*o+u])>uo&&(p=0,s[u]=0);if(p&&1===o)return fo("Detected homogeneous system (Y=0), calling SolveHomogeneousLeastSquares()"),ua(e,t,n,a);if(p)g=1;else for(u=0;u<o;u++)s[u]&&(g=1)}g&&(l=To(n),f=ua(e,t,n,l));const m=To(n*n),h=To(n*n),v=To(n*o);for(d=0;d<e;d++)for(c=0;c<n;c++){for(u=c;u<n;u++)m[c*n+u]+=t[d*n+c]*t[d*n+u];for(u=0;u<o;u++)v[c*o+u]+=t[d*n+c]*r[d*o+u]}for(c=0;c<n;c++)for(u=0;u<c;u++)m[c*n+u]=m[u*n+c];const T=ca(m,h,n);if(T)for(c=0;c<n;c++)for(u=0;u<o;u++)for(a[c*o+u]=0,d=0;d<n;d++)a[c*o+u]+=h[c*n+d]*v[d*o+u];if(g)for(u=0;u<o;u++)if(s[u])for(c=0;c<n;c++)a[c*o+u]=l[c*o];return g?f&&T:T},hex2float:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[0,.5,1];switch(e.length){case 3:return t[0]=17*parseInt(e[0],16)/255,t[1]=17*parseInt(e[1],16)/255,t[2]=17*parseInt(e[2],16)/255,t;case 4:return t[0]=17*parseInt(e[1],16)/255,t[1]=17*parseInt(e[2],16)/255,t[2]=17*parseInt(e[3],16)/255,t;case 6:return t[0]=parseInt(e.substr(0,2),16)/255,t[1]=parseInt(e.substr(2,2),16)/255,t[2]=parseInt(e.substr(4,2),16)/255,t;case 7:return t[0]=parseInt(e.substr(1,2),16)/255,t[1]=parseInt(e.substr(3,2),16)/255,t[2]=parseInt(e.substr(5,2),16)/255,t;case 9:return t[0]=parseInt(e.substr(1,2),16)/255,t[1]=parseInt(e.substr(3,2),16)/255,t[2]=parseInt(e.substr(5,2),16)/255,t[3]=parseInt(e.substr(7,2),16)/255,t;default:return t}},rgb2hsv:da,hsv2rgb:pa,lab2xyz:fa,xyz2lab:ga,xyz2rgb:ma,rgb2xyz:ha,rgb2lab:va,lab2rgb:Ta,uninitializeBounds:ya,areBoundsInitialized:ba,computeBoundsFromPoints:function(e,t,n){return n[0]=Math.min(e[0],t[0]),n[1]=Math.max(e[0],t[0]),n[2]=Math.min(e[1],t[1]),n[3]=Math.max(e[1],t[1]),n[4]=Math.min(e[2],t[2]),n[5]=Math.max(e[2],t[2]),n},clampValue:xa,clampVector:Ca,clampAndNormalizeValue:function(e,t){let n=0;return t[0]!==t[1]&&(n=e<t[0]?t[0]:e>t[1]?t[1]:e,n=(n-t[0])/(t[1]-t[0])),n},getScalarTypeFittingRange:Sa,getAdjustedScalarRange:Aa,extentIsWithinOtherExtent:function(e,t){if(!e||!t)return 0;for(let n=0;n<6;n+=2)if(e[n]<t[n]||e[n]>t[n+1]||e[n+1]<t[n]||e[n+1]>t[n+1])return 0;return 1},boundsIsWithinOtherBounds:function(e,t,n){if(!e||!t)return 0;for(let r=0;r<6;r+=2)if(e[r]+n[r/2]<t[r]||e[r]-n[r/2]>t[r+1]||e[r+1]+n[r/2]<t[r]||e[r+1]-n[r/2]>t[r+1])return 0;return 1},pointIsWithinBounds:function(e,t,n){if(!e||!t||!n)return 0;for(let r=0;r<3;r++)if(e[r]+n[r]<t[2*r]||e[r]-n[r]>t[2*r+1])return 0;return 1},solve3PointCircle:function(e,t,n,r){const o=To(3),a=To(3),i=To(3),s=To(3),l=To(3),c=To(3);for(let r=0;r<3;++r)o[r]=e[r]-t[r],a[r]=t[r]-n[r],i[r]=n[r]-e[r],s[r]=-o[r],l[r]=-a[r],c[r]=-i[r];const u=_o(s),d=_o(l),p=_o(i),f=To(3);Fo(o,a,f);const g=_o(f),m=u*d*p/(2*g),h=2*g*g,v=d*d*No(o,c)/h,T=p*p*No(s,a)/h,y=u*u*No(i,l)/h;for(let o=0;o<3;++o)r[o]=v*e[o]+T*t[o]+y*n[o];return m},inf:1/0,negInf:-1/0,isInf:Ia,isNan:Oa,isNaN:Oa,isFinite:wa,createUninitializedBounds:Ra,getMajorAxisIndex:function(e){let t=-1,n=-1;for(let r=0;r<e.length;r++){const o=Math.abs(e[r]);o>t&&(n=r,t=o)}return n},getSparseOrthogonalMatrix:Ma,floatToHex2:Ea,floatRGB2HexCode:function(e){return`${arguments.length>1&&void 0!==arguments[1]?arguments[1]:"#"}${e.map(Ea).join("")}`},float2CssRGBA:function(e){return 3===e.length?`rgb(${e.map(Va).join(", ")})`:`rgba(${Va(e[0]||0)}, ${Va(e[1]||0)}, ${Va(e[2]||0)}, ${e[3]||0})`}};function Ba(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3];return e[0]=n[0]*r+n[4]*o+n[8]*a+n[12]*i,e[1]=n[1]*r+n[5]*o+n[9]*a+n[13]*i,e[2]=n[2]*r+n[6]*o+n[10]*a+n[14]*i,e[3]=n[3]*r+n[7]*o+n[11]*a+n[15]*i,e}function Na(){var e=new i(4);return i!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e[3]=1,e}function Fa(e,t,n){n*=.5;var r=Math.sin(n);return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=Math.cos(n),e}function _a(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=n[0],l=n[1],c=n[2],u=n[3];return e[0]=r*u+i*s+o*c-a*l,e[1]=o*u+i*l+a*s-r*c,e[2]=a*u+i*c+r*l-o*s,e[3]=i*u-r*s-o*l-a*c,e}Da=new i(4),i!=Float32Array&&(Da[0]=0,Da[1]=0,Da[2]=0,Da[3]=0);var ka=function(e,t,n,r){var o=new i(4);return o[0]=e,o[1]=t,o[2]=n,o[3]=r,o};gn(),hn(1,0,0),hn(0,1,0),Na(),Na(),ie();const Ga={};function Ua(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ga,n),Ht.obj(e,t),Ht.setGet(e,t,["transform"]),function(e,t){t.classHierarchy.push("vtkImplicitFunction"),e.functionValue=n=>{if(!t.transform)return e.evaluateFunction(n);const r=[];return t.transform.transformPoint(n,r),e.evaluateFunction(r)},e.evaluateFunction=e=>{Ht.vtkErrorMacro("not implemented")}}(e,t)}var za={newInstance:Ht.newInstance(Ua,"vtkImplicitFunction"),extend:Ua};const Wa=1e-6,Ha="coincide",ja="disjoint";function Ka(e,t,n){const r=n[0]*(e[0]-t[0])+n[1]*(e[1]-t[1])+n[2]*(e[2]-t[2]);return Math.abs(r)}function $a(e,t,n,r){const o=[];Vo(e,t,o);const a=No(n,o);r[0]=e[0]-a*n[0],r[1]=e[1]-a*n[1],r[2]=e[2]-a*n[2]}function qa(e,t,n){const r=No(e,t);let o=No(t,t);return 0===o&&(o=1),n[0]=e[0]-r*t[0]/o,n[1]=e[1]-r*t[1]/o,n[2]=e[2]-r*t[2]/o,n}function Xa(e,t,n,r){const o=[];Vo(e,t,o);const a=No(n,o),i=No(n,n);0!==i?(r[0]=e[0]-a*n[0]/i,r[1]=e[1]-a*n[1]/i,r[2]=e[2]-a*n[2]/i):(r[0]=e[0],r[1]=e[1],r[2]=e[2])}function Ya(e,t,n,r){const o={intersection:!1,betweenPoints:!1,t:Number.MAX_VALUE,x:[]},a=[],i=[];Vo(t,e,a),Vo(n,e,i);const s=No(r,i),l=No(r,a);let c,u;return c=l<0?-l:l,u=s<0?-s*Wa:s*Wa,c<=u||(o.t=s/l,o.x[0]=e[0]+o.t*a[0],o.x[1]=e[1]+o.t*a[1],o.x[2]=e[2]+o.t*a[2],o.intersection=!0,o.betweenPoints=o.t>=0&&o.t<=1),o}function Za(e,t,n,r){const o={intersection:!1,l0:[],l1:[],error:null},a=[];Fo(t,r,a);const i=a.map((e=>Math.abs(e)));if(i[0]+i[1]+i[2]<Wa){const r=[];return Vo(e,n,r),0===No(t,r)?o.error=Ha:o.error=ja,o}let s;s=i[0]>i[1]&&i[0]>i[2]?"x":i[1]>i[2]?"y":"z";const l=[],c=-No(t,e),u=-No(r,n);switch(s){case"x":l[0]=0,l[1]=(u*t[2]-c*r[2])/a[0],l[2]=(c*r[1]-u*t[1])/a[0];break;case"y":l[0]=(c*r[2]-u*t[2])/a[1],l[1]=0,l[2]=(u*t[0]-c*r[0])/a[1];break;case"z":l[0]=(u*t[1]-c*r[1])/a[2],l[1]=(c*r[0]-u*t[0])/a[2],l[2]=0}return o.l0=l,Eo(l,a,o.l1),o.intersection=!0,o}const Qa={evaluate:function(e,t,n){return e[0]*(n[0]-t[0])+e[1]*(n[1]-t[1])+e[2]*(n[2]-t[2])},distanceToPlane:Ka,projectPoint:$a,projectVector:qa,generalizedProjectPoint:Xa,intersectWithLine:Ya,intersectWithPlane:Za,DISJOINT:ja,COINCIDE:Ha},Ja={normal:[0,0,1],origin:[0,0,0]};function ei(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ja,n),za.extend(e,t,n),Ht.setGetArray(e,t,["normal","origin"],3),function(e,t){t.classHierarchy.push("vtkPlane"),e.distanceToPlane=e=>Ka(e,t.origin,t.normal),e.projectPoint=(e,n)=>{$a(e,t.origin,t.normal,n)},e.projectVector=(e,n)=>qa(e,t.normal,n),e.push=e=>{if(0!==e)for(let n=0;n<3;n++)t.origin[n]+=e*t.normal[n]},e.generalizedProjectPoint=(e,n)=>{Xa(e,t.origin,t.normal,n)},e.evaluateFunction=(e,n,r)=>Array.isArray(e)?t.normal[0]*(e[0]-t.origin[0])+t.normal[1]*(e[1]-t.origin[1])+t.normal[2]*(e[2]-t.origin[2]):t.normal[0]*(e-t.origin[0])+t.normal[1]*(n-t.origin[1])+t.normal[2]*(r-t.origin[2]),e.evaluateGradient=e=>[t.normal[0],t.normal[1],t.normal[2]],e.intersectWithLine=(e,n)=>Ya(e,n,t.origin,t.normal),e.intersectWithPlane=(e,n)=>Za(e,n,t.origin,t.normal)}(e,t)}var ti={newInstance:Ht.newInstance(ei,"vtkPlane"),extend:ei,...Qa};const ni=[Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE];function ri(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]}function oi(e){return e?.length>=6&&e[0]<=e[1]&&e[2]<=e[3]&&e[4]<=e[5]}function ai(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e}function ii(e){return ai(e,ni)}function si(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=o<t?o:t,e[1]=a>t?a:t,e[2]=i<n?i:n,e[3]=s>n?s:n,e[4]=l<r?l:r,e[5]=c>r?c:r,e}function li(e,t){if(0===t.length)return e;if(Array.isArray(t[0]))for(let n=0;n<t.length;++n)si(e,...t[n]);else for(let n=0;n<t.length;n+=3)si(e,...t.slice(n,n+3));return e}function ci(e,t,n,r,o,a,i){const[s,l,c,u,d,p]=e;return void 0===i?(e[0]=Math.min(t[0],s),e[1]=Math.max(t[1],l),e[2]=Math.min(t[2],c),e[3]=Math.max(t[3],u),e[4]=Math.min(t[4],d),e[5]=Math.max(t[5],p)):(e[0]=Math.min(t,s),e[1]=Math.max(n,l),e[2]=Math.min(r,c),e[3]=Math.max(o,u),e[4]=Math.min(a,d),e[5]=Math.max(i,p)),e}function ui(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=t,e[1]=t>a?t:a,e[2]=n,e[3]=n>s?n:s,e[4]=r,e[5]=r>c?r:c,o!==t||i!==n||l!==r}function di(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=t<o?t:o,e[1]=t,e[2]=n<i?n:i,e[3]=n,e[4]=r<l?r:l,e[5]=r,a!==t||s!==n||c!==r}function pi(e,t){return e[0]-=t,e[1]+=t,e[2]-=t,e[3]+=t,e[4]-=t,e[5]+=t,e}function fi(e,t,n,r){return!!oi(e)&&(t>=0?(e[0]*=t,e[1]*=t):(e[0]=t*e[1],e[1]=t*e[0]),n>=0?(e[2]*=n,e[3]*=n):(e[2]=n*e[3],e[3]=n*e[2]),r>=0?(e[4]*=r,e[5]*=r):(e[4]=r*e[5],e[5]=r*e[4]),!0)}function gi(e){return[.5*(e[0]+e[1]),.5*(e[2]+e[3]),.5*(e[4]+e[5])]}function mi(e,t){return e[2*t+1]-e[2*t]}function hi(e){return[mi(e,0),mi(e,1),mi(e,2)]}function vi(e){return e.slice(0,2)}function Ti(e){return e.slice(2,4)}function yi(e){return e.slice(4,6)}function bi(e){const t=hi(e);return t[0]>t[1]?t[0]>t[2]?t[0]:t[2]:t[1]>t[2]?t[1]:t[2]}function xi(e){if(oi(e)){const t=hi(e);return Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2])}return null}function Ci(e){return[e[0],e[2],e[4]]}function Si(e){return[e[1],e[3],e[5]]}function Ai(e,t){return e<=0&&t>=0||e>=0&&t<=0}function Ii(e,t){let n=0;for(let r=0;r<2;r++)for(let o=2;o<4;o++)for(let a=4;a<6;a++)t[n++]=[e[r],e[o],e[a]];return t}function wi(e,t,n){return t[0]=e[0],t[1]=e[2],t[2]=e[4],n[0]=e[1],n[1]=e[3],n[2]=e[5],t}function Oi(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];const r=Ii(e,[]);for(let e=0;e<r.length;++e)wn(r[e],r[e],t);return ii(n),li(n,r)}function Pi(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return t[0]=.5*(e[1]-e[0]),t[1]=.5*(e[3]-e[2]),t[2]=.5*(e[5]-e[4]),t}function Ri(e,t,n,r){const o=[].concat(ni),a=e.getData();for(let e=0;e<a.length;e+=3){const i=[a[e],a[e+1],a[e+2]],s=No(i,t);o[0]=Math.min(s,o[0]),o[1]=Math.max(s,o[1]);const l=No(i,n);o[2]=Math.min(l,o[2]),o[3]=Math.max(l,o[3]);const c=No(i,r);o[4]=Math.min(c,o[4]),o[5]=Math.max(c,o[5])}return o}function Mi(e,t,n,r,o){let a=!0;const i=[];let s=0;const l=[],c=[0,0,0];for(let n=0;n<3;n++)t[n]<e[2*n]?(i[n]=1,c[n]=e[2*n],a=!1):t[n]>e[2*n+1]?(i[n]=0,c[n]=e[2*n+1],a=!1):i[n]=2;if(a)return r[0]=t[0],r[1]=t[1],r[2]=t[2],o[0]=0,1;for(let e=0;e<3;e++)2!==i[e]&&0!==n[e]?l[e]=(c[e]-t[e])/n[e]:l[e]=-1;for(let e=0;e<3;e++)l[s]<l[e]&&(s=e);if(l[s]>1||l[s]<0)return 0;o[0]=l[s];for(let o=0;o<3;o++)if(s!==o){if(r[o]=t[o]+l[s]*n[o],r[o]<e[2*o]||r[o]>e[2*o+1])return 0}else r[o]=c[o];return 1}function Ei(e,t,n){const r=[];let o=0,a=1,i=1;for(let s=4;s<=5;++s){r[2]=e[s];for(let s=2;s<=3;++s){r[1]=e[s];for(let s=0;s<=1;++s)if(r[0]=e[s],o=ti.evaluate(n,t,r),i&&(a=o>=0?1:-1,i=0),0===o||a>0&&o<0||a<0&&o>0)return 1}}return 0}function Vi(e,t){if(!oi(e)||!oi(t))return!1;const n=[0,0,0,0,0,0];let r;for(let o=0;o<3;o++)if(r=!1,t[2*o]>=e[2*o]&&t[2*o]<=e[2*o+1]?(r=!0,n[2*o]=t[2*o]):e[2*o]>=t[2*o]&&e[2*o]<=t[2*o+1]&&(r=!0,n[2*o]=e[2*o]),t[2*o+1]>=e[2*o]&&t[2*o+1]<=e[2*o+1]?(r=!0,n[2*o+1]=t[2*o+1]):e[2*o+1]>=t[2*o]&&e[2*o+1]<=t[2*o+1]&&(r=!0,n[2*o+1]=e[2*o+1]),!r)return!1;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],!0}function Di(e,t){if(!oi(e)||!oi(t))return!1;for(let n=0;n<3;n++)if(!(t[2*n]>=e[2*n]&&t[2*n]<=e[2*n+1]||e[2*n]>=t[2*n]&&e[2*n]<=t[2*n+1]||t[2*n+1]>=e[2*n]&&t[2*n+1]<=e[2*n+1]||e[2*n+1]>=t[2*n]&&e[2*n+1]<=t[2*n+1]))return!1;return!0}function Li(e,t,n,r){return!(t<e[0]||t>e[1]||n<e[2]||n>e[3]||r<e[4]||r>e[5])}function Bi(e,t,n){const r=[[0,1,2,3,4,5,6,7],[0,1,4,5,2,3,6,7],[0,2,4,6,1,3,5,7]],o=[0,0,0,0,0,0,0,0];let a=0;for(let r=0;r<2;r++)for(let i=2;i<4;i++)for(let s=4;s<6;s++){const l=[e[r],e[i],e[s]];o[a++]=ti.evaluate(n,t,l)}let i=2;for(;i--&&!(Ai(o[r[i][0]],o[r[i][4]])&&Ai(o[r[i][1]],o[r[i][5]])&&Ai(o[r[i][2]],o[r[i][6]])&&Ai(o[r[i][3]],o[r[i][7]])););if(i<0)return!1;const s=Math.sign(n[i]),l=Math.abs((e[2*i+1]-e[2*i])*n[i]);let c=s>0?1:0;for(let e=0;e<4;e++){if(0===l)continue;const t=Math.abs(o[r[i][e]])/l;s>0&&t<c&&(c=t),s<0&&t>c&&(c=t)}const u=(1-c)*e[2*i]+c*e[2*i+1];return s>0?e[2*i]=u:e[2*i+1]=u,!0}class Ni{constructor(e){this.bounds=e,this.bounds||(this.bounds=new Float64Array(ni))}getBounds(){return this.bounds}equals(e){return ri(this.bounds,e)}isValid(){return oi(this.bounds)}setBounds(e){return ai(this.bounds,e)}reset(){return ii(this.bounds)}addPoint(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return si(this.bounds,...t)}addPoints(e){return li(this.bounds,e)}addBounds(e,t,n,r,o,a){return ci(this.bounds,e,t,n,r,o,a)}setMinPoint(e,t,n){return ui(this.bounds,e,t,n)}setMaxPoint(e,t,n){return di(this.bounds,e,t,n)}inflate(e){return pi(this.bounds,e)}scale(e,t,n){return fi(this.bounds,e,t,n)}getCenter(){return gi(this.bounds)}getLength(e){return mi(this.bounds,e)}getLengths(){return hi(this.bounds)}getMaxLength(){return bi(this.bounds)}getDiagonalLength(){return xi(this.bounds)}getMinPoint(){return Ci(this.bounds)}getMaxPoint(){return Si(this.bounds)}getXRange(){return vi(this.bounds)}getYRange(){return Ti(this.bounds)}getZRange(){return yi(this.bounds)}getCorners(e){return Ii(this.bounds,e)}computeCornerPoints(e,t){return wi(this.bounds,e,t)}computeLocalBounds(e,t,n){return Ri(this.bounds,e,t,n)}transformBounds(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Oi(this.bounds,e,t)}computeScale3(e){return Pi(this.bounds,e)}cutWithPlane(e,t){return Bi(this.bounds,e,t)}intersectBox(e,t,n,r){return Mi(this.bounds,e,t,n,r)}intersectPlane(e,t){return Ei(this.bounds,e,t)}intersect(e){return Vi(this.bounds,e)}intersects(e){return Di(this.bounds,e)}containsPoint(e,t,n){return Li(this.bounds,e,t,n)}contains(e){return Di(this.bounds,e)}}var Fi={newInstance:function(e){const t=e&&e.bounds;return new Ni(t)},equals:ri,isValid:oi,setBounds:ai,reset:ii,addPoint:si,addPoints:li,addBounds:ci,setMinPoint:ui,setMaxPoint:di,inflate:pi,scale:fi,scaleAboutCenter:function(e,t,n,r){if(!oi(e))return!1;const o=gi(e);return e[0]-=o[0],e[1]-=o[0],e[2]-=o[1],e[3]-=o[1],e[4]-=o[2],e[5]-=o[2],fi(e,t,n,r),e[0]+=o[0],e[1]+=o[0],e[2]+=o[1],e[3]+=o[1],e[4]+=o[2],e[5]+=o[2],!0},getCenter:gi,getLength:mi,getLengths:hi,getMaxLength:bi,getDiagonalLength:xi,getMinPoint:Ci,getMaxPoint:Si,getXRange:vi,getYRange:Ti,getZRange:yi,getCorners:Ii,computeCornerPoints:wi,computeLocalBounds:Ri,transformBounds:Oi,computeScale3:Pi,cutWithPlane:Bi,intersectBox:Mi,intersectPlane:Ei,intersect:Vi,intersects:Di,containsPoint:Li,contains:function(e,t){return!!Di(e,t)&&!!Li(e,...Ci(t))&&!!Li(e,...Si(t))},INIT_BOUNDS:ni},_i={CoordinateSystem:{DISPLAY:0,WORLD:1}};const{CoordinateSystem:ki}=_i;function Gi(e){return()=>Ht.vtkErrorMacro(`vtkProp::${e} - NOT IMPLEMENTED`)}const Ui={allocatedRenderTime:10,coordinateSystem:ki.WORLD,dragable:!0,estimatedRenderTime:0,paths:null,pickable:!0,renderTimeMultiplier:1,savedEstimatedRenderTime:0,textures:[],useBounds:!0,visibility:!0};function zi(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ui,n),Ht.obj(e,t),Ht.get(e,t,["estimatedRenderTime","allocatedRenderTime"]),Ht.setGet(e,t,["_parentProp","coordinateSystem","dragable","pickable","renderTimeMultiplier","useBounds","visibility"]),Ht.moveToProtected(e,t,["parentProp"]),function(e,t){t.classHierarchy.push("vtkProp"),e.getMTime=()=>{let e=t.mtime;for(let n=0;n<t.textures.length;++n){const r=t.textures[n].getMTime();r>e&&(e=r)}return e},e.processSelectorPixelBuffers=(e,t)=>{},e.getNestedProps=()=>null,e.getActors=()=>[],e.getActors2D=()=>[],e.getVolumes=()=>[],e.pick=Gi("pick"),e.hasKey=Gi("hasKey"),e.getNestedVisibility=()=>t.visibility&&(!t._parentProp||t._parentProp.getNestedVisibility()),e.getNestedPickable=()=>t.pickable&&(!t._parentProp||t._parentProp.getNestedPickable()),e.getNestedDragable=()=>t.dragable&&(!t._parentProp||t._parentProp.getNestedDragable()),e.getRedrawMTime=()=>t.mtime,e.setEstimatedRenderTime=e=>{t.estimatedRenderTime=e,t.savedEstimatedRenderTime=e},e.restoreEstimatedRenderTime=()=>{t.estimatedRenderTime=t.savedEstimatedRenderTime},e.addEstimatedRenderTime=e=>{t.estimatedRenderTime+=e},e.setAllocatedRenderTime=e=>{t.allocatedRenderTime=e,t.savedEstimatedRenderTime=t.estimatedRenderTime,t.estimatedRenderTime=0},e.getSupportsSelection=()=>!1,e.getTextures=()=>t.textures,e.hasTexture=e=>-1!==t.textures.indexOf(e),e.addTexture=n=>{n&&!e.hasTexture(n)&&(t.textures=t.textures.concat(n),e.modified())},e.removeTexture=n=>{const r=t.textures.filter((e=>e!==n));t.textures.length!==r.length&&(t.textures=r,e.modified())},e.removeAllTextures=()=>{t.textures=[],e.modified()},e.setCoordinateSystemToWorld=()=>e.setCoordinateSystem(ki.WORLD),e.setCoordinateSystemToDisplay=()=>e.setCoordinateSystem(ki.DISPLAY)}(e,t)}var Wi={newInstance:Ht.newInstance(zi,"vtkProp"),extend:zi,..._i};const Hi={origin:[0,0,0],position:[0,0,0],orientation:[0,0,0],rotation:null,scale:[1,1,1],bounds:[...Fi.INIT_BOUNDS],properties:[],userMatrix:null,userMatrixMTime:null,cachedProp3D:null,isIdentity:!0,matrixMTime:null};function ji(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Hi,n),Wi.extend(e,t,n),t.matrixMTime={},Ht.obj(t.matrixMTime),Ht.get(e,t,["isIdentity"]),Ht.getArray(e,t,["orientation"]),Ht.setGetArray(e,t,["origin","position","scale"],3),Ht.setGet(e,t,["properties"]),t.matrix=g(new Float64Array(16)),t.rotation=g(new Float64Array(16)),t.userMatrix=g(new Float64Array(16)),t.transform=null,function(e,t){t.classHierarchy.push("vtkProp3D"),e.addPosition=n=>{t.position=t.position.map(((e,t)=>e+n[t])),e.modified()},e.getOrientationWXYZ=()=>{const e=Na();N(e,t.rotation);const n=new Float64Array(3),r=function(e,t){var n=2*Math.acos(t[3]),r=Math.sin(n/2);return r>a?(e[0]=t[0]/r,e[1]=t[1]/r,e[2]=t[2]/r):(e[0]=1,e[1]=0,e[2]=0),n}(n,e);return[bo(r),n[0],n[1],n[2]]},e.getOrientationQuaternion=function(){return N(arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t.rotation)},e.rotateX=n=>{0!==n&&(S(t.rotation,t.rotation,yo(n)),e.modified())},e.rotateY=n=>{0!==n&&(A(t.rotation,t.rotation,yo(n)),e.modified())},e.rotateZ=n=>{0!==n&&(I(t.rotation,t.rotation,yo(n)),e.modified())},e.rotateWXYZ=(n,r,o,a)=>{if(0===n||0===r&&0===o&&0===a)return;const i=yo(n),s=Na();Fa(s,[r,o,a],i);const l=new Float64Array(16);k(l,s),y(t.rotation,t.rotation,l),e.modified()},e.rotateQuaternion=n=>{if(Math.abs(n[3])>=.999999)return;const r=k(new Float64Array(16),n);y(t.rotation,t.rotation,r),e.modified()},e.setOrientation=(n,r,o)=>(n!==t.orientation[0]||r!==t.orientation[1]||o!==t.orientation[2])&&(t.orientation=[n,r,o],g(t.rotation),e.rotateZ(o),e.rotateX(n),e.rotateY(r),e.modified(),!0),e.setUserMatrix=n=>!Yo(t.userMatrix,n)&&(d(t.userMatrix,n),e.modified(),!0),e.getMatrix=()=>(e.computeMatrix(),t.matrix),e.computeMatrix=()=>{if(e.getMTime()>t.matrixMTime.getMTime()){g(t.matrix),t.userMatrix&&y(t.matrix,t.matrix,t.userMatrix),b(t.matrix,t.matrix,t.origin),b(t.matrix,t.matrix,t.position),y(t.matrix,t.matrix,t.rotation),x(t.matrix,t.matrix,t.scale),b(t.matrix,t.matrix,[-t.origin[0],-t.origin[1],-t.origin[2]]),m(t.matrix,t.matrix),t.isIdentity=!0;for(let e=0;e<4;++e)for(let n=0;n<4;++n)(e===n?1:0)!==t.matrix[e+4*n]&&(t.isIdentity=!1);t.matrixMTime.modified()}},e.getBoundsByReference=()=>{if(null===t.mapper)return t.bounds;const n=t.mapper.getBounds();if(!n||6!==n.length)return n;if(n[0]>n[1])return t.mapperBounds=n,t.bounds=[...Fi.INIT_BOUNDS],t.boundsMTime.modified(),n;if(!t.mapperBounds||!n.every(((e,r)=>n[r]===t.mapperBounds[r]))||e.getMTime()>t.boundsMTime.getMTime()){Ht.vtkDebugMacro("Recomputing bounds..."),t.mapperBounds=n,e.computeMatrix();const r=new Float64Array(16);m(r,t.matrix),Fi.transformBounds(n,r,t.bounds),t.boundsMTime.modified()}return t.bounds},e.getBounds=()=>{const t=e.getBoundsByReference();try{return[...t]}catch{return t}},e.getCenter=()=>Fi.getCenter(t.bounds),e.getLength=()=>Fi.getLength(t.bounds),e.getXRange=()=>Fi.getXRange(t.bounds),e.getYRange=()=>Fi.getYRange(t.bounds),e.getZRange=()=>Fi.getZRange(t.bounds),e.getUserMatrix=()=>t.userMatrix,e.onModified((function(){e.computeMatrix()})),e.getProperty=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null==t.properties[n]&&(t.properties[n]=e.makeProperty?.()),t.properties[n]},e.setProperty=(e,n)=>{const r=Number.isInteger(e),[o,a]=r?[e,n]:[0,e];return t.properties[o]!==a&&(t.properties[o]=a,!0)},e.getMTime=()=>{let e=t.mtime;return t.properties.forEach((t=>{if(null!==t){const n=t.getMTime();e=n>e?n:e}})),e}}(e,t)}var Ki={newInstance:Ht.newInstance(ji,"vtkProp3D"),extend:ji};const $i={FLAT:0,GOURAUD:1,PHONG:2},qi={POINTS:0,WIREFRAME:1,SURFACE:2};var Xi={Shading:$i,Representation:qi,Interpolation:$i};const{Representation:Yi,Interpolation:Zi}=Xi;function Qi(e){return()=>Ht.vtkErrorMacro(`vtkProperty::${e} - NOT IMPLEMENTED`)}const Ji={color:[1,1,1],ambientColor:[1,1,1],diffuseColor:[1,1,1],specularColor:[1,1,1],edgeColor:[0,0,0],ambient:0,diffuse:1,metallic:0,roughness:.6,normalStrength:1,emission:1,baseIOR:1.45,specular:0,specularPower:1,opacity:1,interpolation:Zi.GOURAUD,representation:Yi.SURFACE,edgeVisibility:!1,backfaceCulling:!1,frontfaceCulling:!1,pointSize:1,lineWidth:1,lighting:!0,shading:!1,materialName:null,ORMTexture:null,RMTexture:null};function es(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ji,n),Ht.obj(e,t),Ht.setGet(e,t,["lighting","interpolation","ambient","diffuse","metallic","roughness","normalStrength","emission","baseIOR","specular","specularPower","opacity","edgeVisibility","lineWidth","pointSize","backfaceCulling","frontfaceCulling","representation","diffuseTexture","metallicTexture","roughnessTexture","normalTexture","ambientOcclusionTexture","emissionTexture","ORMTexture","RMTexture"]),Ht.setGetArray(e,t,["ambientColor","specularColor","diffuseColor","edgeColor"],3),function(e,t){t.classHierarchy.push("vtkProperty"),e.setColor=(n,r,o)=>{Array.isArray(n)?t.color[0]===n[0]&&t.color[1]===n[1]&&t.color[2]===n[2]||(t.color[0]=n[0],t.color[1]=n[1],t.color[2]=n[2],e.modified()):t.color[0]===n&&t.color[1]===r&&t.color[2]===o||(t.color[0]=n,t.color[1]=r,t.color[2]=o,e.modified()),e.setDiffuseColor(t.color),e.setAmbientColor(t.color),e.setSpecularColor(t.color)},e.computeCompositeColor=Qi("ComputeCompositeColor"),e.getColor=()=>{let e=0;t.ambient+t.diffuse+t.specular>0&&(e=1/(t.ambient+t.diffuse+t.specular));for(let n=0;n<3;n++)t.color[n]=e*(t.ambient*t.ambientColor[n]+t.diffuse*t.diffuseColor[n]+t.specular*t.specularColor[n]);return[].concat(t.color)},e.setSpecularPower=n=>{const r=1/Math.max(1,n);t.roughness===r&&t.specularPower===n||(t.specularPower=n,t.roughness=r,e.modified())},e.addShaderVariable=Qi("AddShaderVariable"),e.setInterpolationToFlat=()=>e.setInterpolation(Zi.FLAT),e.setInterpolationToGouraud=()=>e.setInterpolation(Zi.GOURAUD),e.setInterpolationToPhong=()=>e.setInterpolation(Zi.PHONG),e.getInterpolationAsString=()=>Ht.enumToString(Zi,t.interpolation),e.setRepresentationToWireframe=()=>e.setRepresentation(Yi.WIREFRAME),e.setRepresentationToSurface=()=>e.setRepresentation(Yi.SURFACE),e.setRepresentationToPoints=()=>e.setRepresentation(Yi.POINTS),e.getRepresentationAsString=()=>Ht.enumToString(Yi,t.representation)}(e,t)}var ts={newInstance:Ht.newInstance(es,"vtkProperty"),extend:es,...Xi};const ns={mapper:null,backfaceProperty:null,forceOpaque:!1,forceTranslucent:!1};function rs(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ns,n),Ki.extend(e,t,n),t.boundsMTime={},Ht.obj(t.boundsMTime),Ht.setGet(e,t,["backfaceProperty","forceOpaque","forceTranslucent","mapper"]),function(e,t){t.classHierarchy.push("vtkActor");const n={...e};e.getActors=()=>[e],e.getIsOpaque=()=>{if(t.forceOpaque)return!0;if(t.forceTranslucent)return!1;t.properties[0]||e.getProperty();let n=t.properties[0].getOpacity()>=1;return n=n&&(!t.texture||!t.texture.isTranslucent()),n=n&&(!t.mapper||t.mapper.getIsOpaque()),n},e.hasTranslucentPolygonalGeometry=()=>null!==t.mapper&&(t.properties[0]||e.getProperty(),!e.getIsOpaque()),e.makeProperty=ts.newInstance,e.getMTime=()=>{let e=n.getMTime();if(null!==t.backfaceProperty){const n=t.backfaceProperty.getMTime();e=n>e?n:e}return e},e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}return e},e.getSupportsSelection=()=>!!t.mapper&&t.mapper.getSupportsSelection(),e.processSelectorPixelBuffers=(e,n)=>{t.mapper&&t.mapper.processSelectorPixelBuffers&&t.mapper.processSelectorPixelBuffers(e,n)}}(e,t)}var os={newInstance:Ht.newInstance(rs,"vtkActor"),extend:rs};const as={Int8Array:1,Uint8Array:1,Uint8ClampedArray:1,Int16Array:2,Uint16Array:2,Int32Array:4,Uint32Array:4,Float32Array:4,Float64Array:8},is={VOID:"",CHAR:"Int8Array",SIGNED_CHAR:"Int8Array",UNSIGNED_CHAR:"Uint8Array",UNSIGNED_CHAR_CLAMPED:"Uint8ClampedArray",SHORT:"Int16Array",UNSIGNED_SHORT:"Uint16Array",INT:"Int32Array",UNSIGNED_INT:"Uint32Array",FLOAT:"Float32Array",DOUBLE:"Float64Array"};var ss={DefaultDataType:is.FLOAT,DataTypeByteSize:as,VtkDataTypes:is};const{vtkErrorMacro:ls}=jt,{DefaultDataType:cs}=ss;function us(e,t,n){const r=e.length;let o,a,i=Number.MAX_VALUE,s=-Number.MAX_VALUE;for(a=t;a<r;a+=n)if(!Number.isNaN(e[a])){i=e[a],s=i;break}for(;a<r;a+=n)o=e[a],o<i?i=o:o>s&&(s=o);return{min:i,max:s}}function ds(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;if(t<0&&n>1){const t=e.length/n,r=new Float64Array(t);for(let o=0,a=0;o<t;++o){for(let t=a+n;a<t;++a)r[o]+=e[a]*e[a];r[o]**=.5}return us(r,0,1)}return us(e,t<0?0:t,n)}function ps(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=e||[];for(;n.length<=t;)n.push(null);return n}function fs(e){return Object.prototype.toString.call(e).slice(8,-1)}const gs={computeRange:ds,createRangeHelper:function(){let e=Number.MAX_VALUE,t=-Number.MAX_VALUE,n=0,r=0;return{add(o){e>o&&(e=o),t<o&&(t=o),n++,r+=o},get(){return{min:e,max:t,count:n,sum:r,mean:r/n}},getRange(){return{min:e,max:t}}}},fastComputeRange:us,getDataType:fs,getMaxNorm:function(e){const t=e.getNumberOfComponents();let n=0;const r=new Array(t);for(let o=0;o<e.getNumberOfTuples();++o){e.getTuple(o,r);const a=_o(r,t);a>n&&(n=a)}return n}},ms={name:"",numberOfComponents:1,dataType:cs,rangeTuple:[0,0]};function hs(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,ms,n),Array.isArray(n.values)&&void 0===n.dataType&&console.warn("vtkDataArray.newInstance: no dataType provided, converting to Float32Array"),!t.empty&&!t.values&&!t.size)throw new TypeError("Cannot create vtkDataArray object without: size > 0, values");if(t.values?Array.isArray(t.values)&&(t.values=st(t.dataType,t.values)):t.values=it(t.dataType,t.size),t.values&&(t.size=t.size??t.values.length,t.dataType=fs(t.values)),vt(e,t),Ct(e,t,["name","numberOfComponents"]),t.size%t.numberOfComponents!=0)throw new RangeError("model.size is not a multiple of model.numberOfComponents");!function(e,t){function n(n){if(n<0)return!1;const r=e.getNumberOfComponents(),o=t.values.length/(r>0?r:1);if(n===o)return!0;if(n>o){const e=t.values;return t.values=it(t.dataType,(n+o)*r),t.values.set(e),!0}return t.size>n*r&&(t.size=n*r,e.dataChange()),!0}t.classHierarchy.push("vtkDataArray"),e.dataChange=()=>{t.ranges=null,e.modified()},e.resize=r=>{n(r);const o=r*e.getNumberOfComponents();return t.size!==o&&(t.size=o,e.dataChange(),!0)},e.initialize=()=>{e.resize(0)},e.getElementComponentSize=()=>t.values.BYTES_PER_ELEMENT,e.getComponent=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t.values[e*t.numberOfComponents+n]},e.setComponent=(n,r,o)=>{o!==t.values[n*t.numberOfComponents+r]&&(t.values[n*t.numberOfComponents+r]=o,e.dataChange())},e.getValue=n=>{const r=n/t.numberOfComponents,o=n%t.numberOfComponents;return e.getComponent(r,o)},e.setValue=(n,r)=>{const o=n/t.numberOfComponents,a=n%t.numberOfComponents;e.setComponent(o,a,r)},e.getData=()=>t.size===t.values.length?t.values:t.values.subarray(0,t.size),e.getRange=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:-1,r=n;r<0&&(r=1===t.numberOfComponents?0:t.numberOfComponents);let o=null;return t.ranges||(t.ranges=ps(t.ranges,t.numberOfComponents)),o=t.ranges[r],o?(t.rangeTuple[0]=o.min,t.rangeTuple[1]=o.max,t.rangeTuple):(o=ds(e.getData(),n,t.numberOfComponents),t.ranges[r]=o,t.rangeTuple[0]=o.min,t.rangeTuple[1]=o.max,t.rangeTuple)},e.setRange=(e,n)=>{t.ranges||(t.ranges=ps(t.ranges,t.numberOfComponents));const r={min:e.min,max:e.max};return t.ranges[n]=r,t.rangeTuple[0]=r.min,t.rangeTuple[1]=r.max,t.rangeTuple},e.getRanges=function(){if(arguments.length>0&&void 0!==arguments[0]&&!arguments[0])return structuredClone(t.ranges);const n=[];for(let r=0;r<t.numberOfComponents;r++){const[t,o]=e.getRange(r),a={min:t,max:o};n.push(a)}if(t.numberOfComponents>1){const[t,r]=e.getRange(-1),o={min:t,max:r};n.push(o)}return n},e.setTuple=(e,n)=>{const r=e*t.numberOfComponents;for(let e=0;e<t.numberOfComponents;e++)t.values[r+e]=n[e]},e.setTuples=(e,n)=>{let r=e*t.numberOfComponents;const o=Math.min(n.length,t.size-r);for(let e=0;e<o;)t.values[r++]=n[e++]},e.insertTuple=(r,o)=>(t.size<=r*t.numberOfComponents&&(t.size=(r+1)*t.numberOfComponents,n(r+1)),e.setTuple(r,o),r),e.insertTuples=(r,o)=>{const a=r+o.length/t.numberOfComponents;return t.size<a*t.numberOfComponents&&(t.size=a*t.numberOfComponents,n(a)),e.setTuples(r,o),a},e.insertNextTuple=n=>{const r=t.size/t.numberOfComponents;return e.insertTuple(r,n)},e.insertNextTuples=n=>{const r=t.size/t.numberOfComponents;return e.insertTuples(r,n)},e.findTuple=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e-6;for(let r=0;r<t.size;r+=t.numberOfComponents)if(Math.abs(e[0]-t.values[r])<=n){let o=!0;for(let a=1;a<t.numberOfComponents;++a)if(Math.abs(e[a]-t.values[r+a])>n){o=!1;break}if(o)return r/t.numberOfComponents}return-1},e.getTuple=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];const r=t.numberOfComponents||1,o=e*r;switch(r){case 4:n[3]=t.values[o+3];case 3:n[2]=t.values[o+2];case 2:n[1]=t.values[o+1];case 1:n[0]=t.values[o];break;default:for(let e=r-1;e>=0;--e)n[e]=t.values[o+e]}return n},e.getTuples=(n,r)=>{const o=(n??0)*t.numberOfComponents,a=(r??e.getNumberOfTuples())*t.numberOfComponents,i=e.getData().subarray(o,a);return i.length>0?i:null},e.getTupleLocation=function(){return(arguments.length>0&&void 0!==arguments[0]?arguments[0]:1)*t.numberOfComponents},e.getNumberOfComponents=()=>t.numberOfComponents,e.getNumberOfValues=()=>t.size,e.getNumberOfTuples=()=>t.size/t.numberOfComponents,e.getDataType=()=>t.dataType,e.newClone=()=>vs({empty:!0,name:t.name,dataType:t.dataType,numberOfComponents:t.numberOfComponents}),e.getName=()=>(t.name||(e.modified(),t.name=`vtkDataArray${e.getMTime()}`),t.name),e.setData=(n,r)=>{t.values=n,t.size=n.length,t.dataType=fs(n),r&&(t.numberOfComponents=r),t.size%t.numberOfComponents!=0&&(t.numberOfComponents=1),e.dataChange()},e.getState=()=>{if(t.deleted)return null;const n={...t,vtkClass:e.getClassName()};n.values=Array.from(n.values),delete n.buffer,Object.keys(n).forEach((e=>{n[e]||delete n[e]}));const r={};return Object.keys(n).sort().forEach((e=>{r[e]=n[e]})),r.mtime&&delete r.mtime,r},e.deepCopy=n=>{const r=e.getDataType(),o=t.values;e.shallowCopy(n),t.ranges=structuredClone(n.getRanges()),o?.length>=n.getNumberOfValues()&&r===n.getDataType()?(o.set(n.getData()),t.values=o,e.dataChange()):e.setData(n.getData().slice())},e.interpolateTuple=(n,r,o,a,i,s)=>{const l=t.numberOfComponents||1;l===r.getNumberOfComponents()&&l===a.getNumberOfComponents()||ls("numberOfComponents must match");const c=r.getTuple(o),u=a.getTuple(i),d=[];switch(d.length=l,l){case 4:d[3]=c[3]+(u[3]-c[3])*s;case 3:d[2]=c[2]+(u[2]-c[2])*s;case 2:d[1]=c[1]+(u[1]-c[1])*s;case 1:d[0]=c[0]+(u[0]-c[0])*s;break;default:for(let e=0;e<l;e++)d[e]=c[e]+(u[e]-c[e])*s}return e.insertTuple(n,d)}}(e,t)}const vs=Et(hs,"vtkDataArray");var Ts={newInstance:vs,extend:hs,...gs,...ss};const ys={clippingPlanes:[]};var bs=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ys,n),Ht.obj(e,t),Ht.algo(e,t,1,0),t.clippingPlanes||(t.clippingPlanes=[]),function(e,t){t.classHierarchy.push("vtkAbstractMapper"),e.update=()=>{e.getInputData()},e.addClippingPlane=n=>!!n.isA("vtkPlane")&&!t.clippingPlanes.includes(n)&&(t.clippingPlanes.push(n),e.modified(),!0),e.getNumberOfClippingPlanes=()=>t.clippingPlanes.length,e.removeAllClippingPlanes=()=>0!==t.clippingPlanes.length&&(t.clippingPlanes.length=0,e.modified(),!0),e.removeClippingPlane=n=>{const r=t.clippingPlanes.indexOf(n);return-1!==r&&(t.clippingPlanes.splice(r,1),e.modified(),!0)},e.getClippingPlanes=()=>t.clippingPlanes,e.setClippingPlanes=t=>{if(t)if(Array.isArray(t)){const n=t.length;for(let r=0;r<n&&r<6;r++)e.addClippingPlane(t[r])}else e.addClippingPlane(t)},e.getClippingPlaneInDataCoords=(e,n,r)=>{const o=t.clippingPlanes,a=e;if(o){const e=o.length;if(n>=0&&n<e){const e=o[n],t=e.getNormal(),i=e.getOrigin(),s=t[0],l=t[1],c=t[2],u=-(s*i[0]+l*i[1]+c*i[2]);return r[0]=s*a[0]+l*a[4]+c*a[8]+u*a[12],r[1]=s*a[1]+l*a[5]+c*a[9]+u*a[13],r[2]=s*a[2]+l*a[6]+c*a[10]+u*a[14],void(r[3]=s*a[3]+l*a[7]+c*a[11]+u*a[15])}}Ht.vtkErrorMacro(`Clipping plane index ${n} is out of range.`)}}(e,t)},xs=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,(e=>({bounds:[...Fi.INIT_BOUNDS],center:[0,0,0],viewSpecificProperties:{},...e}))(n)),bs(e,t,n),Ht.setGet(e,t,["viewSpecificProperties"]),function(e,t){e.getBounds=()=>(Ht.vtkErrorMacro("vtkAbstractMapper3D.getBounds - NOT IMPLEMENTED"),Ra()),e.getCenter=()=>{const n=e.getBounds();return t.center=Fi.isValid(n)?Fi.getCenter(n):null,t.center?.slice()},e.getLength=()=>{const t=e.getBounds();return Fi.getDiagonalLength(t)}}(e,t)};const{vtkErrorMacro:Cs,vtkWarningMacro:Ss}=Ht,As={arrays:[],copyFieldFlags:[],doCopyAllOn:!0,doCopyAllOff:!1};function Is(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,As,n),Ht.obj(e,t),function(e,t){t.classHierarchy.push("vtkFieldData");const n=e.getState;t.arrays&&(t.arrays=t.arrays.map((e=>({data:We(e.data)})))),e.initialize=()=>{e.initializeFields(),e.copyAllOn(),e.clearFieldFlags()},e.initializeFields=()=>{t.arrays=[],t.copyFieldFlags={},e.modified()},e.copyStructure=n=>{e.initializeFields(),t.copyFieldFlags=n.getCopyFieldFlags().map((e=>e)),t.arrays=n.arrays().map((e=>({array:e})))},e.getNumberOfArrays=()=>t.arrays.length,e.getNumberOfActiveArrays=()=>t.arrays.length,e.addArray=n=>{const r=n.getName(),{array:o,index:a}=e.getArrayWithIndex(r);return null!=o?(t.arrays[a]={data:n},a):(t.arrays=[].concat(t.arrays,{data:n}),t.arrays.length-1)},e.removeAllArrays=()=>{t.arrays=[]},e.removeArray=n=>{const r=t.arrays.findIndex((e=>e.data.getName()===n));return e.removeArrayByIndex(r)},e.removeArrayByIndex=e=>-1!==e&&e<t.arrays.length&&(t.arrays.splice(e,1),!0),e.getArrays=()=>t.arrays.map((e=>e.data)),e.getArray=t=>"number"==typeof t?e.getArrayByIndex(t):e.getArrayByName(t),e.getArrayByName=e=>t.arrays.reduce(((t,n,r)=>n.data.getName()===e?n.data:t),null),e.getArrayWithIndex=e=>{const n=t.arrays.findIndex((t=>t.data.getName()===e));return{array:-1!==n?t.arrays[n].data:null,index:n}},e.getArrayByIndex=e=>e>=0&&e<t.arrays.length?t.arrays[e].data:null,e.hasArray=t=>e.getArrayWithIndex(t).index>=0,e.getArrayName=e=>{const n=t.arrays[e];return n?n.data.getName():""},e.getCopyFieldFlags=()=>t.copyFieldFlags,e.getFlag=e=>t.copyFieldFlags[e],e.passData=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;n.getArrays().forEach((a=>{const i=e.getFlag(a.getName());if(!1!==i&&(!t.doCopyAllOff||!0===i)&&a){let t=e.getArrayByName(a.getName());if(t)if(a.getNumberOfComponents()===t.getNumberOfComponents())if(r>-1&&r<a.getNumberOfTuples()){const e=o>-1?o:r;t.insertTuple(e,a.getTuple(r))}else t.insertTuples(0,a.getTuples());else Cs("Unhandled case in passData");else if(r<0||r>a.getNumberOfTuples())e.addArray(a),n.getAttributes(a).forEach((t=>{e.setAttribute(a,t)}));else{const i=a.getNumberOfComponents();let s=a.getNumberOfValues();const l=o>-1?o:r;s<=l*i&&(s=(l+1)*i),t=Ts.newInstance({name:a.getName(),dataType:a.getDataType(),numberOfComponents:i,values:Ht.newTypedArray(a.getDataType(),s),size:0}),t.insertTuple(l,a.getTuple(r)),e.addArray(t),n.getAttributes(a).forEach((n=>{e.setAttribute(t,n)}))}}}))},e.interpolateData=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:-1,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5;n.getArrays().forEach((s=>{const l=e.getFlag(s.getName());if(!1!==l&&(!t.doCopyAllOff||!0===l)&&s){let t=e.getArrayByName(s.getName());if(t)if(s.getNumberOfComponents()===t.getNumberOfComponents())if(r>-1&&r<s.getNumberOfTuples()){const e=a>-1?a:r;t.interpolateTuple(e,s,r,s,o,i),Ss("Unexpected case in interpolateData")}else t.insertTuples(s.getTuples());else Cs("Unhandled case in interpolateData");else if(r<0||o<0||r>s.getNumberOfTuples())e.addArray(s),n.getAttributes(s).forEach((t=>{e.setAttribute(s,t)}));else{const l=s.getNumberOfComponents();let c=s.getNumberOfValues();const u=a>-1?a:r;c<=u*l&&(c=(u+1)*l),t=Ts.newInstance({name:s.getName(),dataType:s.getDataType(),numberOfComponents:l,values:Ht.newTypedArray(s.getDataType(),c),size:0}),t.interpolateTuple(u,s,r,s,o,i),e.addArray(t),n.getAttributes(s).forEach((n=>{e.setAttribute(t,n)}))}}}))},e.copyFieldOn=e=>{t.copyFieldFlags[e]=!0},e.copyFieldOff=e=>{t.copyFieldFlags[e]=!1},e.copyAllOn=()=>{t.doCopyAllOn&&!t.doCopyAllOff||(t.doCopyAllOn=!0,t.doCopyAllOff=!1,e.modified())},e.copyAllOff=()=>{!t.doCopyAllOn&&t.doCopyAllOff||(t.doCopyAllOn=!1,t.doCopyAllOff=!0,e.modified())},e.clearFieldFlags=()=>{t.copyFieldFlags={}},e.deepCopy=e=>{t.arrays=e.getArrays().map((e=>{const t=e.newClone();return t.deepCopy(e),{data:t}}))},e.copyFlags=e=>e.getCopyFieldFlags().map((e=>e)),e.reset=()=>t.arrays.forEach((e=>e.data.reset())),e.getMTime=()=>t.arrays.reduce(((e,t)=>t.data.getMTime()>e?t.data.getMTime():e),t.mtime),e.getNumberOfComponents=()=>t.arrays.reduce(((e,t)=>e+t.data.getNumberOfComponents()),0),e.getNumberOfTuples=()=>t.arrays.length>0?t.arrays[0].getNumberOfTuples():0,e.getState=()=>{const e=n();return e&&(e.arrays=t.arrays.map((e=>({data:e.data.getState()})))),e}}(e,t)}var ws={newInstance:Ht.newInstance(Is,"vtkFieldData"),extend:Is};const Os={DEFAULT:0,SINGLE:1,DOUBLE:2};var Ps={AttributeCopyOperations:{COPYTUPLE:0,INTERPOLATE:1,PASSDATA:2,ALLCOPY:3},AttributeLimitTypes:{MAX:0,EXACT:1,NOLIMIT:2},AttributeTypes:{SCALARS:0,VECTORS:1,NORMALS:2,TCOORDS:3,TENSORS:4,GLOBALIDS:5,PEDIGREEIDS:6,EDGEFLAG:7,NUM_ATTRIBUTES:8},CellGhostTypes:{DUPLICATECELL:1,HIGHCONNECTIVITYCELL:2,LOWCONNECTIVITYCELL:4,REFINEDCELL:8,EXTERIORCELL:16,HIDDENCELL:32},DesiredOutputPrecision:Os,PointGhostTypes:{DUPLICATEPOINT:1,HIDDENPOINT:2},ghostArrayName:"vtkGhostType"};const{AttributeTypes:Rs,AttributeCopyOperations:Ms}=Ps,{vtkWarningMacro:Es}=Ht,Vs={activeScalars:-1,activeVectors:-1,activeTensors:-1,activeNormals:-1,activeTCoords:-1,activeGlobalIds:-1,activePedigreeIds:-1};function Ds(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Vs,n),ws.extend(e,t,n),Ht.setGet(e,t,["activeScalars","activeNormals","activeTCoords","activeVectors","activeTensors","activeGlobalIds","activePedigreeIds"]),t.arrays||(t.arrays={}),function(e,t){const n=["Scalars","Vectors","Normals","TCoords","Tensors","GlobalIds","PedigreeIds"];function r(e){let t=n.find((t=>Rs[t.toUpperCase()]===e||"number"!=typeof e&&t.toLowerCase()===e.toLowerCase()));return void 0===t&&(t=null),t}t.classHierarchy.push("vtkDataSetAttributes");const o={...e};e.checkNumberOfComponents=e=>!0,e.setAttribute=(n,o)=>{const a=r(o);if(n&&"PEDIGREEIDS"===a.toUpperCase()&&!n.isA("vtkDataArray"))return Es(`Cannot set attribute ${a}. The attribute must be a vtkDataArray.`),-1;if(n&&!e.checkNumberOfComponents(n,a))return Es(`Cannot set attribute ${a}. Incorrect number of components.`),-1;let i=t[`active${a}`];if(i>=0&&i<t.arrays.length){if(t.arrays[i]===n)return i;e.removeArrayByIndex(i)}return n?(i=e.addArray(n),t[`active${a}`]=i):t[`active${a}`]=-1,e.modified(),t[`active${a}`]},e.getAttributes=t=>n.filter((n=>e[`get${n}`]()===t)),e.setActiveAttributeByName=(t,n)=>e.setActiveAttributeByIndex(e.getArrayWithIndex(t).index,n),e.setActiveAttributeByIndex=(n,o)=>{const a=r(o);if(n>=0&&n<t.arrays.length){if("PEDIGREEIDS"!==a.toUpperCase()){const t=e.getArrayByIndex(n);if(!t.isA("vtkDataArray"))return Es(`Cannot set attribute ${a}. Only vtkDataArray subclasses can be set as active attributes.`),-1;if(!e.checkNumberOfComponents(t,a))return Es(`Cannot set attribute ${a}. Incorrect number of components.`),-1}return t[`active${a}`]=n,e.modified(),n}return-1===n&&(t[`active${a}`]=n,e.modified()),-1},e.getActiveAttribute=t=>{const n=r(t);return e[`get${n}`]()},e.removeAllArrays=()=>{n.forEach((e=>{t[`active${e}`]=-1})),o.removeAllArrays()},e.removeArrayByIndex=e=>(-1!==e&&n.forEach((n=>{e===t[`active${n}`]?t[`active${n}`]=-1:e<t[`active${n}`]&&(t[`active${n}`]-=1)})),o.removeArrayByIndex(e)),n.forEach((n=>{const r=`active${n}`;e[`get${n}`]=()=>e.getArrayByIndex(t[r]),e[`set${n}`]=t=>e.setAttribute(t,n),e[`setActive${n}`]=t=>e.setActiveAttributeByIndex(e.getArrayWithIndex(t).index,n),e[`copy${n}Off`]=()=>{const e=n.toUpperCase();t.copyAttributeFlags[Ms.PASSDATA][Rs[e]]=!1},e[`copy${n}On`]=()=>{const e=n.toUpperCase();t.copyAttributeFlags[Ms.PASSDATA][Rs[e]]=!0}})),e.initializeAttributeCopyFlags=()=>{t.copyAttributeFlags=[],Object.keys(Ms).filter((e=>"ALLCOPY"!==e)).forEach((e=>{t.copyAttributeFlags[Ms[e]]=Object.keys(Rs).filter((e=>"NUM_ATTRIBUTES"!==e)).reduce(((e,t)=>(e[Rs[t]]=!0,e)),[])})),t.copyAttributeFlags[Ms.COPYTUPLE][Rs.GLOBALIDS]=!1,t.copyAttributeFlags[Ms.INTERPOLATE][Rs.GLOBALIDS]=!1,t.copyAttributeFlags[Ms.COPYTUPLE][Rs.PEDIGREEIDS]=!1},e.initialize=Ht.chain(e.initialize,e.initializeAttributeCopyFlags),t.dataArrays&&Object.keys(t.dataArrays).length&&Object.keys(t.dataArrays).forEach((n=>{t.dataArrays[n].ref||"vtkDataArray"!==t.dataArrays[n].type||e.addArray(Ts.newInstance(t.dataArrays[n]))}));const a=e.shallowCopy;e.shallowCopy=(e,n)=>{a(e,n),t.arrays=e.getArrays().map((e=>{const t=e.newClone();return t.shallowCopy(e,n),{data:t}}))},e.initializeAttributeCopyFlags()}(e,t)}var Ls={newInstance:Ht.newInstance(Ds,"vtkDataSetAttributes"),extend:Ds,...Ps};const Bs=["pointData","cellData","fieldData"],Ns={};function Fs(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ns,n),Ht.obj(e,t),Ht.setGet(e,t,Bs),function(e,t){t.classHierarchy.push("vtkDataSet"),Bs.forEach((e=>{t[e]?t[e]=We(t[e]):t[e]=Ls.newInstance()}));const n=e.shallowCopy;e.shallowCopy=function(e){n(e,arguments.length>1&&void 0!==arguments[1]&&arguments[1]),Bs.forEach((n=>{t[n]=Ls.newInstance(),t[n].shallowCopy(e.getReferenceByName(n))}))}}(e,t)}var _s={newInstance:Ht.newInstance(Fs,"vtkDataSet"),extend:Fs,FieldDataTypes:{UNIFORM:0,DATA_OBJECT_FIELD:0,COORDINATE:1,POINT_DATA:1,POINT:2,POINT_FIELD_DATA:2,CELL:3,CELL_FIELD_DATA:3,VERTEX:4,VERTEX_FIELD_DATA:4,EDGE:5,EDGE_FIELD_DATA:5,ROW:6,ROW_DATA:6},FieldAssociations:{FIELD_ASSOCIATION_POINTS:0,FIELD_ASSOCIATION_CELLS:1,FIELD_ASSOCIATION_NONE:2,FIELD_ASSOCIATION_POINTS_THEN_CELLS:3,FIELD_ASSOCIATION_VERTICES:4,FIELD_ASSOCIATION_EDGES:5,FIELD_ASSOCIATION_ROWS:6,NUMBER_OF_ASSOCIATIONS:7}};const ks={UNCHANGED:0,SINGLE_POINT:1,X_LINE:2,Y_LINE:3,Z_LINE:4,XY_PLANE:5,YZ_PLANE:6,XZ_PLANE:7,XYZ_GRID:8,EMPTY:9};var Gs={StructuredType:ks};const{StructuredType:Us}=Gs;var zs={getDataDescriptionFromExtent:function(e){let t=0;for(let n=0;n<3;++n)e[2*n]<e[2*n+1]&&t++;return e[0]>e[1]||e[2]>e[3]||e[4]>e[5]?Us.EMPTY:3===t?Us.XYZ_GRID:2===t?e[0]===e[1]?Us.YZ_PLANE:e[2]===e[3]?Us.XZ_PLANE:Us.XY_PLANE:1===t?e[0]<e[1]?Us.X_LINE:e[2]<e[3]?Us.Y_LINE:Us.Z_LINE:Us.SINGLE_POINT},...Gs};const{vtkErrorMacro:Ws}=Ht,Hs={direction:null,indexToWorld:null,worldToIndex:null,spacing:[1,1,1],origin:[0,0,0],extent:[0,-1,0,-1,0,-1],dataDescription:ks.EMPTY};function js(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Hs,n),_s.extend(e,t,n),t.direction?Array.isArray(t.direction)&&(t.direction=new Float64Array(t.direction.slice(0,9))):t.direction=pe(new Float64Array(9)),t.indexToWorld=new Float64Array(16),t.worldToIndex=new Float64Array(16),Ht.get(e,t,["indexToWorld","worldToIndex"]),Ht.setGetArray(e,t,["origin","spacing"],3),Ht.setGetArray(e,t,["direction"],9),Ht.getArray(e,t,["extent"],6),function(e,t){t.classHierarchy.push("vtkImageData"),e.setExtent=function(){if(t.deleted)return Ws("instance deleted - cannot call any method"),!1;for(var n=arguments.length,r=new Array(n),o=0;o<n;o++)r[o]=arguments[o];const a=1===r.length?r[0]:r;if(6!==a.length)return!1;const i=t.extent.some(((e,t)=>e!==a[t]));return i&&(t.extent=a.slice(),t.dataDescription=zs.getDataDescriptionFromExtent(t.extent),e.modified()),i},e.setDimensions=function(){let n,r,o;if(t.deleted)Ws("instance deleted - cannot call any method");else{if(1===arguments.length){const e=arguments.length<=0?void 0:arguments[0];n=e[0],r=e[1],o=e[2]}else{if(3!==arguments.length)return void Ws("Bad dimension specification");n=arguments.length<=0?void 0:arguments[0],r=arguments.length<=1?void 0:arguments[1],o=arguments.length<=2?void 0:arguments[2]}e.setExtent(0,n-1,0,r-1,0,o-1)}},e.getDimensions=()=>[t.extent[1]-t.extent[0]+1,t.extent[3]-t.extent[2]+1,t.extent[5]-t.extent[4]+1],e.getNumberOfCells=()=>{const t=e.getDimensions();let n=1;for(let e=0;e<3;e++){if(0===t[e])return 0;t[e]>1&&(n*=t[e]-1)}return n},e.getNumberOfPoints=()=>{const t=e.getDimensions();return t[0]*t[1]*t[2]},e.getPoint=n=>{const r=e.getDimensions();if(0===r[0]||0===r[1]||0===r[2])return Ws("Requesting a point from an empty image."),null;const o=new Float64Array(3);switch(t.dataDescription){case ks.EMPTY:return null;case ks.SINGLE_POINT:break;case ks.X_LINE:o[0]=n;break;case ks.Y_LINE:o[1]=n;break;case ks.Z_LINE:o[2]=n;break;case ks.XY_PLANE:o[0]=n%r[0],o[1]=n/r[0];break;case ks.YZ_PLANE:o[1]=n%r[1],o[2]=n/r[1];break;case ks.XZ_PLANE:o[0]=n%r[0],o[2]=n/r[0];break;case ks.XYZ_GRID:o[0]=n%r[0],o[1]=n/r[0]%r[1],o[2]=n/(r[0]*r[1]);break;default:Ws("Invalid dataDescription")}const a=[0,0,0];return e.indexToWorld(o,a),a},e.getBounds=()=>e.extentToBounds(e.getSpatialExtent()),e.extentToBounds=e=>Fi.transformBounds(e,t.indexToWorld),e.getSpatialExtent=()=>Fi.inflate([...t.extent],.5),e.computeTransforms=()=>{w(t.indexToWorld,t.origin),t.indexToWorld[0]=t.direction[0],t.indexToWorld[1]=t.direction[1],t.indexToWorld[2]=t.direction[2],t.indexToWorld[4]=t.direction[3],t.indexToWorld[5]=t.direction[4],t.indexToWorld[6]=t.direction[5],t.indexToWorld[8]=t.direction[6],t.indexToWorld[9]=t.direction[7],t.indexToWorld[10]=t.direction[8],x(t.indexToWorld,t.indexToWorld,t.spacing),h(t.worldToIndex,t.indexToWorld)},e.indexToWorld=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return wn(n,e,t.indexToWorld),n},e.indexToWorldVec3=e.indexToWorld,e.worldToIndex=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return wn(n,e,t.worldToIndex),n},e.worldToIndexVec3=e.worldToIndex,e.indexToWorldBounds=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Fi.transformBounds(e,t.indexToWorld,n)},e.worldToIndexBounds=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Fi.transformBounds(e,t.worldToIndex,n)},e.onModified(e.computeTransforms),e.computeTransforms(),e.getCenter=()=>Fi.getCenter(e.getBounds()),e.computeHistogram=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const r=[0,0,0,0,0,0];e.worldToIndexBounds(t,r);const o=[0,0,0],a=[0,0,0];Fi.computeCornerPoints(r,o,a),ta(o,o),ta(a,a);const i=e.getDimensions();Ca(o,[0,0,0],[i[0]-1,i[1]-1,i[2]-1],o),Ca(a,[0,0,0],[i[0]-1,i[1]-1,i[2]-1],a);const s=i[0],l=i[0]*i[1],c=e.getPointData().getScalars().getData();let u=-1/0,d=1/0,p=0,f=0,g=0;for(let e=o[2];e<=a[2];e++)for(let t=o[1];t<=a[1];t++){let i=o[0]+t*s+e*l;for(let s=o[0];s<=a[0];s++){if(!n||n([s,t,e],r)){const e=c[i];e>u&&(u=e),e<d&&(d=e),p+=e*e,f+=e,g+=1}++i}}const m=g>0?f/g:0,h=g?Math.abs(p/g-m*m):0;return{minimum:d,maximum:u,average:m,variance:h,sigma:Math.sqrt(h),count:g}},e.computeIncrements=function(e){const t=[];let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;for(let r=0;r<3;++r)t[r]=n,n*=e[2*r+1]-e[2*r]+1;return t},e.computeOffsetIndex=t=>{let[n,r,o]=t;const a=e.getExtent(),i=e.getPointData().getScalars().getNumberOfComponents(),s=e.computeIncrements(a,i);return Math.floor((Math.round(n)-a[0])*s[0]+(Math.round(r)-a[2])*s[1]+(Math.round(o)-a[4])*s[2])},e.getOffsetIndexFromWorld=t=>{const n=e.getExtent(),r=e.worldToIndex(t);for(let e=0;e<3;++e)if(r[e]<n[2*e]||r[e]>n[2*e+1])return Ws(`GetScalarPointer: Pixel ${r} is not in memory. Current extent = ${n}`),NaN;return e.computeOffsetIndex(r)},e.getScalarValueFromWorld=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const r=e.getPointData().getScalars().getNumberOfComponents();if(n<0||n>=r)return Ws(`GetScalarPointer: Scalar Component ${n} is not within bounds. Current Scalar numberOfComponents: ${r}`),NaN;const o=e.getOffsetIndexFromWorld(t);return Number.isNaN(o)?o:e.getPointData().getScalars().getComponent(o,n)}}(e,t)}var Ks={newInstance:Ht.newInstance(js,"vtkImageData"),extend:js};const $s={LUMINANCE:1,LUMINANCE_ALPHA:2,RGB:3,RGBA:4};var qs={VectorMode:{MAGNITUDE:0,COMPONENT:1,RGBCOLORS:2},ScalarMappingTarget:$s,Scale:{LINEAR:0,LOG10:1}},Xs={ColorMode:{DEFAULT:0,MAP_SCALARS:1,DIRECT_SCALARS:2},GetArray:{BY_ID:0,BY_NAME:1},ScalarMode:{DEFAULT:0,USE_POINT_DATA:1,USE_CELL_DATA:2,USE_POINT_FIELD_DATA:3,USE_CELL_FIELD_DATA:4,USE_FIELD_DATA:5}};const{ScalarMappingTarget:Ys,Scale:Zs,VectorMode:Qs}=qs,{VtkDataTypes:Js}=Ts,{ColorMode:el}=Xs,{vtkErrorMacro:tl}=Ht;function nl(e){return e}function rl(e){return Math.floor(255*e+.5)}const ol={alpha:1,vectorComponent:0,vectorSize:-1,vectorMode:Qs.COMPONENT,mappingRange:null,annotationArray:null,annotatedValueMap:null,indexedLookup:!1,scale:Zs.LINEAR};function al(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ol,n),Ht.obj(e,t),t.mappingRange=[0,255],t.annotationArray=[],t.annotatedValueMap=[],Ht.setGet(e,t,["vectorSize","vectorComponent","vectorMode","alpha","indexedLookup"]),Ht.setArray(e,t,["mappingRange"],2),Ht.getArray(e,t,["mappingRange"]),function(e,t){t.classHierarchy.push("vtkScalarsToColors"),e.setVectorModeToMagnitude=()=>e.setVectorMode(Qs.MAGNITUDE),e.setVectorModeToComponent=()=>e.setVectorMode(Qs.COMPONENT),e.setVectorModeToRGBColors=()=>e.setVectorMode(Qs.RGBCOLORS),e.build=()=>{},e.isOpaque=()=>!0,e.setAnnotations=(n,r)=>{if(!(n&&!r||!n&&r))if(n&&r&&n.length!==r.length)tl("Values and annotations do not have the same number of tuples so ignoring");else{if(t.annotationArray=[],r&&n){const e=r.length;for(let o=0;o<e;o++)t.annotationArray.push({value:n[o],annotation:String(r[o])})}e.updateAnnotatedValueMap(),e.modified()}},e.setAnnotation=(n,r)=>{let o=e.checkForAnnotatedValue(n),a=!1;return o>=0?t.annotationArray[o].annotation!==r&&(t.annotationArray[o].annotation=r,a=!0):(t.annotationArray.push({value:n,annotation:r}),o=t.annotationArray.length-1,a=!0),a&&(e.updateAnnotatedValueMap(),e.modified()),o},e.getNumberOfAnnotatedValues=()=>t.annotationArray.length,e.getAnnotatedValue=e=>e<0||e>=t.annotationArray.length?null:t.annotationArray[e].value,e.getAnnotation=e=>void 0===t.annotationArray[e]?null:t.annotationArray[e].annotation,e.getAnnotatedValueIndex=n=>t.annotationArray.length?e.checkForAnnotatedValue(n):-1,e.removeAnnotation=n=>{const r=e.checkForAnnotatedValue(n),o=r>=0;return o&&(t.annotationArray.splice(r,1),e.updateAnnotatedValueMap(),e.modified()),o},e.resetAnnotations=()=>{t.annotationArray=[],t.annotatedValueMap=[],e.modified()},e.getAnnotationColor=(n,r)=>{if(t.indexedLookup){const t=e.getAnnotatedValueIndex(n);e.getIndexedColor(t,r)}else e.getColor(parseFloat(n),r),r[3]=1},e.checkForAnnotatedValue=t=>e.getAnnotatedValueIndexInternal(t),e.getAnnotatedValueIndexInternal=e=>{if(void 0!==t.annotatedValueMap[e]){const n=t.annotationArray.length;return t.annotatedValueMap[e]%n}return-1},e.getIndexedColor=(e,t)=>{t[0]=0,t[1]=0,t[2]=0,t[3]=0},e.updateAnnotatedValueMap=()=>{t.annotatedValueMap=[];const e=t.annotationArray.length;for(let n=0;n<e;n++)t.annotatedValueMap[t.annotationArray[n].value]=n},e.mapScalars=(t,n,r)=>{const o=t.getNumberOfComponents();let a=null;if(n===el.DEFAULT&&(t.getDataType()===Js.UNSIGNED_CHAR||t.getDataType()===Js.UNSIGNED_CHAR_CLAMPED)||n===el.DIRECT_SCALARS&&t)a=e.convertToRGBA(t,o,t.getNumberOfTuples());else{const n={type:"vtkDataArray",name:"temp",numberOfComponents:4,dataType:Js.UNSIGNED_CHAR},i=Ht.newTypedArray(n.dataType,4*t.getNumberOfTuples());n.values=i,n.size=i.length,a=Ts.newInstance(n);let s=r;s<0&&o>1?e.mapVectorsThroughTable(t,a,Ys.RGBA,-1,-1):(s<0&&(s=0),s>=o&&(s=o-1),e.mapScalarsThroughTable(t,a,Ys.RGBA,s))}return a},e.mapVectorsToMagnitude=(e,t,n)=>{const r=e.getNumberOfTuples(),o=e.getNumberOfComponents(),a=t.getData(),i=e.getData();for(let e=0;e<r;e++){let t=0;for(let r=0;r<n;r++)t+=i[e*o+r]*i[e*o+r];a[e]=Math.sqrt(t)}},e.mapVectorsThroughTable=(t,n,r,o,a)=>{let i=e.getVectorMode(),s=a,l=o;const c=t.getNumberOfComponents();i===Qs.COMPONENT?(-1===l&&(l=e.getVectorComponent()),l<0&&(l=0),l>=c&&(l=c-1)):(-1===s&&(s=e.getVectorSize()),s<=0?(l=0,s=c):(l<0&&(l=0),l>=c&&(l=c-1),l+s>c&&(s=c-l)),i!==Qs.MAGNITUDE||1!==c&&1!==s||(i=Qs.COMPONENT));let u=0;switch(l>0&&(u=l),i){case Qs.COMPONENT:e.mapScalarsThroughTable(t,n,r,u);break;case Qs.RGBCOLORS:break;case Qs.MAGNITUDE:default:{const o=Ts.newInstance({numberOfComponents:1,values:new Float32Array(t.getNumberOfTuples())});e.mapVectorsToMagnitude(t,o,s),e.mapScalarsThroughTable(o,n,r,0);break}}},e.luminanceToRGBA=(e,t,n,r)=>{const o=r(n),a=t.getData(),i=e.getData(),s=a.length;let l=0;for(let e=0;e<s;e+=1){const t=r(a[e]);i[4*l]=t,i[4*l+1]=t,i[4*l+2]=t,i[4*l+3]=o,l++}},e.luminanceAlphaToRGBA=(e,t,n,r)=>{const o=t.getData(),a=e.getData(),i=o.length;let s=0;for(let e=0;e<i;e+=2){const t=r(o[e]);a[s]=t,a[s+1]=t,a[s+2]=t,a[s+3]=r(o[e+1])*n,s+=4}},e.rGBToRGBA=(e,t,n,r)=>{const o=rl(n),a=t.getData(),i=e.getData(),s=a.length;let l=0;for(let e=0;e<s;e+=3)i[4*l]=r(a[e]),i[4*l+1]=r(a[e+1]),i[4*l+2]=r(a[e+2]),i[4*l+3]=o,l++},e.rGBAToRGBA=(e,t,n,r)=>{const o=t.getData(),a=e.getData(),i=o.length;let s=0;for(let e=0;e<i;e+=4)a[4*s]=r(o[e]),a[4*s+1]=r(o[e+1]),a[4*s+2]=r(o[e+2]),a[4*s+3]=r(o[e+3])*n,s++},e.convertToRGBA=(n,r,o)=>{let{alpha:a}=t;if(4===r&&a>=1&&n.getDataType()===Js.UNSIGNED_CHAR)return n;const i=Ts.newInstance({numberOfComponents:4,empty:!0,size:4*o,dataType:Js.UNSIGNED_CHAR});if(o<=0)return i;a=a>0?a:0,a=a<1?a:1;let s=nl;switch(n.getDataType()!==Js.FLOAT&&n.getDataType()!==Js.DOUBLE||(s=rl),r){case 1:e.luminanceToRGBA(i,n,a,s);break;case 2:e.luminanceAlphaToRGBA(i,n,s);break;case 3:e.rGBToRGBA(i,n,a,s);break;case 4:e.rGBAToRGBA(i,n,a,s);break;default:return tl("Cannot convert colors"),null}return i},e.usingLogScale=()=>!1,e.getNumberOfAvailableColors=()=>16777216,e.setRange=(t,n)=>e.setMappingRange(t,n),e.getRange=()=>e.getMappingRange(),e.areScalarsOpaque=(n,r,o)=>{if(!n)return e.isOpaque();const a=n.getNumberOfComponents();return(r!==el.DEFAULT||n.getDataType()!==Js.UNSIGNED_CHAR)&&r!==el.DIRECT_SCALARS||(3===a||1===a?t.alpha>=1:255===n.getRange(a-1)[0])}}(e,t)}var il={newInstance:Ht.newInstance(al,"vtkScalarsToColors"),extend:al,...qs};const{vtkErrorMacro:sl}=Ht,ll={numberOfColors:256,hueRange:[0,.66667],saturationRange:[1,1],valueRange:[1,1],alphaRange:[1,1],nanColor:[.5,0,0,1],belowRangeColor:[0,0,0,1],aboveRangeColor:[1,1,1,1],useAboveRangeColor:!1,useBelowRangeColor:!1,alpha:1};function cl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ll,n),il.extend(e,t,n),t.table||(t.table=[]),t.buildTime={},Ht.obj(t.buildTime),t.opaqueFlagBuildTime={},Ht.obj(t.opaqueFlagBuildTime,{mtime:0}),t.insertTime={},Ht.obj(t.insertTime,{mtime:0}),Ht.get(e,t,["buildTime"]),Ht.setGet(e,t,["numberOfColors","useAboveRangeColor","useBelowRangeColor"]),Ht.setArray(e,t,["alphaRange","hueRange","saturationRange","valueRange"],2),Ht.setArray(e,t,["nanColor","belowRangeColor","aboveRangeColor"],4),Ht.getArray(e,t,["hueRange","saturationRange","valueRange","alphaRange","nanColor","belowRangeColor","aboveRangeColor"]),function(e,t){t.classHierarchy.push("vtkLookupTable"),e.isOpaque=()=>{if(t.opaqueFlagBuildTime.getMTime()<e.getMTime()){let e=!0;t.nanColor[3]<1&&(e=0),t.useBelowRangeColor&&t.belowRangeColor[3]<1&&(e=0),t.useAboveRangeColor&&t.aboveRangeColor[3]<1&&(e=0);for(let n=3;n<t.table.length&&e;n+=4)t.table[n]<255&&(e=!1);t.opaqueFlag=e,t.opaqueFlagBuildTime.modified()}return t.opaqueFlag},e.usingLogScale=()=>!1,e.getNumberOfAvailableColors=()=>t.table.length/4-3,e.linearIndexLookup=(e,t)=>{let n=0;const r=Number(e);return r<t.range[0]?n=t.maxIndex+0+1.5:r>t.range[1]?n=t.maxIndex+1+1.5:(n=(r+t.shift)*t.scale,n=n<t.maxIndex?n:t.maxIndex),Math.floor(n)},e.linearLookup=(t,n,r)=>{let o=0;o=Pa(t)?Math.floor(r.maxIndex+1.5+2):e.linearIndexLookup(t,r);const a=4*o;return n.slice(a,a+4)},e.indexedLookupFunction=(n,r,o)=>{let a=e.getAnnotatedValueIndexInternal(n);-1===a&&(a=t.numberOfColors+2);const i=4*a;return[r[i],r[i+1],r[i+2],r[i+3]]},e.lookupShiftAndScale=(e,t)=>{t.shift=-e[0],t.scale=Number.MAX_VALUE,e[1]>e[0]&&(t.scale=(t.maxIndex+1)/(e[1]-e[0]))},e.mapScalarsThroughTable=(n,r,o,a)=>{let i=e.linearLookup;t.indexedLookup&&(i=e.indexedLookupFunction);const s=e.getMappingRange(),l={maxIndex:e.getNumberOfColors()-1,range:s,shift:0,scale:0};e.lookupShiftAndScale(s,l);const c=e.getAlpha(),u=n.getNumberOfTuples(),d=n.getNumberOfComponents(),p=r.getData(),f=n.getData();if(c>=1){if(o===$s.RGBA)for(let e=0;e<u;e++){const n=i(f[e*d+a],t.table,l);p[4*e]=n[0],p[4*e+1]=n[1],p[4*e+2]=n[2],p[4*e+3]=n[3]}}else if(o===$s.RGBA)for(let e=0;e<u;e++){const n=i(f[e*d+a],t.table,l);p[4*e]=n[0],p[4*e+1]=n[1],p[4*e+2]=n[2],p[4*e+3]=Math.floor(n[3]*c+.5)}},e.forceBuild=()=>{let n=0,r=0,o=0,a=0;const i=t.numberOfColors-1;i&&(n=(t.hueRange[1]-t.hueRange[0])/i,r=(t.saturationRange[1]-t.saturationRange[0])/i,o=(t.valueRange[1]-t.valueRange[0])/i,a=(t.alphaRange[1]-t.alphaRange[0])/i),t.table.length=4*i+16;const s=[],l=[];for(let e=0;e<=i;e++)s[0]=t.hueRange[0]+e*n,s[1]=t.saturationRange[0]+e*r,s[2]=t.valueRange[0]+e*o,pa(s,l),l[3]=t.alphaRange[0]+e*a,t.table[4*e]=255*l[0]+.5,t.table[4*e+1]=255*l[1]+.5,t.table[4*e+2]=255*l[2]+.5,t.table[4*e+3]=255*l[3]+.5;e.buildSpecialColors(),t.buildTime.modified()},e.setTable=n=>{if(Array.isArray(n)){const r=n[0].length;t.numberOfColors=n.length;const o=4-r;let a=0;for(let e=0;e<t.numberOfColors;e++)t.table[4*e]=255,t.table[4*e+1]=255,t.table[4*e+2]=255,t.table[4*e+3]=255;for(let e=0;e<n.length;e++){const i=n[e];for(let e=0;e<r;e++)t.table[a++]=i[e];a+=o}return e.buildSpecialColors(),t.insertTime.modified(),e.modified(),!0}if(4!==n.getNumberOfComponents())return sl("Expected 4 components for RGBA colors"),!1;if(n.getDataType()!==is.UNSIGNED_CHAR)return sl("Expected unsigned char values for RGBA colors"),!1;t.numberOfColors=n.getNumberOfTuples();const r=n.getData();t.table.length=r.length;for(let e=0;e<r.length;e++)t.table[e]=r[e];return e.buildSpecialColors(),t.insertTime.modified(),e.modified(),!0},e.buildSpecialColors=()=>{const{numberOfColors:e}=t,n=t.table;let r=4*(e+0);t.useBelowRangeColor||0===e?(n[r]=255*t.belowRangeColor[0]+.5,n[r+1]=255*t.belowRangeColor[1]+.5,n[r+2]=255*t.belowRangeColor[2]+.5,n[r+3]=255*t.belowRangeColor[3]+.5):(n[r]=n[0],n[r+1]=n[1],n[r+2]=n[2],n[r+3]=n[3]),r=4*(e+1),t.useAboveRangeColor||0===e?(n[r]=255*t.aboveRangeColor[0]+.5,n[r+1]=255*t.aboveRangeColor[1]+.5,n[r+2]=255*t.aboveRangeColor[2]+.5,n[r+3]=255*t.aboveRangeColor[3]+.5):(n[r]=n[4*(e-1)+0],n[r+1]=n[4*(e-1)+1],n[r+2]=n[4*(e-1)+2],n[r+3]=n[4*(e-1)+3]),r=4*(e+2),n[r]=255*t.nanColor[0]+.5,n[r+1]=255*t.nanColor[1]+.5,n[r+2]=255*t.nanColor[2]+.5,n[r+3]=255*t.nanColor[3]+.5},e.build=()=>{(t.table.length<1||e.getMTime()>t.buildTime.getMTime()&&t.insertTime.getMTime()<=t.buildTime.getMTime())&&e.forceBuild()},t.table.length>0&&(e.buildSpecialColors(),t.insertTime.modified())}(e,t)}var ul={newInstance:Ht.newInstance(cl,"vtkLookupTable"),extend:cl};const dl={Off:0,PolygonOffset:1};let pl=dl.PolygonOffset,fl=dl.Off;const gl=["VTK_RESOLVE_OFF","VTK_RESOLVE_POLYGON_OFFSET"];function ml(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const t=fl===e;return fl=e,t}var hl={Resolve:dl,getResolveCoincidentTopologyAsString:function(){return gl[fl]},getResolveCoincidentTopologyPolygonOffsetFaces:function(){return pl},getResolveCoincidentTopology:function(){return fl},setResolveCoincidentTopology:ml,setResolveCoincidentTopologyPolygonOffsetFaces:function(e){const t=pl===e;return pl=e,t},setResolveCoincidentTopologyToDefault:function(){return ml(dl.Off)},setResolveCoincidentTopologyToOff:function(){return ml(dl.Off)},setResolveCoincidentTopologyToPolygonOffset:function(){return ml(dl.PolygonOffset)}};function vl(e,t,n){n.forEach((n=>{e[`get${n.method}`]=()=>t[n.key],e[`set${n.method}`]=Ht.objectSetterMap.object(e,t,{name:n.key,params:["factor","offset"]})}))}const Tl=["Polygon","Line","Point"],yl={modified:()=>{}};vl(yl,{Polygon:{factor:2,offset:0},Line:{factor:1,offset:-1},Point:{factor:0,offset:-2}},Tl.map((e=>({key:e,method:`ResolveCoincidentTopology${e}OffsetParameters`}))));var bl={implementCoincidentTopologyMethods:function(e,t){void 0===t.resolveCoincidentTopology&&(t.resolveCoincidentTopology=!1),Ht.setGet(e,t,["resolveCoincidentTopology"]),t.topologyOffset={Polygon:{factor:0,offset:0},Line:{factor:0,offset:0},Point:{factor:0,offset:0}},Object.keys(hl).forEach((t=>{e[t]=hl[t]})),Object.keys(yl).filter((e=>"modified"!==e)).forEach((t=>{e[t]=yl[t]})),vl(e,t.topologyOffset,Tl.map((e=>({key:e,method:`RelativeCoincidentTopology${e}OffsetParameters`})))),e.getCoincidentTopologyPolygonOffsetParameters=()=>{const t=yl.getResolveCoincidentTopologyPolygonOffsetParameters(),n=e.getRelativeCoincidentTopologyPolygonOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}},e.getCoincidentTopologyLineOffsetParameters=()=>{const t=yl.getResolveCoincidentTopologyLineOffsetParameters(),n=e.getRelativeCoincidentTopologyLineOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}},e.getCoincidentTopologyPointOffsetParameter=()=>{const t=yl.getResolveCoincidentTopologyPointOffsetParameters(),n=e.getRelativeCoincidentTopologyPointOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}}},staticOffsetAPI:yl,otherStaticMethods:hl,CATEGORIES:Tl,Resolve:dl};const xl={MIN_KNOWN_PASS:0,ACTOR_PASS:0,COMPOSITE_INDEX_PASS:1,ID_LOW24:2,ID_HIGH24:3,MAX_KNOWN_PASS:3};var Cl={PassTypes:xl};const{FieldAssociations:Sl}=_s,{staticOffsetAPI:Al,otherStaticMethods:Il}=bl,{ColorMode:wl,ScalarMode:Ol,GetArray:Pl}=Xs,{VectorMode:Rl}=qs,{VtkDataTypes:Ml}=Ts;function El(e){return()=>Ht.vtkErrorMacro(`vtkMapper::${e} - NOT IMPLEMENTED`)}function Vl(e,t){const n=e[1]%2==0?1:-1;if(e[0]+=n,e[0]>=t[0]||e[0]<0){const r=e[2]%2==0?1:-1;e[0]-=n,e[1]+=r,(e[1]>=t[1]||e[1]<0)&&(e[1]-=r,e[2]++)}}function Dl(e,t,n){const r=Math.floor(t),o=r%(2*n[0]);let a,i;o<n[0]?(e[0]=o,a=1,i=e[0]===n[0]-1):(e[0]=2*n[0]-1-o,a=-1,i=0===e[0]);const s=Math.floor(r/n[0]),l=s%(2*n[1]);let c,u;l<n[1]?(e[1]=l,c=1,u=e[1]===n[1]-1):(e[1]=2*n[1]-1-l,c=-1,u=0===e[1]),e[2]=Math.floor(s/n[1]);const d=t-r;i?u?e[2]+=d:e[1]+=c*d:e[0]+=a*d,e[0]=(e[0]+.5)/n[0],e[1]=(e[1]+.5)/n[1],e[2]=(e[2]+.5)/n[2]}const Ll=new WeakMap;const Bl={colorMapColors:null,areScalarsMappedFromCells:!1,static:!1,lookupTable:null,scalarVisibility:!0,scalarRange:[0,1],useLookupTableScalarRange:!1,colorMode:0,scalarMode:0,arrayAccessMode:1,renderTime:0,colorByArrayName:null,fieldDataTupleId:-1,populateSelectionSettings:!0,selectionWebGLIdsToVTKIds:null,interpolateScalarsBeforeMapping:!1,colorCoordinates:null,colorTextureMap:null,numberOfColorsInRange:0,forceCompileOnly:0,useInvertibleColors:!1,invertibleScalars:null,customShaderAttributes:[]};function Nl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Bl,n),xs(e,t,n),Ht.get(e,t,["areScalarsMappedFromCells","colorCoordinates","colorMapColors","colorTextureMap","numberOfColorsInRange","selectionWebGLIdsToVTKIds"]),Ht.setGet(e,t,["colorByArrayName","arrayAccessMode","colorMode","fieldDataTupleId","interpolateScalarsBeforeMapping","lookupTable","populateSelectionSettings","renderTime","scalarMode","scalarVisibility","static","useLookupTableScalarRange","customShaderAttributes"]),Ht.setGetArray(e,t,["scalarRange"],2),bl.implementCoincidentTopologyMethods(e,t),function(e,t){t.classHierarchy.push("vtkMapper"),e.getBounds=()=>{const n=e.getInputData();return n?(t.static||e.update(),t.bounds=n.getBounds()):t.bounds=Ra(),t.bounds},e.setForceCompileOnly=e=>{t.forceCompileOnly=e},e.setSelectionWebGLIdsToVTKIds=e=>{t.selectionWebGLIdsToVTKIds=e},e.createDefaultLookupTable=()=>{t.lookupTable=ul.newInstance()},e.getColorModeAsString=()=>Ht.enumToString(wl,t.colorMode),e.setColorModeToDefault=()=>e.setColorMode(0),e.setColorModeToMapScalars=()=>e.setColorMode(1),e.setColorModeToDirectScalars=()=>e.setColorMode(2),e.getScalarModeAsString=()=>Ht.enumToString(Ol,t.scalarMode),e.setScalarModeToDefault=()=>e.setScalarMode(0),e.setScalarModeToUsePointData=()=>e.setScalarMode(1),e.setScalarModeToUseCellData=()=>e.setScalarMode(2),e.setScalarModeToUsePointFieldData=()=>e.setScalarMode(3),e.setScalarModeToUseCellFieldData=()=>e.setScalarMode(4),e.setScalarModeToUseFieldData=()=>e.setScalarMode(5),e.getAbstractScalars=(e,n,r,o,a)=>{if(!e||!t.scalarVisibility)return{scalars:null,cellFlag:!1};let i=null,s=!1;if(n===Ol.DEFAULT)i=e.getPointData().getScalars(),i||(i=e.getCellData().getScalars(),s=!0);else if(n===Ol.USE_POINT_DATA)i=e.getPointData().getScalars();else if(n===Ol.USE_CELL_DATA)i=e.getCellData().getScalars(),s=!0;else if(n===Ol.USE_POINT_FIELD_DATA){const t=e.getPointData();i=r===Pl.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===Ol.USE_CELL_FIELD_DATA){const t=e.getCellData();s=!0,i=r===Pl.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===Ol.USE_FIELD_DATA){const t=e.getFieldData();i=r===Pl.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}return{scalars:i,cellFlag:s}},e.mapScalars=(n,r)=>{const{scalars:o,cellFlag:a}=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName);if(t.areScalarsMappedFromCells=a,!o)return t.colorCoordinates=null,t.colorTextureMap=null,void(t.colorMapColors=null);const i=`${e.getMTime()}${o.getMTime()}${r}`;if(t.colorBuildString!==i){if(t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]),e.canUseTextureMapForColoring(o,a))t.mapScalarsToTexture(o,a,r);else{t.colorCoordinates=null,t.colorTextureMap=null;const n=e.getLookupTable();n&&(n.build(),t.colorMapColors=n.mapScalars(o,t.colorMode,t.fieldDataTupleId))}t.colorBuildString=`${e.getMTime()}${o.getMTime()}${r}`}},t.mapScalarsToTexture=(n,r,o)=>{const a=t.lookupTable.getRange(),i=t.lookupTable.usingLogScale(),s=t.lookupTable.getAlpha(),l=i?[Math.log10(a[0]),Math.log10(a[1])]:a;if(t.colorMapColors=null,null==t.colorTextureMap||e.getMTime()>t.colorTextureMap.getMTime()||t.lookupTable.getMTime()>t.colorTextureMap.getMTime()||t.lookupTable.getAlpha()!==o){t.lookupTable.setAlpha(o),t.colorTextureMap=null,t.lookupTable.build();const e=t.lookupTable.getNumberOfAvailableColors(),n=2048,a=2,d=r?n**3-3:4094;t.numberOfColorsInRange=Math.min(Math.max(e,a),d);const p=t.numberOfColorsInRange+3,f=t.numberOfColorsInRange+2,g=r?[Math.min(Math.ceil(p/n**0),n),Math.min(Math.ceil(p/n**1),n),Math.min(Math.ceil(p/n**2),n)]:[f,2,1],m=g[0]*g[1]*g[2],h=new Float64Array(m);h.fill(NaN);const v=t.numberOfColorsInRange,T=v+2,y=[0,0,0],b=l[0],x=l[1]-l[0];for(let e=0;e<T;++e){const t=b+x*(e-1)/(v-1),n=i?10**t:t;h[(u=g,(c=y)[0]+u[0]*(c[1]+u[1]*c[2]))]=n,Vl(y,g)}const C=Ts.newInstance({numberOfComponents:1,values:h}),S=t.lookupTable.mapScalars(C,t.colorMode,0);t.colorTextureMap=Ks.newInstance(),t.colorTextureMap.setDimensions(g),t.colorTextureMap.getPointData().setScalars(S),t.lookupTable.setAlpha(s)}var c,u;const d=t.lookupTable.getVectorMode()===Rl.MAGNITUDE&&n.getNumberOfComponents()>1?-1:t.lookupTable.getVectorComponent();t.colorCoordinates=function(e,t,n,r,o,a,i){const s=new Array(arguments.length);for(let e=0;e<arguments.length;++e){const t=arguments[e];s[e]=t.getMTime?.()??t}const l=s.join("/"),c=Ll.get(e);if(c&&c.stringHash===l)return c.textureCoordinates;const u=(n[1]-n[0])/(o-1),[d,p]=[n[0]-u,n[1]+u],f=d-.5*u,g=1/(p-d+u),m=d,h=(o+1)/(p-d),v=e.getData(),T=e.getNumberOfTuples(),y=e.getNumberOfComponents(),b=t<0||t>=y,x=a[2]<=1?2:3,C=Ts.newInstance({numberOfComponents:x,values:new Float32Array(T*x)}),S=C.getData(),A=[0,0,0];Dl(A,o+2,a);let I=0,w=0;const O=[.5,.5,.5];for(let e=0;e<T;++e){let e;if(b){let t=0;for(let e=0;e<y;++e){const n=v[I+e];t+=n*n}e=Math.sqrt(t)}else e=v[I+t];if(r&&(e=Math.log10(e)),I+=y,Pa(e))O[0]=A[0],O[1]=A[1],O[2]=A[2];else if(i){let t=(e-m)*h;t<1?t=0:t>o&&(t=o+1),Dl(O,t,a)}else{O[1]=.49;const t=(e-f)*g;O[0]=t>1e3?1e3:t<-1e3?-1e3:t}for(let e=0;e<x;++e)S[w++]=O[e]}return Ll.set(e,{stringHash:l,textureCoordinates:C}),C}(n,d,l,i,t.numberOfColorsInRange,t.colorTextureMap.getDimensions(),r)},e.getIsOpaque=()=>{const n=e.getInputData(),r=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;if(!t.scalarVisibility||null==r)return!0;const o=e.getLookupTable();return!o||(o.build(),o.areScalarsOpaque(r,t.colorMode,-1))},e.canUseTextureMapForColoring=(e,n)=>!((!n||t.colorMode===wl.DIRECT_SCALARS)&&(!t.interpolateScalarsBeforeMapping||t.lookupTable&&t.lookupTable.getIndexedLookup()||!e||t.colorMode===wl.DEFAULT&&e.getDataType()===Ml.UNSIGNED_CHAR||t.colorMode===wl.DIRECT_SCALARS)),e.clearColorArrays=()=>{t.colorMapColors=null,t.colorCoordinates=null,t.colorTextureMap=null},e.getLookupTable=()=>(t.lookupTable||e.createDefaultLookupTable(),t.lookupTable),e.getMTime=()=>{let e=t.mtime;if(null!==t.lookupTable){const n=t.lookupTable.getMTime();e=n>e?n:e}return e},e.getPrimitiveCount=()=>{const t=e.getInputData();return{points:t.getPoints().getNumberOfValues()/3,verts:t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells(),lines:t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells(),triangles:t.getPolys().getNumberOfValues()-3*t.getPolys().getNumberOfCells()}},e.acquireInvertibleLookupTable=El("AcquireInvertibleLookupTable"),e.valueToColor=El("ValueToColor"),e.colorToValue=El("ColorToValue"),e.useInvertibleColorFor=El("UseInvertibleColorFor"),e.clearInvertibleColor=El("ClearInvertibleColor"),e.processSelectorPixelBuffers=(e,n)=>{if(!e||!t.selectionWebGLIdsToVTKIds||!t.populateSelectionSettings)return;const r=e.getRawPixelBuffer(xl.ID_LOW24),o=e.getRawPixelBuffer(xl.ID_HIGH24),a=e.getCurrentPass(),i=e.getFieldAssociation();let s=null;i===Sl.FIELD_ASSOCIATION_POINTS?s=t.selectionWebGLIdsToVTKIds.points:i===Sl.FIELD_ASSOCIATION_CELLS&&(s=t.selectionWebGLIdsToVTKIds.cells),s&&n.forEach((t=>{if(a===xl.ID_LOW24){let n=0;o&&(n+=o[t],n*=256),n+=r[t+2],n*=256,n+=r[t+1],n*=256,n+=r[t];const a=s[n],i=e.getPixelBuffer(xl.ID_LOW24);i[t]=255&a,i[t+1]=(65280&a)>>8,i[t+2]=(16711680&a)>>16}else if(a===xl.ID_HIGH24&&o){let n=0;n+=o[t],n*=256,n+=r[t+2],n*=256,n+=r[t+1],n*=256,n+=r[t];const a=s[n];e.getPixelBuffer(xl.ID_HIGH24)[t]=(4278190080&a)>>24}}))}}(e,t)}var Fl={newInstance:Ht.newInstance(Nl,"vtkMapper"),extend:Nl,...Al,...Il,...Xs};function _l(e){let t=0;return e.filter(((e,n)=>n===t&&(t+=e+1,!0)))}function kl(e){let t=0;for(let n=0;n<e.length;)n+=e[n]+1,t++;return t}const Gl={extractCellSizes:_l,getNumberOfCells:kl};function Ul(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Ts.extend(e,t,function(e){return{empty:!0,numberOfComponents:1,dataType:is.UNSIGNED_INT,...e}}(n)),function(e,t){t.classHierarchy.push("vtkCellArray");const n={...e};e.getNumberOfCells=n=>void 0===t.numberOfCells||n?(t.cellSizes?t.numberOfCells=t.cellSizes.length:t.numberOfCells=kl(e.getData()),t.numberOfCells):t.numberOfCells,e.getCellSizes=n=>void 0===t.cellSizes||n?(t.cellSizes=_l(e.getData()),t.cellSizes):t.cellSizes,e.resize=r=>{const o=e.getNumberOfTuples();n.resize(r);const a=e.getNumberOfTuples();a<o&&(0===a?(t.numberOfCells=0,t.cellSizes=[]):(t.numberOfCells=void 0,t.cellSizes=void 0))},e.setData=e=>{n.setData(e,1),t.numberOfCells=void 0,t.cellSizes=void 0},e.getCell=e=>{let n=e;const r=t.values[n++];return t.values.subarray(n,n+r)},e.insertNextCell=n=>{const r=e.getNumberOfCells();return e.insertNextTuples([n.length,...n]),++t.numberOfCells,null!=t.cellSizes&&t.cellSizes.push(n.length),r}}(e,t)}var zl={newInstance:Ht.newInstance(Ul,"vtkCellArray"),extend:Ul,...Gl};const{vtkErrorMacro:Wl}=Ht,Hl=[1,-1,1,-1,1,-1],jl={empty:!0,numberOfComponents:3,dataType:is.FLOAT,bounds:[1,-1,1,-1,1,-1]};function Kl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,jl,n),Ts.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkPoints"),e.getNumberOfPoints=e.getNumberOfTuples,e.setNumberOfPoints=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;e.getNumberOfPoints()!==n&&(t.size=n*r,t.values=Ht.newTypedArray(t.dataType,t.size),e.setNumberOfComponents(r),e.modified())},e.setPoint=function(t){for(var n=arguments.length,r=new Array(n>1?n-1:0),o=1;o<n;o++)r[o-1]=arguments[o];e.setTuple(t,r)},e.getPoint=e.getTuple,e.findPoint=e.findTuple,e.insertNextPoint=(t,n,r)=>e.insertNextTuple([t,n,r]),e.getBounds=()=>{if(3===e.getNumberOfComponents()){const n=e.getRange(0);t.bounds[0]=n[0],t.bounds[1]=n[1];const r=e.getRange(1);t.bounds[2]=r[0],t.bounds[3]=r[1];const o=e.getRange(2);return t.bounds[4]=o[0],t.bounds[5]=o[1],t.bounds}if(2!==e.getNumberOfComponents())return Wl(`getBounds called on an array with components of\n        ${e.getNumberOfComponents()}`),Hl;const n=e.getRange(0);t.bounds[0]=n[0],t.bounds[1]=n[1];const r=e.getRange(1);return t.bounds[2]=r[0],t.bounds[3]=r[1],t.bounds[4]=0,t.bounds[5]=0,t.bounds},e.computeBounds=e.getBounds,e.setNumberOfComponents(t.numberOfComponents<2?3:t.numberOfComponents)}(e,t)}var $l={newInstance:Ht.newInstance(Kl,"vtkPoints"),extend:Kl};const ql={bounds:[-1,-1,-1,-1,-1,-1],pointsIds:[]};function Xl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ql,n),Ht.obj(e,t),t.points||(t.points=$l.newInstance()),Ht.get(e,t,["points","pointsIds"]),function(e,t){t.classHierarchy.push("vtkCell"),e.initialize=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(n){t.pointsIds=n;let r=t.points.getData();r.length!==3*t.pointsIds.length&&(r=Ht.newTypedArray(e.getDataType(),3*t.pointsIds.length));const o=e.getData();t.pointsIds.forEach(((e,t)=>{let n=3*e,a=3*t;r[a]=o[n],r[++a]=o[++n],r[++a]=o[++n]})),t.points.setData(r)}else{t.points=e,t.pointsIds=new Array(e.getNumberOfPoints());for(let n=e.getNumberOfPoints()-1;n>=0;--n)t.pointsIds[n]=n}},e.getBounds=()=>{const e=t.points.getNumberOfPoints(),n=[];if(e){t.points.getPoint(0,n),t.bounds[0]=n[0],t.bounds[1]=n[0],t.bounds[2]=n[1],t.bounds[3]=n[1],t.bounds[4]=n[2],t.bounds[5]=n[2];for(let r=1;r<e;r++)t.points.getPoint(r,n),t.bounds[0]=n[0]<t.bounds[0]?n[0]:t.bounds[0],t.bounds[1]=n[0]>t.bounds[1]?n[0]:t.bounds[1],t.bounds[2]=n[1]<t.bounds[2]?n[1]:t.bounds[2],t.bounds[3]=n[1]>t.bounds[3]?n[1]:t.bounds[3],t.bounds[4]=n[2]<t.bounds[4]?n[2]:t.bounds[4],t.bounds[5]=n[2]>t.bounds[5]?n[2]:t.bounds[5]}else ya(t.bounds);return t.bounds},e.getLength2=()=>{e.getBounds();let n=0,r=0;for(let e=0;e<3;e++)r=t.bounds[2*e+1]-t.bounds[2*e],n+=r*r;return n},e.getParametricDistance=e=>{let t,n=0;for(let r=0;r<3;r++)t=e[r]<0?-e[r]:e[r]>1?e[r]-1:0,t>n&&(n=t);return n},e.getNumberOfPoints=()=>t.points.getNumberOfPoints(),e.deepCopy=e=>{e.initialize(t.points,t.pointsIds)},e.getCellDimension=()=>{},e.intersectWithLine=(e,t,n,r,o,a,i)=>{},e.evaluatePosition=(e,t,n,r,o,a)=>{Ht.vtkErrorMacro("vtkCell.evaluatePosition is not implemented.")}}(e,t)}var Yl={newInstance:Ht.newInstance(Xl,"vtkCell"),extend:Xl};const Zl={array:null,maxId:0,extend:0};function Ql(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Zl,n),Ht.obj(e,t),function(e,t){t.classHierarchy.push("vtkCellLinks"),e.buildLinks=n=>{const r=n.getPoints().getNumberOfPoints(),o=n.getNumberOfCells(),a=new Uint32Array(r);if(n.isA("vtkPolyData")){for(let t=0;t<o;++t){const{cellPointIds:r}=n.getCellPoints(t);r.forEach((t=>{e.incrementLinkCount(t)}))}e.allocateLinks(r),t.maxId=r-1;for(let t=0;t<o;++t){const{cellPointIds:r}=n.getCellPoints(t);r.forEach((n=>{e.insertCellReference(n,a[n]++,t)}))}}else{for(let t=0;t<o;t++)Yl.newInstance().getPointsIds().forEach((t=>{e.incrementLinkCount(t)}));e.allocateLinks(r),t.maxId=r-1;for(let t=0;t<o;++t)Yl.newInstance().getPointsIds().forEach((n=>{e.insertCellReference(n,a[n]++,t)}))}},e.allocate=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e3;t.array=Array(e).fill().map((()=>({ncells:0,cells:null}))),t.extend=n,t.maxId=-1},e.initialize=()=>{t.array=null},e.getLink=e=>t.array[e],e.getNcells=e=>t.array[e].ncells,e.getCells=e=>t.array[e].cells,e.insertNextPoint=e=>{t.array.push({ncells:e,cells:Array(e)}),++t.maxId},e.insertNextCellReference=(e,n)=>{t.array[e].cells[t.array[e].ncells++]=n},e.deletePoint=e=>{t.array[e].ncells=0,t.array[e].cells=null},e.removeCellReference=(e,n)=>{t.array[n].cells=t.array[n].cells.filter((t=>t!==e)),t.array[n].ncells=t.array[n].cells.length},e.addCellReference=(e,n)=>{t.array[n].cells[t.array[n].ncells++]=e},e.resizeCellList=(e,n)=>{t.array[e].cells.length=n},e.squeeze=()=>{!function(e,t){let n=t;for(t>=e.array.length&&(n+=e.array.length);n>e.array.length;)e.array.push({ncells:0,cells:null});e.array.length=n}(t,t.maxId+1)},e.reset=()=>{t.maxId=-1},e.deepCopy=e=>{t.array=[...e.array],t.extend=e.extend,t.maxId=e.maxId},e.incrementLinkCount=e=>{++t.array[e].ncells},e.allocateLinks=e=>{for(let n=0;n<e;++n)t.array[n].cells=new Array(t.array[n].ncells)},e.insertCellReference=(e,n,r)=>{t.array[e].cells[n]=r}}(e,t)}var Jl={newInstance:Ht.newInstance(Ql,"vtkCellLinks"),extend:Ql};const ec=0,tc=1,nc=2,rc=3,oc=4,ac=5,ic=6,sc=7,lc=9,cc=21,uc=41,dc=42,pc=["vtkEmptyCell","vtkVertex","vtkPolyVertex","vtkLine","vtkPolyLine","vtkTriangle","vtkTriangleStrip","vtkPolygon","vtkPixel","vtkQuad","vtkTetra","vtkVoxel","vtkHexahedron","vtkWedge","vtkPyramid","vtkPentagonalPrism","vtkHexagonalPrism","UnknownClass","UnknownClass","UnknownClass","UnknownClass","vtkQuadraticEdge","vtkQuadraticTriangle","vtkQuadraticQuad","vtkQuadraticTetra","vtkQuadraticHexahedron","vtkQuadraticWedge","vtkQuadraticPyramid","vtkBiQuadraticQuad","vtkTriQuadraticHexahedron","vtkQuadraticLinearQuad","vtkQuadraticLinearWedge","vtkBiQuadraticQuadraticWedge","vtkBiQuadraticQuadraticHexahedron","vtkBiQuadraticTriangle","vtkCubicLine","vtkQuadraticPolygon","UnknownClass","UnknownClass","UnknownClass","UnknownClass","vtkConvexPointSet","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","vtkParametricCurve","vtkParametricSurface","vtkParametricTriSurface","vtkParametricQuadSurface","vtkParametricTetraRegion","vtkParametricHexRegion","UnknownClass","UnknownClass","UnknownClass","vtkHigherOrderEdge","vtkHigherOrderTriangle","vtkHigherOrderQuad","vtkHigherOrderPolygon","vtkHigherOrderTetrahedron","vtkHigherOrderWedge","vtkHigherOrderPyramid","vtkHigherOrderHexahedron"],fc={getClassNameFromTypeId:function(e){return e<pc.length?pc[e]:"UnknownClass"},getTypeIdFromClassName:function(e){return pc.findIndex(e)},isLinear:function(e){return e<cc||e===uc||e===dc},hasSubCells:function(e){return e===ic||e===oc||e===nc}},gc={size:0,maxId:-1,extend:1e3};function mc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,gc,n),Ht.obj(e,t),Ht.get(e,t,["size","maxId","extend"]),Ht.getArray(e,t,["typeArray","locationArray"]),function(e,t){t.classHierarchy.push("vtkCellTypes"),e.allocate=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:512,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e3;t.size=e>0?e:1,t.extend=n>0?n:1,t.maxId=-1,t.typeArray=new Uint8Array(e),t.locationArray=new Uint32Array(e)},e.insertCell=(e,n,r)=>{t.typeArray[e]=n,t.locationArray[e]=r,e>t.maxId&&(t.maxId=e)},e.insertNextCell=(n,r)=>(e.insertCell(++t.maxId,n,r),t.maxId),e.setCellTypes=(e,n,r)=>{t.size=e,t.typeArray=n,t.locationArray=r,t.maxId=e-1},e.getCellLocation=e=>t.locationArray[e],e.deleteCell=e=>{t.typeArray[e]=ec},e.getNumberOfTypes=()=>t.maxId+1,e.isType=t=>{const n=e.getNumberOfTypes();for(let r=0;r<n;++r)if(t===e.getCellType(r))return!0;return!1},e.insertNextType=t=>e.insertNextCell(t,-1),e.getCellType=e=>t.typeArray[e],e.reset=()=>{t.maxId=-1},e.deepCopy=n=>{e.allocate(n.getSize(),n.getExtend()),t.typeArray.set(n.getTypeArray()),t.locationArray.set(n.getLocationArray()),t.maxId=n.getMaxId()}}(e,t)}var hc={newInstance:Ht.newInstance(mc,"vtkCellTypes"),extend:mc,...fc},vc={IntersectionState:{NO_INTERSECTION:0,YES_INTERSECTION:1,ON_LINE:2}};const{IntersectionState:Tc}=vc;function yc(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const o={t:Number.MIN_VALUE,distance:0},a=[];let i;a[0]=n[0]-t[0],a[1]=n[1]-t[1],a[2]=n[2]-t[2];const s=a[0]*(e[0]-t[0])+a[1]*(e[1]-t[1])+a[2]*(e[2]-t[2]),l=No(a,a);let c=1e-5*s;return 0!==l&&(o.t=s/l),c<0&&(c=-c),-c<l&&l<c||l<=0||o.t<0?i=t:o.t>1?i=n:(i=a,a[0]=t[0]+o.t*a[0],a[1]=t[1]+o.t*a[1],a[2]=t[2]+o.t*a[2]),r&&(r[0]=i[0],r[1]=i[1],r[2]=i[2]),o.distance=Uo(i,e),o}function bc(e,t,n,r,o,a){const i=[],s=[],l=[];o[0]=0,a[0]=0,Vo(t,e,i),Vo(r,n,s),Vo(n,e,l);const c=[No(i,i),-No(i,s),-No(i,s),No(s,s)],u=[];if(u[0]=No(i,l),u[1]=-No(s,l),0===la(c,u,2)){let i=Number.MAX_VALUE;const s=[e,t,n,r],l=[n,n,e,e],c=[r,r,t,t];let u;a[0],a[0],o[0],o[0],o[0],o[0],a[0],a[0];for(let e=0;e<4;e++)u=yc(s[e],l[e],c[e]),u.distance<i&&(i=u.distance,u.t);return Tc.ON_LINE}return o[0]=u[0],a[0]=u[1],o[0]>=0&&o[0]<=1&&a[0]>=0&&a[0]<=1?Tc.YES_INTERSECTION:Tc.NO_INTERSECTION}const xc={distanceToLine:yc,intersection:bc},Cc={orientations:null};function Sc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Cc,n),Yl.extend(e,t,n),Ht.setGet(e,t,["orientations"]),function(e,t){t.classHierarchy.push("vtkLine"),e.getCellDimension=()=>1,e.intersectWithLine=(e,n,r,o,a)=>{const i={intersect:0,t:Number.MAX_VALUE,subId:0,betweenPoints:null};a[1]=0,a[2]=0;const s=[],l=[],c=[];t.points.getPoint(0,l),t.points.getPoint(1,c);const u=[],d=[],p=bc(e,n,l,c,u,d);var f;if(i.t=u[0],i.betweenPoints=(f=i.t)>=0&&f<=1,a[0]=d[0],p===Tc.YES_INTERSECTION){for(let t=0;t<3;t++)o[t]=l[t]+a[0]*(c[t]-l[t]),s[t]=e[t]+i.t*(n[t]-e[t]);if(Uo(o,s)<=r*r)return i.intersect=1,i}else{let t;if(i.t<0)return t=yc(e,l,c,o),t.distance<=r*r?(i.t=0,i.intersect=1,i.betweenPoints=!0,i):i;if(i.t>1)return t=yc(n,l,c,o),t.distance<=r*r?(i.t=1,i.intersect=1,i.betweenPoints=!0,i):i;if(a[0]<0)return a[0]=0,t=yc(l,e,n,o),i.t=t.t,t.distance<=r*r?(i.intersect=1,i):i;if(a[0]>1)return a[0]=1,t=yc(c,e,n,o),i.t=t.t,t.distance<=r*r?(i.intersect=1,i):i}return i},e.evaluateLocation=(e,n,r)=>{const o=[],a=[];t.points.getPoint(0,o),t.points.getPoint(1,a);for(let t=0;t<3;t++)n[t]=o[t]+e[0]*(a[t]-o[t]);r[0]=1-e[0],r[1]=e[0]},e.evaluateOrientation=(e,n,r)=>!!t.orientations&&(function(e,t,n,r){var o,i,s,l,c,u=t[0],d=t[1],p=t[2],f=t[3],g=n[0],m=n[1],h=n[2],v=n[3];(i=u*g+d*m+p*h+f*v)<0&&(i=-i,g=-g,m=-m,h=-h,v=-v),1-i>a?(o=Math.acos(i),s=Math.sin(o),l=Math.sin((1-r)*o)/s,c=Math.sin(r*o)/s):(l=1-r,c=r),e[0]=l*u+c*g,e[1]=l*d+c*m,e[2]=l*p+c*h,e[3]=l*f+c*v}(n,t.orientations[0],t.orientations[1],e[0]),r[0]=1-e[0],r[1]=e[0],!0)}(e,t)}var Ac={newInstance:Ht.newInstance(Sc,"vtkLine"),extend:Sc,...xc,...vc};const Ic={};function wc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ic,n),_s.extend(e,t,n),Ht.setGet(e,t,["points"]),function(e,t){t.classHierarchy.push("vtkPointSet"),t.points?t.points=We(t.points):t.points=$l.newInstance(),e.getNumberOfPoints=()=>t.points.getNumberOfPoints(),e.getBounds=()=>t.points.getBounds(),e.computeBounds=()=>{e.getBounds()};const n=e.shallowCopy;e.shallowCopy=function(e){n(e,arguments.length>1&&void 0!==arguments[1]&&arguments[1]),t.points=$l.newInstance(),t.points.shallowCopy(e.getPoints())}}(e,t)}var Oc={newInstance:Ht.newInstance(wc,"vtkPointSet"),extend:wc};function Pc(e,t,n,r){const o=n[0]-t[0],a=n[1]-t[1],i=n[2]-t[2],s=e[0]-t[0],l=e[1]-t[1],c=e[2]-t[2];r[0]=a*c-i*l,r[1]=i*s-o*c,r[2]=o*l-a*s}function Rc(e,t,n,r){Pc(e,t,n,r);const o=Math.sqrt(r[0]*r[0]+r[1]*r[1]+r[2]*r[2]);0!==o&&(r[0]/=o,r[1]/=o,r[2]/=o)}const Mc={computeNormalDirection:Pc,computeNormal:Rc,intersectWithTriangle:function(e,t,n,r,o,a){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1e-6,s=!1;const l=[],c=[],u=[],d=[],p=[];Rc(e,t,n,d),Rc(r,o,a,p);const f=-No(d,e),g=-No(p,r),m=[No(p,e)+g,No(p,t)+g,No(p,n)+g];if(m[0]*m[1]>i&&m[0]*m[2]>i)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};const h=[No(d,r)+f,No(d,o)+f,No(d,a)+f];if(h[0]*h[1]>i&&h[0]*h[2]>i)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(Math.abs(d[0]-p[0])<1e-9&&Math.abs(d[1]-p[1])<1e-9&&Math.abs(d[2]-p[2])<1e-9&&Math.abs(f-g)<1e-9)return s=!0,{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};const v=[e,t,n],T=[r,o,a],y=No(d,p),b=(f-g*y)/(y*y-1),x=(g-f*y)/(y*y-1),C=[b*d[0]+x*p[0],b*d[1]+x*p[1],b*d[2]+x*p[2]],S=Fo(d,p,[]);ko(S);let A=0,I=0;const w=[],O=[];let P,R,M=50,E=50;for(let t=0;t<3;t++){const n=t,o=(t+1)%3,a=ti.intersectWithLine(v[n],v[o],r,p);a.intersection&&a.t>0-i&&a.t<1+i&&(a.t<1+i&&a.t>1-i&&(M=A),w[A++]=No(a.x,S)-No(C,S));const s=ti.intersectWithLine(T[n],T[o],e,d);s.intersection&&s.t>0-i&&s.t<1+i&&(s.t<1+i&&s.t>1-i&&(E=I),O[I++]=No(s.x,S)-No(C,S))}if(A>2){A--;const e=w[2];w[2]=w[M],w[M]=e}if(I>2){I--;const e=O[2];O[2]=O[E],O[E]=e}if(2!==A||2!==I)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(Number.isNaN(w[0])||Number.isNaN(w[1])||Number.isNaN(O[0])||Number.isNaN(O[1]))return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(w[0]>w[1]){const e=w[1];w[1]=w[0],w[0]=e}if(O[0]>O[1]){const e=O[1];O[1]=O[0],O[0]=e}return w[1]<O[0]||O[1]<w[0]?{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u}:(w[0]<O[0]?w[1]<O[1]?(u[0]=2,u[1]=1,P=O[0],R=w[1]):(u[0]=2,u[1]=2,P=O[0],R=O[1]):w[1]<O[1]?(u[0]=1,u[1]=1,P=w[0],R=w[1]):(u[0]=1,u[1]=2,P=w[0],R=O[1]),Bo(C,S,P,l),Bo(C,S,R,c),{intersect:!0,coplanar:s,pt1:l,pt2:c,surfaceId:u})}},Ec={};function Vc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ec,n),Yl.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkTriangle"),e.getCellDimension=()=>2,e.intersectWithLine=(n,r,o,a,i)=>{const s={subId:0,t:Number.MAX_VALUE,intersect:0,betweenPoints:!1};i[2]=0;const l=[],c=o*o,u=[],d=[],p=[];t.points.getPoint(0,u),t.points.getPoint(1,d),t.points.getPoint(2,p);const f=[],g=[];if(Rc(u,d,p,f),0!==f[0]||0!==f[1]||0!==f[2]){const t=ti.intersectWithLine(n,r,u,f);if(s.betweenPoints=t.betweenPoints,s.t=t.t,a[0]=t.x[0],a[1]=t.x[1],a[2]=t.x[2],!t.intersection)return i[0]=0,i[1]=0,s.intersect=0,s;const o=e.evaluatePosition(a,l,i,g);if(o.evaluation>=0)return o.dist2<=c?(s.intersect=1,s):(s.intersect=o.evaluation,s)}const m=Uo(u,d),h=Uo(d,p),v=Uo(p,u);t.line||(t.line=Ac.newInstance()),m>h&&m>v?(t.line.getPoints().setPoint(0,u),t.line.getPoints().setPoint(1,d)):h>v&&h>m?(t.line.getPoints().setPoint(0,d),t.line.getPoints().setPoint(1,p)):(t.line.getPoints().setPoint(0,p),t.line.getPoints().setPoint(1,u));const T=t.line.intersectWithLine(n,r,o,a,i);if(s.betweenPoints=T.betweenPoints,s.t=T.t,T.intersect){const e=[],t=[],n=[];for(let r=0;r<3;r++)e[r]=u[r]-p[r],t[r]=d[r]-p[r],n[r]=a[r]-p[r];return i[0]=No(n,e)/v,i[1]=No(n,t)/h,s.intersect=1,s}return i[0]=0,i[1]=0,s.intersect=0,s},e.evaluatePosition=(e,n,r,o)=>{const a={subId:0,dist2:0,evaluation:-1};let i,s;const l=[],c=[],u=[],d=[];let p;const f=[],g=[],m=[];let h=0,v=0;const T=[];let y,b,x,C=[];const S=[],A=[],I=[];a.subId=0,r[2]=0,t.points.getPoint(1,l),t.points.getPoint(2,c),t.points.getPoint(0,u),Pc(l,c,u,d),ti.generalizedProjectPoint(e,l,d,I);let w=0;for(i=0;i<3;i++)p=d[i]<0?-d[i]:d[i],p>w&&(w=p,v=i);for(s=0,i=0;i<3;i++)i!==v&&(T[s++]=i);for(i=0;i<2;i++)f[i]=I[T[i]]-u[T[i]],g[i]=l[T[i]]-u[T[i]],m[i]=c[T[i]]-u[T[i]];if(h=Ho(g,m),0===h)return r[0]=0,r[1]=0,a.evaluation=-1,a;if(r[0]=Ho(f,m)/h,r[1]=Ho(g,f)/h,o[0]=1-(r[0]+r[1]),o[1]=r[0],o[2]=r[1],o[0]>=0&&o[0]<=1&&o[1]>=0&&o[1]<=1&&o[2]>=0&&o[2]<=1)n&&(a.dist2=Uo(I,e),n[0]=I[0],n[1]=I[1],n[2]=I[2]),a.evaluation=1;else{let t;if(n)if(o[1]<0&&o[2]<0)for(y=Uo(e,u),b=Ac.distanceToLine(e,l,u,t,S),x=Ac.distanceToLine(e,u,c,t,A),y<b?(a.dist2=y,C=u):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[2]<0&&o[0]<0)for(y=Uo(e,l),b=Ac.distanceToLine(e,l,u,t,S),x=Ac.distanceToLine(e,l,c,t,A),y<b?(a.dist2=y,C=l):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[1]<0&&o[0]<0)for(y=Uo(e,c),b=Ac.distanceToLine(e,c,u,t,S),x=Ac.distanceToLine(e,l,c,t,A),y<b?(a.dist2=y,C=c):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[0]<0){const t=Ac.distanceToLine(e,l,c,n);a.dist2=t.distance}else if(o[1]<0){const t=Ac.distanceToLine(e,c,u,n);a.dist2=t.distance}else if(o[2]<0){const t=Ac.distanceToLine(e,l,u,n);a.dist2=t.distance}a.evaluation=0}return a},e.evaluateLocation=(e,n,r)=>{const o=[],a=[],i=[];t.points.getPoint(0,o),t.points.getPoint(1,a),t.points.getPoint(2,i);const s=1-e[0]-e[1];for(let t=0;t<3;t++)n[t]=o[t]*s+a[t]*e[0]+i[t]*e[1];r[0]=s,r[1]=e[0],r[2]=e[1]},e.getParametricDistance=e=>{let t,n=0;const r=[];r[0]=e[0],r[1]=e[1],r[2]=1-e[0]-e[1];for(let e=0;e<3;e++)t=r[e]<0?-r[e]:r[e]>1?r[e]-1:0,t>n&&(n=t);return n}}(e,t)}var Dc={newInstance:Ht.newInstance(Vc,"vtkTriangle"),extend:Vc,...Mc};const Lc=["verts","lines","polys","strips"],{vtkWarningMacro:Bc}=Ht,Nc={[rc]:Ac,[oc]:Ac,[ac]:Dc},Fc={};function _c(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Fc,n),Oc.extend(e,t,n),Ht.get(e,t,["cells","links"]),Ht.setGet(e,t,["verts","lines","polys","strips"]),function(e,t){t.classHierarchy.push("vtkPolyData"),Lc.forEach((n=>{e[`getNumberOf${function(e){return e.replace(/(?:^\w|[A-Z]|\b\w)/g,(e=>e.toUpperCase())).replace(/\s+/g,"")}(n)}`]=()=>t[n].getNumberOfCells(),t[n]?t[n]=We(t[n]):t[n]=zl.newInstance()})),e.getNumberOfCells=()=>Lc.reduce(((e,n)=>e+t[n].getNumberOfCells()),0);const n=e.shallowCopy;e.shallowCopy=function(e){n(e,arguments.length>1&&void 0!==arguments[1]&&arguments[1]),Lc.forEach((n=>{t[n]=zl.newInstance(),t[n].shallowCopy(e.getReferenceByName(n))}))},e.buildCells=()=>{const n=e.getNumberOfVerts(),r=e.getNumberOfLines(),o=e.getNumberOfPolys(),a=e.getNumberOfStrips(),i=n+r+o+a,s=new Uint8Array(i);let l=s;const c=new Uint32Array(i);let u=c;if(n){let e=0;t.verts.getCellSizes().forEach(((t,n)=>{u[n]=e,l[n]=t>1?nc:tc,e+=t+1})),u=u.subarray(n),l=l.subarray(n)}if(r){let e=0;t.lines.getCellSizes().forEach(((t,n)=>{u[n]=e,l[n]=t>2?oc:rc,1===t&&Bc("Building VTK_LINE ",n," with only one point, but VTK_LINE needs at least two points. Check the input."),e+=t+1})),u=u.subarray(r),l=l.subarray(r)}if(o){let e=0;t.polys.getCellSizes().forEach(((t,n)=>{switch(u[n]=e,t){case 3:l[n]=ac;break;case 4:l[n]=lc;break;default:l[n]=sc}t<3&&Bc("Building VTK_TRIANGLE ",n," with less than three points, but VTK_TRIANGLE needs at least three points. Check the input."),e+=t+1})),u+=u.subarray(o),l+=l.subarray(o)}if(a){let e=0;l.fill(ic,0,a),t.strips.getCellSizes().forEach(((t,n)=>{u[n]=e,e+=t+1}))}t.cells=hc.newInstance(),t.cells.setCellTypes(i,s,c)},e.buildLinks=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;void 0===t.cells&&e.buildCells(),t.links=Jl.newInstance(),n>0?t.links.allocate(n):t.links.allocate(e.getPoints().getNumberOfPoints()),t.links.buildLinks(e)},e.getCellType=e=>t.cells.getCellType(e),e.getCellPoints=n=>{const r=e.getCellType(n);let o=null;switch(r){case tc:case nc:o=t.verts;break;case rc:case oc:o=t.lines;break;case ac:case lc:case sc:o=t.polys;break;case ic:o=t.strips;break;default:return o=null,{type:0,cellPointIds:null}}const a=t.cells.getCellLocation(n);return{cellType:r,cellPointIds:o.getCell(a)}},e.getPointCells=e=>t.links.getCells(e),e.getCellEdgeNeighbors=(e,n,r)=>{const o=t.links.getLink(n),a=t.links.getLink(r);return o.cells.filter((t=>t!==e&&-1!==a.cells.indexOf(t)))},e.getCell=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const r=e.getCellPoints(t),o=n||Nc[r.cellType].newInstance();return o.initialize(e.getPoints(),r.cellPointIds),o}}(e,t)}var kc={newInstance:Ht.newInstance(_c,"vtkPolyData"),extend:_c};const Gc={image:null,canvas:null,jsImageData:null,imageBitmap:null,imageLoaded:!1,repeat:!1,interpolate:!1,edgeClamp:!1,mipLevel:0,resizable:!1};function Uc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Gc,n),Ht.obj(e,t),Ht.algo(e,t,6,0),Ht.get(e,t,["canvas","image","jsImageData","imageBitmap","imageLoaded","resizable"]),Ht.setGet(e,t,["repeat","edgeClamp","interpolate","mipLevel"]),function(e,t){t.classHierarchy.push("vtkTexture"),e.imageLoaded=()=>{t.image.removeEventListener("load",e.imageLoaded),t.imageLoaded=!0,e.modified()},e.setJsImageData=n=>{t.jsImageData!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.image=null,t.canvas=null,t.imageBitmap=null),t.jsImageData=n,t.imageLoaded=!0,e.modified())},e.setImageBitmap=n=>{t.imageBitmap!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.image=null,t.canvas=null,t.jsImageData=null),t.imageBitmap=n,t.imageLoaded=!0,e.modified())},e.setCanvas=n=>{t.canvas!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.image=null,t.imageBitmap=null,t.jsImageData=null),t.canvas=n,e.modified())},e.setImage=n=>{t.image!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.canvas=null,t.jsImageData=null,t.imageBitmap=null),t.image=n,t.imageLoaded=!1,n.complete?e.imageLoaded():n.addEventListener("load",e.imageLoaded),e.modified())},e.getDimensionality=()=>{let n=0,r=0,o=1;if(e.getInputData()){const t=e.getInputData();n=t.getDimensions()[0],r=t.getDimensions()[1],o=t.getDimensions()[2]}return t.jsImageData&&(n=t.jsImageData.width,r=t.jsImageData.height),t.canvas&&(n=t.canvas.width,r=t.canvas.height),t.image&&(n=t.image.width,r=t.image.height),t.imageBitmap&&(n=t.imageBitmap.width,r=t.imageBitmap.height),(n>1)+(r>1)+(o>1)},e.getInputAsJsImageData=()=>{if(!t.imageLoaded||e.getInputData())return null;if(t.jsImageData)return t.jsImageData;if(t.imageBitmap)return t.imageBitmap;if(t.canvas)return t.canvas.getContext("2d").getImageData(0,0,t.canvas.width,t.canvas.height);if(t.image){const e=t.image.width,n=t.image.height,r=new OffscreenCanvas(e,n).getContext("2d");return r.translate(0,n),r.scale(1,-1),r.drawImage(t.image,0,0,e,n),r.getImageData(0,0,e,n)}return null}}(e,t)}var zc={newInstance:Ht.newInstance(Uc,"vtkTexture"),extend:Uc,generateMipmaps:(e,t,n)=>{const r=e.createShaderModule({code:"\n    @group(0) @binding(0) var inputTexture: texture_2d<f32>;\n    @group(0) @binding(1) var outputTexture: texture_storage_2d<rgba8unorm, write>;\n\n    @compute @workgroup_size(8, 8)\n    fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n      let texelCoord = vec2<i32>(global_id.xy);\n      let outputSize = textureDimensions(outputTexture);\n\n      if (texelCoord.x >= i32(outputSize.x) || texelCoord.y >= i32(outputSize.y)) {\n        return;\n      }\n\n      let inputSize = textureDimensions(inputTexture);\n      let scale = vec2<f32>(inputSize) / vec2<f32>(outputSize);\n\n      // Compute the floating-point source coordinate\n      let srcCoord = (vec2<f32>(texelCoord) + 0.5) * scale - 0.5;\n\n      // Get integer coordinates for the four surrounding texels\n      let x0 = i32(floor(srcCoord.x));\n      let x1 = min(x0 + 1, i32(inputSize.x) - 1);\n      let y0 = i32(floor(srcCoord.y));\n      let y1 = min(y0 + 1, i32(inputSize.y) - 1);\n\n      // Compute the weights\n      let wx = srcCoord.x - f32(x0);\n      let wy = srcCoord.y - f32(y0);\n\n      // Fetch the four texels\n      let c00 = textureLoad(inputTexture, vec2<i32>(x0, y0), 0);\n      let c10 = textureLoad(inputTexture, vec2<i32>(x1, y0), 0);\n      let c01 = textureLoad(inputTexture, vec2<i32>(x0, y1), 0);\n      let c11 = textureLoad(inputTexture, vec2<i32>(x1, y1), 0);\n\n      // Bilinear interpolation\n      let color = mix(\n        mix(c00, c10, wx),\n        mix(c01, c11, wx),\n        wy\n      );\n\n      textureStore(outputTexture, texelCoord, color);\n    }\n  "}),o=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float"}},{binding:1,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba8unorm",access:"write-only"}},{binding:2,visibility:GPUShaderStage.COMPUTE,sampler:{type:"filtering"}}]}),a=e.createPipelineLayout({bindGroupLayouts:[o]}),i=e.createComputePipeline({label:"ComputeMipmapPipeline",layout:a,compute:{module:r,entryPoint:"main"}}),s=e.createSampler({magFilter:"linear",minFilter:"linear"});for(let r=1;r<n;r++){const n=t.createView({baseMipLevel:r-1,mipLevelCount:1}),o=t.createView({baseMipLevel:r,mipLevelCount:1}),a=e.createBindGroup({layout:i.getBindGroupLayout(0),entries:[{binding:0,resource:n},{binding:1,resource:o},{binding:2,resource:s}]}),l=e.createCommandEncoder({label:"MipmapGenerateCommandEncoder"}),c=l.beginComputePass();c.setPipeline(i),c.setBindGroup(0,a);const u=Math.max(1,t.width>>r),d=Math.max(1,t.height>>r),p=Math.ceil(u/8),f=Math.ceil(d/8);c.dispatchWorkgroups(p,f),c.end(),e.queue.submit([l.finish()])}}};const Wc=[[-1,0,0],[1,0,0],[0,-1,0],[0,1,0],[0,0,-1],[0,0,1]],Hc=[[8,7,11,3],[9,1,10,5],[4,9,0,8],[2,11,6,10],[0,3,2,1],[4,5,6,7]],jc=[[0,1],[1,3],[2,3],[0,2],[4,5],[5,7],[6,7],[4,6],[0,4],[1,5],[3,7],[2,6]],Kc=[0,1,0,1,0,1,0,1,2,2,2,2],$c=[[1,2],[1,2],[0,2],[0,2],[0,1],[0,1]],qc=new Float64Array(3),Xc=new Float64Array(3),Yc=new Float64Array(3),Zc=new Float64Array(3),Qc=new Float64Array(3),Jc=new Float64Array(3),eu=new Float64Array(16);function tu(e,t){e.strokeStyle=t.strokeColor,e.lineWidth=t.strokeSize,e.fillStyle=t.fontColor,e.font=`${t.fontStyle} ${t.fontSize}px ${t.fontFamily}`}function nu(e){const t=[],n=[];for(let r=0;r<3;r++){const o=oo().domain([e[2*r],e[2*r+1]]);t[r]=o.ticks(5);const a=o.tickFormat(5);n[r]=t[r].map(a)}return{ticks:t,tickStrings:n}}const ru=Ht.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{renderable:null};Object.assign(t,{},n),Ht.obj(e,t),t.tmPolyData=kc.newInstance(),t.tmMapper=Fl.newInstance(),t.tmMapper.setInputData(t.tmPolyData),t.tmActor=os.newInstance({parentProp:e}),t.tmActor.setMapper(t.tmMapper),Ht.setGet(e,t,["renderable"]),Ht.get(e,t,["lastSize","lastAspectRatio","axisTextStyle","tickTextStyle","tmActor","ticks"]),t.forceUpdate=!1,t.lastRedrawTime={},Ht.obj(t.lastRedrawTime,{mtime:0}),t.lastRebuildTime={},Ht.obj(t.lastRebuildTime,{mtime:0}),t.lastSize=[-1,-1],t.lastTickBounds=[],function(e,t){t.classHierarchy.push("vtkCubeAxesActorHelper"),e.setRenderable=n=>{t.renderable!==n&&(t.renderable=n,t.tmActor.addTexture(t.renderable.getTmTexture()),t.tmActor.setProperty(n.getProperty()),t.tmActor.setParentProp(n),e.modified())},e.createPolyDataForOneLabel=(e,n,r,o,a,i,s)=>{const l=t.renderable.get_tmAtlas().get(e);if(!l)return;const c=t.renderable.getTextPolyData().getPoints().getData(),u=t.lastSize;qc[0]=c[3*n],qc[1]=c[3*n+1],qc[2]=c[3*n+2],wn(Yc,qc,r),Yc[0]+=.1,wn(Xc,Yc,o),yn(Qc,Xc,qc),Yc[0]-=.1,Yc[1]+=.1,wn(Xc,Yc,o),yn(Jc,Xc,qc);for(let e=0;e<3;e++)Qc[e]/=.05*u[0],Jc[e]/=.05*u[1];let d=s.ptIdx,p=s.cellIdx;qc[0]=c[3*n],qc[1]=c[3*n+1],qc[2]=c[3*n+2],a[0]<-.5?xn(Yc,Qc,a[0]*i-l.width):a[0]>.5?xn(Yc,Qc,a[0]*i):xn(Yc,Qc,a[0]*i-l.width/2),Tn(qc,qc,Yc),xn(Yc,Jc,a[1]*i-l.height/2),Tn(qc,qc,Yc),s.points[3*d]=qc[0],s.points[3*d+1]=qc[1],s.points[3*d+2]=qc[2],s.tcoords[2*d]=l.tcoords[0],s.tcoords[2*d+1]=l.tcoords[1],d++,xn(Yc,Qc,l.width),Tn(qc,qc,Yc),s.points[3*d]=qc[0],s.points[3*d+1]=qc[1],s.points[3*d+2]=qc[2],s.tcoords[2*d]=l.tcoords[2],s.tcoords[2*d+1]=l.tcoords[3],d++,xn(Yc,Jc,l.height),Tn(qc,qc,Yc),s.points[3*d]=qc[0],s.points[3*d+1]=qc[1],s.points[3*d+2]=qc[2],s.tcoords[2*d]=l.tcoords[4],s.tcoords[2*d+1]=l.tcoords[5],d++,xn(Yc,Qc,l.width),yn(qc,qc,Yc),s.points[3*d]=qc[0],s.points[3*d+1]=qc[1],s.points[3*d+2]=qc[2],s.tcoords[2*d]=l.tcoords[6],s.tcoords[2*d+1]=l.tcoords[7],d++,s.polys[4*p]=3,s.polys[4*p+1]=d-4,s.polys[4*p+2]=d-3,s.polys[4*p+3]=d-2,p++,s.polys[4*p]=3,s.polys[4*p+1]=d-4,s.polys[4*p+2]=d-2,s.polys[4*p+3]=d-1,s.ptIdx+=4,s.cellIdx+=2},e.updateTexturePolyData=()=>{const n=t.camera.getCompositeProjectionMatrix(t.lastAspectRatio,-1,1);m(n,n);const r=t.renderable.getTextValues().length,o=4*r,a=2*r,i=new Float64Array(3*o),s=new Uint16Array(4*a),l=new Float32Array(2*o);h(eu,n);const c={ptIdx:0,cellIdx:0,polys:s,points:i,tcoords:l};let u=0,d=0,p=0;const f=t.renderable.getTextPolyData().getPoints().getData(),g=t.renderable.getTextValues();for(;u<f.length/3;){qc[0]=f[3*u],qc[1]=f[3*u+1],qc[2]=f[3*u+2],wn(Yc,qc,n),qc[0]=f[3*u+3],qc[1]=f[3*u+4],qc[2]=f[3*u+5],wn(Zc,qc,n),yn(Yc,Yc,Zc);const r=[Yc[0],Yc[1]];Wo(r),e.createPolyDataForOneLabel(g[d],u,n,eu,r,t.renderable.getAxisTitlePixelOffset(),c),u+=2,d++;for(let o=0;o<t.renderable.getTickCounts()[p];o++)e.createPolyDataForOneLabel(g[d],u,n,eu,r,t.renderable.getTickLabelPixelOffset(),c),u++,d++;p++}const v=Ts.newInstance({numberOfComponents:2,values:l,name:"TextureCoordinates"});t.tmPolyData.getPointData().setTCoords(v),t.tmPolyData.getPoints().setData(i,3),t.tmPolyData.getPoints().modified(),t.tmPolyData.getPolys().setData(s,1),t.tmPolyData.getPolys().modified(),t.tmPolyData.modified()},e.updateAPISpecificData=(n,r,o)=>{t.lastSize[0]===n[0]&&t.lastSize[1]===n[1]||(t.lastSize[0]=n[0],t.lastSize[1]=n[1],t.lastAspectRatio=n[0]/n[1],t.forceUpdate=!0),t.camera=r,e.updateTexturePolyData()}}(e,t)}),"vtkCubeAxesActorHelper");function ou(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};os.extend(e,t,function(e,t,n){return{boundsScaleFactor:1.3,camera:null,dataBounds:[...Fi.INIT_BOUNDS],faceVisibilityAngle:8,gridLines:!0,axisLabels:null,axisTitlePixelOffset:35,tickLabelPixelOffset:12,generateTicks:nu,...n,axisTextStyle:{fontColor:"white",fontStyle:"normal",fontSize:18,fontFamily:"serif",...n?.axisTextStyle},tickTextStyle:{fontColor:"white",fontStyle:"normal",fontSize:14,fontFamily:"serif",...n?.tickTextStyle}}}(0,0,n)),t.lastFacesToDraw=[!1,!1,!1,!1,!1,!1],t.axisLabels=["X-Axis","Y-Axis","Z-Axis"],t.tickCounts=[],t.textValues=[],t.lastTickBounds=[],t.tmCanvas=document.createElement("canvas"),t.tmContext=t.tmCanvas.getContext("2d"),t._tmAtlas=new Map,t.tmTexture=zc.newInstance({resizable:!0}),t.tmTexture.setInterpolate(!1),e.getProperty().setDiffuse(0),e.getProperty().setAmbient(1),t.gridMapper=Fl.newInstance(),t.polyData=kc.newInstance(),t.gridMapper.setInputData(t.polyData),t.gridActor=os.newInstance(),t.gridActor.setMapper(t.gridMapper),t.gridActor.setProperty(e.getProperty()),t.gridActor.setParentProp(e),t.textPolyData=kc.newInstance(),Ht.setGet(e,t,["axisTitlePixelOffset","boundsScaleFactor","faceVisibilityAngle","gridLines","tickLabelPixelOffset","generateTicks"]),Ht.setGetArray(e,t,["dataBounds"],6),Ht.setGetArray(e,t,["axisLabels"],3),Ht.get(e,t,["axisTextStyle","tickTextStyle","camera","tmTexture","textValues","textPolyData","tickCounts","gridActor"]),function(e,t){t.classHierarchy.push("vtkCubeAxesActor"),e.setCamera=n=>{t.camera!==n&&(t.cameraModifiedSub&&(t.cameraModifiedSub.unsubscribe(),t.cameraModifiedSub=null),t.camera=n,n&&(t.cameraModifiedSub=n.onModified(e.update)),e.update(),e.modified())},e.computeFacesToDraw=()=>{const e=t.camera.getViewMatrix();m(e,e);let n=!1;const r=Fi.getDiagonalLength(t.dataBounds),o=Math.sin(t.faceVisibilityAngle*Math.PI/180);for(let a=0;a<6;a++){let i=!1;const s=Math.floor(a/2),l=(s+1)%3,c=(s+2)%3;t.dataBounds[2*l]!==t.dataBounds[2*l+1]&&t.dataBounds[2*c]!==t.dataBounds[2*c+1]&&(qc[s]=t.dataBounds[a]-.1*r*Wc[a][s],qc[l]=.5*(t.dataBounds[2*l]+t.dataBounds[2*l+1]),qc[c]=.5*(t.dataBounds[2*c]+t.dataBounds[2*c+1]),wn(Yc,qc,e),qc[s]=t.dataBounds[a],wn(Zc,qc,e),yn(Yc,Zc,Yc),Sn(Yc,Yc),i=Yc[2]>o,t.camera.getParallelProjection()||(Sn(Zc,Zc),i=An(Zc,Yc)>o)),i!==t.lastFacesToDraw[a]&&(t.lastFacesToDraw[a]=i,n=!0)}return n},e.updatePolyData=(e,n,r)=>{let o=0,a=0;o+=8;let i=0;for(let e=0;e<12;e++)n[e]>0&&i++;if(a+=i,t.gridLines)for(let t=0;t<6;t++)e[t]&&(o+=2*r[$c[t][0]].length+2*r[$c[t][1]].length,a+=r[$c[t][0]].length+r[$c[t][1]].length);const s=new Float64Array(3*o),l=new Uint32Array(3*a);let c=0,u=0;for(let e=0;e<2;e++)for(let n=0;n<2;n++)for(let r=0;r<2;r++)s[3*c]=t.dataBounds[r],s[3*c+1]=t.dataBounds[2+n],s[3*c+2]=t.dataBounds[4+e],c++;for(let e=0;e<12;e++)n[e]>0&&(l[3*u]=2,l[3*u+1]=jc[e][0],l[3*u+2]=jc[e][1],u++);if(t.gridLines)for(let n=0;n<6;n++)if(e[n]){const e=Math.floor(n/2);let o=r[$c[n][0]];for(let r=0;r<o.length;r++)s[3*c+e]=t.dataBounds[n],s[3*c+$c[n][0]]=o[r],s[3*c+$c[n][1]]=t.dataBounds[2*$c[n][1]],c++,s[3*c+e]=t.dataBounds[n],s[3*c+$c[n][0]]=o[r],s[3*c+$c[n][1]]=t.dataBounds[2*$c[n][1]+1],c++,l[3*u]=2,l[3*u+1]=c-2,l[3*u+2]=c-1,u++;o=r[$c[n][1]];for(let r=0;r<o.length;r++)s[3*c+e]=t.dataBounds[n],s[3*c+$c[n][1]]=o[r],s[3*c+$c[n][0]]=t.dataBounds[2*$c[n][0]],c++,s[3*c+e]=t.dataBounds[n],s[3*c+$c[n][1]]=o[r],s[3*c+$c[n][0]]=t.dataBounds[2*$c[n][0]+1],c++,l[3*u]=2,l[3*u+1]=c-2,l[3*u+2]=c-1,u++}t.polyData.getPoints().setData(s,3),t.polyData.getPoints().modified(),t.polyData.getLines().setData(l,1),t.polyData.getLines().modified(),t.polyData.modified()},e.updateTextData=(e,n,r,o)=>{let a=0;for(let e=0;e<12;e++)1===n[e]&&(a+=2,a+=r[Kc[e]].length);const i=t.polyData.getPoints().getData(),s=new Float64Array(3*a);let l=0,c=0,u=0;for(let a=0;a<6;a++)if(e[a])for(let e=0;e<4;e++){const d=Hc[a][e];if(1===n[d]){const e=Kc[d],n=3*jc[d][0],p=3*jc[d][1];s[3*l]=.5*(i[n]+i[p]),s[3*l+1]=.5*(i[n+1]+i[p+1]),s[3*l+2]=.5*(i[n+2]+i[p+2]),l++,s[3*l+Math.floor(a/2)]=t.dataBounds[a],s[3*l+$c[a][0]]=.5*(t.dataBounds[2*$c[a][0]]+t.dataBounds[2*$c[a][0]+1]),s[3*l+$c[a][1]]=.5*(t.dataBounds[2*$c[a][1]]+t.dataBounds[2*$c[a][1]+1]),l++,t.textValues[c]=t.axisLabels[e],c++;const f=(e+1)%3,g=(e+2)%3,m=r[e],h=o[e];t.tickCounts[u]=m.length;for(let r=0;r<m.length;r++)s[3*l+e]=m[r],s[3*l+f]=i[n+f],s[3*l+g]=i[n+g],l++,t.textValues[c]=h[r],c++;u++}}t.textPolyData.getPoints().setData(s,3),t.textPolyData.modified()},e.update=()=>{if(!t.camera)return;const n=e.computeFacesToDraw(),r=t.lastFacesToDraw;let o=!1;for(let e=0;e<6;e++)t.dataBounds[e]!==t.lastTickBounds[e]&&(o=!0,t.lastTickBounds[e]=t.dataBounds[e]);if(n||o||t.forceUpdate){const n=new Array(12).fill(0);for(let e=0;e<6;e++)if(r[e])for(let t=0;t<4;t++)n[Hc[e][t]]++;const a=t.generateTicks(t.dataBounds);e.updatePolyData(r,n,a.ticks),e.updateTextData(r,n,a.ticks,a.tickStrings),(o||t.forceUpdate)&&e.updateTextureAtlas(a.tickStrings)}t.forceUpdate=!1},e.updateTextureAtlas=e=>{t.tmContext.textBaseline="bottom",t.tmContext.textAlign="left",t._tmAtlas.clear();let n=0,r=1;for(let o=0;o<3;o++){if(!t._tmAtlas.has(t.axisLabels[o])){tu(t.tmContext,t.axisTextStyle);const e=t.tmContext.measureText(t.axisLabels[o]),a={height:e.actualBoundingBoxAscent+2,startingHeight:r,width:e.width+2,textStyle:t.axisTextStyle};t._tmAtlas.set(t.axisLabels[o],a),r+=a.height,n<a.width&&(n=a.width)}tu(t.tmContext,t.tickTextStyle);for(let a=0;a<e[o].length;a++)if(!t._tmAtlas.has(e[o][a])){const i=t.tmContext.measureText(e[o][a]),s={height:i.actualBoundingBoxAscent+2,startingHeight:r,width:i.width+2,textStyle:t.tickTextStyle};t._tmAtlas.set(e[o][a],s),r+=s.height,n<s.width&&(n=s.width)}}n=Po(n),r=Po(r),t._tmAtlas.forEach((e=>{e.tcoords=[0,(r-e.startingHeight-e.height)/r,e.width/n,(r-e.startingHeight-e.height)/r,e.width/n,(r-e.startingHeight)/r,0,(r-e.startingHeight)/r]})),t.tmCanvas.width=n,t.tmCanvas.height=r,t.tmContext.textBaseline="bottom",t.tmContext.textAlign="left",t.tmContext.clearRect(0,0,n,r),t._tmAtlas.forEach(((e,n)=>{tu(t.tmContext,e.textStyle),t.tmContext.fillText(n,1,e.startingHeight+e.height-1)})),t.tmTexture.setCanvas(t.tmCanvas),t.tmTexture.modified()},e.onModified((()=>{t.forceUpdate=!0,e.update()})),e.setTickTextStyle=n=>{t.tickTextStyle={...t.tickTextStyle,...n},e.modified()},e.setAxisTextStyle=n=>{t.axisTextStyle={...t.axisTextStyle,...n},e.modified()},e.get_tmAtlas=()=>t._tmAtlas,e.getBounds=()=>(e.update(),Fi.setBounds(t.bounds,t.gridActor.getBounds()),Fi.scaleAboutCenter(t.bounds,t.boundsScaleFactor,t.boundsScaleFactor,t.boundsScaleFactor),t.bounds);const n=Ht.chain(e.setProperty,t.gridActor.setProperty);e.setProperty=e=>n(e)[0]}(e,t)}var au={newInstance:Ht.newInstance(ou,"vtkCubeAxesActor"),extend:ou,newCubeAxesActorHelper:ru,defaultGenerateTicks:nu};const iu={};const su=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,iu,n),Xt.extend(e,t,n),t.CubeAxesActorHelper=au.newCubeAxesActorHelper(),function(e,t){t.classHierarchy.push("vtkOpenGLCubeAxesActor"),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.CubeAxesActorHelper.getRenderable()||t.CubeAxesActorHelper.setRenderable(t.renderable),e.prepareNodes(),e.addMissingNode(t.CubeAxesActorHelper.getTmActor()),e.addMissingNode(t.renderable.getGridActor()),e.removeUnusedNodes())},e.opaquePass=(e,n)=>{if(e){const e=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,n=t._openGLRenderer.getTiledSizeAndOrigin();t.CubeAxesActorHelper.updateAPISpecificData([n.usize,n.vsize],e,t._openGLRenderWindow.getRenderable())}}}(e,t)}),"vtkOpenGLCubeAxesActor");en("vtkCubeAxesActor",su);const lu={ARRAY_BUFFER:0,ELEMENT_ARRAY_BUFFER:1,TEXTURE_BUFFER:2};var cu={ObjectType:lu};const{ObjectType:uu}=cu,du={objectType:uu.ARRAY_BUFFER,context:null,allocatedGPUMemoryInBytes:0};function pu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,du,n),Ht.obj(e,t),Ht.get(e,t,["_openGLRenderWindow","allocatedGPUMemoryInBytes"]),Ht.moveToProtected(e,t,["openGLRenderWindow"]),function(e,t){function n(e){switch(e){case uu.ELEMENT_ARRAY_BUFFER:return t.context.ELEMENT_ARRAY_BUFFER;case uu.TEXTURE_BUFFER:if("TEXTURE_BUFFER"in t.context)return t.context.TEXTURE_BUFFER;case uu.ARRAY_BUFFER:default:return t.context.ARRAY_BUFFER}}t.classHierarchy.push("vtkOpenGLBufferObject");let r=null,o=null,a=!0,i="";e.getType=()=>r,e.setType=e=>{r=e},e.getHandle=()=>o,e.isReady=()=>!1===a,e.generateBuffer=e=>{const a=n(e);return null===o&&(o=t.context.createBuffer(),r=e),n(r)===a},e.upload=(s,l)=>e.generateBuffer(l)?(t.context.bindBuffer(n(r),o),t.context.bufferData(n(r),s,t.context.STATIC_DRAW),t.allocatedGPUMemoryInBytes=s.length*s.BYTES_PER_ELEMENT,a=!1,!0):(i="Trying to upload array buffer to incompatible buffer.",!1),e.bind=()=>!!o&&(t.context.bindBuffer(n(r),o),!0),e.release=()=>!!o&&(t.context.bindBuffer(n(r),null),!0),e.releaseGraphicsResources=()=>{null!==o&&(t.context.bindBuffer(n(r),null),t.context.deleteBuffer(o),o=null,t.allocatedGPUMemoryInBytes=0)},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.getError=()=>i}(e,t)}var fu={newInstance:Ht.newInstance(pu),extend:pu,...cu};function gu(e){let t=0,n=0;for(let r=0;r<3;++r){const o=e.getRange(r),a=o[1]-o[0];t+=a*a;const i=.5*(o[1]+o[0]);n+=i*i}const r=t>0&&(Math.abs(n)/t>1e6||Math.abs(Math.log10(t))>3||0===t&&n>1e6);if(r){const t=new Float64Array(3),n=new Float64Array(3);for(let r=0;r<3;++r){const o=e.getRange(r),a=o[1]-o[0];t[r]=.5*(o[1]+o[0]),n[r]=a>0?1/a:1}return{useShiftAndScale:r,coordShift:t,coordScale:n}}return{useShiftAndScale:r,coordShift:new Float32Array([0,0,0]),coordScale:new Float32Array([1,1,1])}}const{vtkErrorMacro:mu}=Ht;const hu={elementCount:0,stride:0,colorBOStride:0,vertexOffset:0,normalOffset:0,tCoordOffset:0,tCoordComponents:0,colorOffset:0,colorComponents:0,tcoordBO:null,customData:[],coordShift:null,coordScale:null,coordShiftAndScaleEnabled:!1,inverseShiftAndScaleMatrix:null};function vu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,hu,n),fu.extend(e,t,n),Ht.setGet(e,t,["colorBO","elementCount","stride","colorBOStride","vertexOffset","normalOffset","tCoordOffset","tCoordComponents","colorOffset","colorComponents","customData"]),Ht.get(e,t,["coordShift","coordScale","coordShiftAndScaleEnabled","inverseShiftAndScaleMatrix"]),function(e,t){t.classHierarchy.push("vtkOpenGLCellArrayBufferObject"),e.setType(lu.ARRAY_BUFFER),e.createVBO=function(n,r,o,a){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;if(!n.getData()||!n.getData().length)return t.elementCount=0,0;t.blockSize=3,t.vertexOffset=0,t.normalOffset=0,t.tCoordOffset=0,t.tCoordComponents=0,t.colorComponents=0,t.colorOffset=0,t.customData=[];const s=a.points.getData();let l=null,c=null,u=null;const d=a.colors?a.colors.getNumberOfComponents():0,p=a.tcoords?a.tcoords.getNumberOfComponents():0;a.normals&&(t.normalOffset=4*t.blockSize,t.blockSize+=3,l=a.normals.getData()),a.customAttributes&&a.customAttributes.forEach((e=>{e&&(t.customData.push({data:e.getData(),offset:4*t.blockSize,components:e.getNumberOfComponents(),name:e.getName()}),t.blockSize+=e.getNumberOfComponents())})),a.tcoords&&(t.tCoordOffset=4*t.blockSize,t.tCoordComponents=p,t.blockSize+=p,c=a.tcoords.getData()),a.colors?(t.colorComponents=a.colors.getNumberOfComponents(),t.colorOffset=0,u=a.colors.getData(),t.colorBO||(t.colorBO=fu.newInstance()),t.colorBO.setOpenGLRenderWindow(t._openGLRenderWindow)):t.colorBO=null,t.stride=4*t.blockSize;let f,g=0,m=0,h=0,v=0,T=0,y=0;const b={anythingToPoints(e,t,n,r){for(let o=0;o<e;++o)f(t[n+o],r)},linesToWireframe(e,t,n,r){for(let o=0;o<e-1;++o)f(t[n+o],r),f(t[n+o+1],r)},polysToWireframe(e,t,n,r){if(e>2)for(let o=0;o<e;++o)f(t[n+o],r),f(t[n+(o+1)%e],r)},stripsToWireframe(e,t,n,r){if(e>2){for(let o=0;o<e-1;++o)f(t[n+o],r),f(t[n+o+1],r);for(let o=0;o<e-2;o++)f(t[n+o],r),f(t[n+o+2],r)}},polysToSurface(e,t,n,r){for(let o=0;o<e-2;o++)f(t[n+0],r),f(t[n+o+1],r),f(t[n+o+2],r)},stripsToSurface(e,t,n,r){for(let o=0;o<e-2;o++)f(t[n+o],r),f(t[n+o+1+o%2],r),f(t[n+o+1+(o+1)%2],r)}},x={anythingToPoints(e,t){return e},linesToWireframe(e,t){return e>1?2*(e-1):0},polysToWireframe(e,t){return e>2?2*e:0},stripsToWireframe(e,t){return e>2?4*e-6:0},polysToSurface(e,t){return e>2?3*(e-2):0},stripsToSurface(e,t,n){return e>2?3*(e-2):0}};let C=null,S=null;o===qi.POINTS||"verts"===r?(C=b.anythingToPoints,S=x.anythingToPoints):o===qi.WIREFRAME||"lines"===r?(C=b[`${r}ToWireframe`],S=x[`${r}ToWireframe`]):(C=b[`${r}ToSurface`],S=x[`${r}ToSurface`]);const A=n.getData(),I=A.length;let w=0;for(let e=0;e<I;)w+=S(A[e],A),e+=A[e]+1;let O=null;const P=new Float32Array(w*t.blockSize);u&&(O=new Uint8Array(4*w));let R=0,M=0;const{useShiftAndScale:E,coordShift:V,coordScale:D}=gu(a.points);if(E?e.setCoordShiftAndScale(V,D):!0===t.coordShiftAndScaleEnabled&&e.setCoordShiftAndScale(null,null),i)if(i.points||i.cells){const e=new Int32Array(w+i.points.length);e.set(i.points),i.points=e;const t=new Int32Array(w+i.cells.length);t.set(i.cells),i.cells=t}else i.points=new Int32Array(w),i.cells=new Int32Array(w);let L=a.vertexOffset;f=function(e,n){if(i&&(i.points[L]=e,i.cells[L]=y+a.cellOffset),++L,g=3*e,t.coordShiftAndScaleEnabled?(P[R++]=(s[g++]-t.coordShift[0])*t.coordScale[0],P[R++]=(s[g++]-t.coordShift[1])*t.coordScale[1],P[R++]=(s[g++]-t.coordShift[2])*t.coordScale[2]):(P[R++]=s[g++],P[R++]=s[g++],P[R++]=s[g++]),null!==l&&(m=a.haveCellNormals?3*(y+a.cellOffset):3*e,P[R++]=l[m++],P[R++]=l[m++],P[R++]=l[m++]),t.customData.forEach((t=>{T=e*t.components;for(let e=0;e<t.components;++e)P[R++]=t.data[T++]})),null!==c){h=a.useTCoordsPerCell?n*p:e*p;for(let e=0;e<p;++e)P[R++]=c[h++]}null!==u&&(v=a.haveCellScalars?(y+a.cellOffset)*d:e*d,O[M++]=u[v++],O[M++]=u[v++],O[M++]=u[v++],O[M++]=4===d?u[v++]:255)};for(let e=0;e<I;e+=A[e]+1,y++)C(A[e],A,e+1,y+a.cellOffset);return t.elementCount=w,e.upload(P,lu.ARRAY_BUFFER),t.colorBO&&(t.colorBOStride=4,t.colorBO.upload(O,lu.ARRAY_BUFFER)),y},e.setCoordShiftAndScale=(e,n)=>{null===e||e.constructor===Float64Array&&3===e.length?null===n||n.constructor===Float64Array&&3===n.length?(null!==t.coordShift&&null!==e&&Rn(e,t.coordShift)||(t.coordShift=e),null!==t.coordScale&&null!==n&&Rn(n,t.coordScale)||(t.coordScale=n),t.coordShiftAndScaleEnabled=function(e,t){return null!==e&&null!==t&&!(Pn(e,[0,0,0])&&Pn(t,[1,1,1]))}(t.coordShift,t.coordScale),t.coordShiftAndScaleEnabled?t.inverseShiftAndScaleMatrix=function(e,t){const n=new Float64Array(3);Cn(n,t);const r=new Float64Array(16);return F(r,Na(),e,n),r}(t.coordShift,t.coordScale):t.inverseShiftAndScaleMatrix=null):mu("Wrong type for coordScale, expected vec3 or null"):mu("Wrong type for coordShift, expected vec3 or null")}}(e,t)}var Tu={newInstance:Ht.newInstance(vu),extend:vu};const{vtkErrorMacro:yu}=Ht,bu={shaderType:"Unknown",source:"",error:"",handle:0,dirty:!1,context:null};function xu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bu,n),Ht.obj(e,t),Ht.setGet(e,t,["shaderType","source","error","handle","context"]),function(e,t){t.classHierarchy.push("vtkShader"),e.compile=()=>{let e=t.context.VERTEX_SHADER;if(!t.source||!t.source.length||"Unknown"===t.shaderType)return!1;if(0!==t.handle&&(t.context.deleteShader(t.handle),t.handle=0),e="Fragment"===t.shaderType?t.context.FRAGMENT_SHADER:t.context.VERTEX_SHADER,t.handle=t.context.createShader(e),t.context.shaderSource(t.handle,t.source),t.context.compileShader(t.handle),!t.context.getShaderParameter(t.handle,t.context.COMPILE_STATUS)){const e=t.context.getShaderInfoLog(t.handle);return yu(`Error compiling shader '${t.source}': ${e}`),t.context.deleteShader(t.handle),t.handle=0,!1}return!0},e.cleanup=()=>{"Unknown"!==t.shaderType&&0!==t.handle&&(t.context.deleteShader(t.handle),t.handle=0,t.dirty=!0)}}(e,t)}var Cu={newInstance:Ht.newInstance(xu,"vtkShader"),extend:xu};const{vtkErrorMacro:Su}=Ht,Au={vertexShaderHandle:0,fragmentShaderHandle:0,geometryShaderHandle:0,vertexShader:null,fragmentShader:null,geometryShader:null,linked:!1,bound:!1,compiled:!1,error:"",handle:0,numberOfOutputs:0,attributesLocs:null,uniformLocs:null,md5Hash:0,context:null,lastCameraMTime:null};function Iu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Au,n),t.attributesLocs={},t.uniformLocs={},t.vertexShader=Cu.newInstance(),t.vertexShader.setShaderType("Vertex"),t.fragmentShader=Cu.newInstance(),t.fragmentShader.setShaderType("Fragment"),t.geometryShader=Cu.newInstance(),t.geometryShader.setShaderType("Geometry"),Ht.obj(e,t),Ht.get(e,t,["lastCameraMTime"]),Ht.setGet(e,t,["error","handle","compiled","bound","md5Hash","vertexShader","fragmentShader","geometryShader","linked"]),function(e,t){t.classHierarchy.push("vtkShaderProgram"),e.compileShader=()=>t.vertexShader.compile()?t.fragmentShader.compile()?e.attachShader(t.vertexShader)&&e.attachShader(t.fragmentShader)?e.link()?(e.setCompiled(!0),1):(Su(`Links failed: ${t.error}`),0):(Su(t.error),0):(Su(t.fragmentShader.getSource().split("\n").map(((e,t)=>`${t}: ${e}`)).join("\n")),Su(t.fragmentShader.getError()),0):(Su(t.vertexShader.getSource().split("\n").map(((e,t)=>`${t}: ${e}`)).join("\n")),Su(t.vertexShader.getError()),0),e.cleanup=()=>{"Unknown"!==t.shaderType&&0!==t.handle&&(e.release(),0!==t.vertexShaderHandle&&(t.context.detachShader(t.handle,t.vertexShaderHandle),t.vertexShaderHandle=0),0!==t.fragmentShaderHandle&&(t.context.detachShader(t.handle,t.fragmentShaderHandle),t.fragmentShaderHandle=0),t.context.deleteProgram(t.handle),t.handle=0,e.setCompiled(!1))},e.bind=()=>!(!t.linked&&!e.link()||(t.context.useProgram(t.handle),e.setBound(!0),0)),e.isBound=()=>!!t.bound,e.release=()=>{t.context.useProgram(null),e.setBound(!1)},e.setContext=e=>{t.vertexShader.setContext(e),t.fragmentShader.setContext(e),t.geometryShader.setContext(e)},e.link=()=>{if(t.linked)return!0;if(0===t.handle)return t.error="Program has not been initialized, and/or does not have shaders.",!1;if(t.uniformLocs={},t.context.linkProgram(t.handle),!t.context.getProgramParameter(t.handle,t.context.LINK_STATUS)){const e=t.context.getProgramInfoLog(t.handle);return Su(`Error linking shader ${e}`),t.handle=0,!1}return e.setLinked(!0),t.attributeLocs={},!0},e.setUniformMatrix=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;const a=new Float32Array(r);return t.context.uniformMatrix4fv(o,!1,a),!0},e.setUniformMatrix3x3=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;const a=new Float32Array(r);return t.context.uniformMatrix3fv(o,!1,a),!0},e.setUniformf=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1f(o,r),!0)},e.setUniformfv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1fv(o,r),!0)},e.setUniformi=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1i(o,r),!0)},e.setUniformiv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1iv(o,r),!0)},e.setUniform2f=(n,r,o)=>{const a=e.findUniform(n);if(-1===a)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===o)throw new RangeError("Invalid number of values for array");return t.context.uniform2f(a,r,o),!0},e.setUniform2fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform2fv(o,r),!0)},e.setUniform2i=(n,r,o)=>{const a=e.findUniform(n);if(-1===a)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===o)throw new RangeError("Invalid number of values for array");return t.context.uniform2i(a,r,o),!0},e.setUniform2iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform2iv(o,r),!0)},e.setUniform3f=(n,r,o,a)=>{const i=e.findUniform(n);if(-1===i)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===a)throw new RangeError("Invalid number of values for array");return t.context.uniform3f(i,r,o,a),!0},e.setUniform3fArray=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(!Array.isArray(r)||3!==r.length)throw new RangeError("Invalid number of values for array");return t.context.uniform3f(o,r[0],r[1],r[2]),!0},e.setUniform3fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform3fv(o,r),!0)},e.setUniform3i=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),3!==s.length)throw new RangeError("Invalid number of values for array");return t.context.uniform3i(r,s[0],s[1],s[2]),!0},e.setUniform3iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform3iv(o,r),!0)},e.setUniform4f=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),4!==s.length)throw new RangeError("Invalid number of values for array");return t.context.uniform4f(r,s[0],s[1],s[2],s[3]),!0},e.setUniform4fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform4fv(o,r),!0)},e.setUniform4i=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),4!==s.length)throw new RangeError("Invalid number of values for array");return t.context.uniform4i(r,s[0],s[1],s[2],s[3]),!0},e.setUniform4iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform4iv(o,r),!0)},e.findUniform=e=>{if(!e||!t.linked)return-1;let n=t.uniformLocs[e];return void 0!==n?n:(n=t.context.getUniformLocation(t.handle,e),null===n?(t.error=`Uniform ${e} not found in current shader program.`,t.uniformLocs[e]=-1,-1):(t.uniformLocs[e]=n,n))},e.isUniformUsed=e=>{if(!e)return!1;let n=t.uniformLocs[e];return void 0!==n?null!==n:t.linked?(n=t.context.getUniformLocation(t.handle,e),t.uniformLocs[e]=n,null!==n):(Su("attempt to find uniform when the shader program is not linked"),!1)},e.isAttributeUsed=e=>{if(!e)return!1;if(e in t.attributeLocs)return!0;if(!t.linked)return Su("attempt to find uniform when the shader program is not linked"),!1;const n=t.context.getAttribLocation(t.handle,e);return-1!==n&&(t.attributeLocs[e]=n,!0)},e.attachShader=n=>{if(0===n.getHandle())return t.error="Shader object was not initialized, cannot attach it.",!1;if("Unknown"===n.getShaderType())return t.error="Shader object is of type Unknown and cannot be used.",!1;if(0===t.handle){const e=t.context.createProgram();if(0===e)return t.error="Could not create shader program.",!1;t.handle=e,t.linked=!1}return"Vertex"===n.getShaderType()&&(0!==t.vertexShaderHandle&&t.context.detachShader(t.handle,t.vertexShaderHandle),t.vertexShaderHandle=n.getHandle()),"Fragment"===n.getShaderType()&&(0!==t.fragmentShaderHandle&&t.context.detachShader(t.handle,t.fragmentShaderHandle),t.fragmentShaderHandle=n.getHandle()),t.context.attachShader(t.handle,n.getHandle()),e.setLinked(!1),!0},e.detachShader=e=>{if(0===e.getHandle())return t.error="shader object was not initialized, cannot attach it.",!1;if("Unknown"===e.getShaderType())return t.error="Shader object is of type Unknown and cannot be used.",!1;switch(0===t.handle&&(t.error="This shader program has not been initialized yet."),e.getShaderType()){case"Vertex":return t.vertexShaderHandle!==e.getHandle()?(t.error="The supplied shader was not attached to this program.",!1):(t.context.detachShader(t.handle,e.getHandle()),t.vertexShaderHandle=0,t.linked=!1,!0);case"Fragment":return t.fragmentShaderHandle!==e.getHandle()?(t.error="The supplied shader was not attached to this program.",!1):(t.context.detachShader(t.handle,e.getHandle()),t.fragmentShaderHandle=0,t.linked=!1,!0);default:return!1}},e.setContext=e=>{t.context=e,t.vertexShader.setContext(e),t.fragmentShader.setContext(e),t.geometryShader.setContext(e)},e.setLastCameraMTime=e=>{t.lastCameraMTime=e}}(e,t)}var wu={newInstance:Ht.newInstance(Iu,"vtkShaderProgram"),extend:Iu,substitute:function(e,t,n,r){const o="string"==typeof n?n:n.join("\n"),a=!1===r?t:new RegExp(t,"g"),i=e.replace(a,o);return{replace:i!==o,result:i}}};const Ou={forceEmulation:!1,handleVAO:0,handleProgram:0,supported:!0,buffers:null,context:null};function Pu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ou,n),t.buffers=[],Ht.obj(e,t),Ht.get(e,t,["supported"]),Ht.setGet(e,t,["forceEmulation"]),function(e,t){t.classHierarchy.push("vtkOpenGLVertexArrayObject"),e.exposedMethod=()=>{},e.initialize=()=>{t.instancingExtension=null,t._openGLRenderWindow.getWebgl2()||(t.instancingExtension=t.context.getExtension("ANGLE_instanced_arrays")),!t.forceEmulation&&t._openGLRenderWindow&&t._openGLRenderWindow.getWebgl2()?(t.extension=null,t.supported=!0,t.handleVAO=t.context.createVertexArray()):(t.extension=t.context.getExtension("OES_vertex_array_object"),!t.forceEmulation&&t.extension?(t.supported=!0,t.handleVAO=t.extension.createVertexArrayOES()):t.supported=!1)},e.isReady=()=>0!==t.handleVAO||!1===t.supported,e.bind=()=>{if(e.isReady()||e.initialize(),e.isReady()&&t.supported)t.extension?t.extension.bindVertexArrayOES(t.handleVAO):t.context.bindVertexArray(t.handleVAO);else if(e.isReady()){const e=t.context;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];t.context.bindBuffer(e.ARRAY_BUFFER,r.buffer);for(let n=0;n<r.attributes.length;++n){const o=r.attributes[n],a=o.isMatrix?o.size:1;for(let n=0;n<a;++n)e.enableVertexAttribArray(o.index+n),e.vertexAttribPointer(o.index+n,o.size,o.type,o.normalize,o.stride,o.offset+o.stride*n/o.size),o.divisor>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(o.index+n,1):e.vertexAttribDivisor(o.index+n,1))}}}},e.release=()=>{if(e.isReady()&&t.supported)t.extension?t.extension.bindVertexArrayOES(null):t.context.bindVertexArray(null);else if(e.isReady()){const e=t.context;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];t.context.bindBuffer(e.ARRAY_BUFFER,r.buffer);for(let n=0;n<r.attributes.length;++n){const o=r.attributes[n],a=o.isMatrix?o.size:1;for(let n=0;n<a;++n)e.enableVertexAttribArray(o.index+n),e.vertexAttribPointer(o.index+n,o.size,o.type,o.normalize,o.stride,o.offset+o.stride*n/o.size),o.divisor>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(o.index+n,0):e.vertexAttribDivisor(o.index+n,0)),e.disableVertexAttribArray(o.index+n)}}}},e.shaderProgramChanged=()=>{e.release(),t.handleVAO&&(t.extension?t.extension.deleteVertexArrayOES(t.handleVAO):t.context.deleteVertexArray(t.handleVAO)),t.handleVAO=0,t.handleProgram=0},e.releaseGraphicsResources=()=>{e.shaderProgramChanged(),t.handleVAO&&(t.extension?t.extension.deleteVertexArrayOES(t.handleVAO):t.context.deleteVertexArray(t.handleVAO)),t.handleVAO=0,t.supported=!0,t.handleProgram=0},e.addAttributeArray=(t,n,r,o,a,i,s,l)=>e.addAttributeArrayWithDivisor(t,n,r,o,a,i,s,l,0,!1),e.addAttributeArrayWithDivisor=(n,r,o,a,i,s,l,c,u,d)=>{if(!n)return!1;if(!n.isBound()||0===r.getHandle()||r.getType()!==lu.ARRAY_BUFFER)return!1;if(0===t.handleProgram&&(t.handleProgram=n.getHandle()),e.isReady()||e.initialize(),!e.isReady()||t.handleProgram!==n.getHandle())return!1;const p=t.context,f={};if(f.name=o,f.index=p.getAttribLocation(t.handleProgram,o),f.offset=a,f.stride=i,f.type=s,f.size=l,f.normalize=c,f.isMatrix=d,f.divisor=u,-1===f.Index)return!1;if(r.bind(),p.enableVertexAttribArray(f.index),p.vertexAttribPointer(f.index,f.size,f.type,f.normalize,f.stride,f.offset),u>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(f.index,1):p.vertexAttribDivisor(f.index,1)),f.buffer=r.getHandle(),!t.supported){let e=!1;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];if(r.buffer===f.buffer){e=!0;let t=!1;for(let e=0;e<r.attributes.length;++e)r.attributes[e].name===o&&(t=!0,r.attributes[e]=f);t||r.attributes.push(f)}}e||t.buffers.push({buffer:f.buffer,attributes:[f]})}return!0},e.addAttributeMatrixWithDivisor=(n,r,o,a,i,s,l,c,u)=>{const d=e.addAttributeArrayWithDivisor(n,r,o,a,i,s,l,c,u,!0);if(!d)return d;const p=t.context,f=p.getAttribLocation(t.handleProgram,o);for(let e=1;e<l;e++)p.enableVertexAttribArray(f+e),p.vertexAttribPointer(f+e,l,s,c,i,a+i*e/l),u>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(f+e,1):p.vertexAttribDivisor(f+e,1));return!0},e.removeAttributeArray=n=>{if(!e.isReady()||0===t.handleProgram)return!1;if(!t.supported)for(let e=0;e<t.buffers.length;++e){const r=t.buffers[e];for(let o=0;o<r.attributes.length;++o)if(r.attributes[o].name===n)return r.attributes.splice(o,1),r.attributes.length||t.buffers.splice(e,1),!0}return!0},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))}}(e,t)}var Ru={newInstance:Ht.newInstance(Pu,"vtkOpenGLVertexArrayObject"),extend:Pu};const Mu={Start:0,Points:0,Lines:1,Tris:2,TriStrips:3,TrisEdges:4,TriStripsEdges:5,End:6},Eu={context:null,program:null,shaderSourceTime:null,VAO:null,attributeUpdateTime:null,CABO:null,primitiveType:0,pointPicking:!1};function Vu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Eu,n),Ht.obj(e,t),t.shaderSourceTime={},Ht.obj(t.shaderSourceTime),t.attributeUpdateTime={},Ht.obj(t.attributeUpdateTime),Ht.setGet(e,t,["program","shaderSourceTime","VAO","attributeUpdateTime","CABO","primitiveType","pointPicking"]),t.program=wu.newInstance(),t.VAO=Ru.newInstance(),t.CABO=Tu.newInstance(),function(e,t){t.classHierarchy.push("vtkOpenGLHelper"),e.setOpenGLRenderWindow=e=>{t.context=e.getContext(),t.program.setContext(t.context),t.VAO.setOpenGLRenderWindow(e),t.CABO.setOpenGLRenderWindow(e)},e.releaseGraphicsResources=e=>{t.VAO.releaseGraphicsResources(),t.CABO.releaseGraphicsResources(),t.CABO.setElementCount(0)},e.drawArrays=(n,r,o,a)=>{if(t.CABO.getElementCount()){const i=e.getOpenGLMode(o),s=e.haveWideLines(n,r),l=t.context,c=l.getParameter(l.DEPTH_WRITEMASK);t.pointPicking&&l.depthMask(!1),i===l.LINES&&s?(e.updateShaders(n,r,a),l.drawArraysInstanced(i,0,t.CABO.getElementCount(),2*Math.ceil(r.getProperty().getLineWidth()))):(l.lineWidth(r.getProperty().getLineWidth()),e.updateShaders(n,r,a),l.drawArrays(i,0,t.CABO.getElementCount()),l.lineWidth(1));const u=(i===l.POINTS?1:0)||(i===l.LINES?2:3);return t.pointPicking&&l.depthMask(c),t.CABO.getElementCount()/u}return 0},e.getOpenGLMode=e=>{if(t.pointPicking)return t.context.POINTS;const n=t.primitiveType;return e===qi.POINTS||n===Mu.Points?t.context.POINTS:e===qi.WIREFRAME||n===Mu.Lines||n===Mu.TrisEdges||n===Mu.TriStripsEdges?t.context.LINES:t.context.TRIANGLES},e.haveWideLines=(e,n)=>n.getProperty().getLineWidth()>1&&!(t.CABO.getOpenGLRenderWindow()&&t.CABO.getOpenGLRenderWindow().getHardwareMaximumLineWidth()>=n.getProperty().getLineWidth()),e.getNeedToRebuildShaders=(t,n,r)=>!!(r.getNeedToRebuildShaders(e,t,n)||0===e.getProgram()||e.getShaderSourceTime().getMTime()<r.getMTime()||e.getShaderSourceTime().getMTime()<n.getMTime()),e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};o.buildShaders(a,n,r);const i=t.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==e.getProgram()&&(e.setProgram(i),e.getVAO().releaseGraphicsResources()),e.getShaderSourceTime().modified()}else t.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgram(e.getProgram());e.getVAO().bind(),o.setMapperShaderParameters(e,n,r),o.setPropertyShaderParameters(e,n,r),o.setCameraShaderParameters(e,n,r),o.setLightingShaderParameters(e,n,r),o.invokeShaderCallbacks(e,n,r)},e.setMapperShaderParameters=(n,r,o)=>{if(e.haveWideLines(n,r)){e.getProgram().setUniform2f("viewportSize",o.usize,o.vsize);const t=parseFloat(r.getProperty().getLineWidth()),n=t/2;e.getProgram().setUniformf("lineWidthStepSize",t/Math.ceil(t)),e.getProgram().setUniformf("halfLineWidth",n)}t.primitiveType===Mu.Points||r.getProperty().getRepresentation()===qi.POINTS?e.getProgram().setUniformf("pointSize",r.getProperty().getPointSize()):t.pointPicking&&e.getProgram().setUniformf("pointSize",e.getPointPickingPrimitiveSize())},e.replaceShaderPositionVC=(n,r,o)=>{let a=n.Vertex;a=wu.substitute(a,"//VTK::PositionVC::Dec",["//VTK::PositionVC::Dec","uniform float pointSize;"]).result,a=wu.substitute(a,"//VTK::PositionVC::Impl",["//VTK::PositionVC::Impl","  gl_PointSize = pointSize;"],!1).result,e.getOpenGLMode(o.getProperty().getRepresentation())===t.context.LINES&&e.haveWideLines(r,o)&&(a=wu.substitute(a,"//VTK::PositionVC::Dec",["//VTK::PositionVC::Dec","uniform vec2 viewportSize;","uniform float lineWidthStepSize;","uniform float halfLineWidth;"]).result,a=wu.substitute(a,"//VTK::PositionVC::Impl",["//VTK::PositionVC::Impl"," if (halfLineWidth > 0.0)","   {","   float offset = float(gl_InstanceID / 2) * lineWidthStepSize - halfLineWidth;","   vec4 tmpPos = gl_Position;","   vec3 tmpPos2 = tmpPos.xyz / tmpPos.w;","   tmpPos2.x = tmpPos2.x + 2.0 * mod(float(gl_InstanceID), 2.0) * offset / viewportSize[0];","   tmpPos2.y = tmpPos2.y + 2.0 * mod(float(gl_InstanceID + 1), 2.0) * offset / viewportSize[1];","   gl_Position = vec4(tmpPos2.xyz * tmpPos.w, tmpPos.w);","   }"]).result),n.Vertex=a},e.getPointPickingPrimitiveSize=()=>t.primitiveType===Mu.Points?2:t.primitiveType===Mu.Lines?4:6,e.getAllocatedGPUMemoryInBytes=()=>e.getCABO().getAllocatedGPUMemoryInBytes()}(e,t)}var Du={newInstance:Ht.newInstance(Vu),extend:Vu,primTypes:Mu};const Lu={CLAMP_TO_EDGE:0,REPEAT:1,MIRRORED_REPEAT:2},Bu={NEAREST:0,LINEAR:1,NEAREST_MIPMAP_NEAREST:2,NEAREST_MIPMAP_LINEAR:3,LINEAR_MIPMAP_NEAREST:4,LINEAR_MIPMAP_LINEAR:5};var Nu={Wrap:Lu,Filter:Bu};const Fu=new Float32Array(1),_u=new Int32Array(Fu.buffer);var ku={fromHalf:function(e){const t=(32768&e)>>15,n=(31744&e)>>10,r=1023&e;return 0===n?(t?-1:1)*2**-14*(r/1024):31===n?r?NaN:1/0*(t?-1:1):(t?-1:1)*2**(n-15)*(1+r/1024)},toHalf:function(e){Fu[0]=e;const t=_u[0];let n=t>>16&32768,r=t>>12&2047;const o=t>>23&255;return o<103?n:o>142?(n|=31744,n|=(255===o?0:1)&&8388607&t,n):o<113?(r|=2048,n|=(r>>114-o)+(r>>113-o&1),n):(n|=o-112<<10|r>>1,n+=1&r,n)}};let Gu;const{Wrap:Uu,Filter:zu}=Nu,{VtkDataTypes:Wu}=Ts,{vtkDebugMacro:Hu,vtkErrorMacro:ju,vtkWarningMacro:Ku,requiredParam:$u}=jt,{toHalf:qu}=ku;function Xu(e,t){function n(){return{internalFormat:t.internalFormat,format:t.format,openGLDataType:t.openGLDataType,width:t.width,height:t.height}}t.classHierarchy.push("vtkOpenGLTexture"),e.render=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;if(n?t._openGLRenderWindow=n:(t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow")),t.context=t._openGLRenderWindow.getContext(),t.renderable.getInterpolate()?(t.generateMipmap?e.setMinificationFilter(zu.LINEAR_MIPMAP_LINEAR):e.setMinificationFilter(zu.LINEAR),e.setMagnificationFilter(zu.LINEAR)):(e.setMinificationFilter(zu.NEAREST),e.setMagnificationFilter(zu.NEAREST)),t.renderable.getRepeat()&&(e.setWrapR(Uu.REPEAT),e.setWrapS(Uu.REPEAT),e.setWrapT(Uu.REPEAT)),t.renderable.getInputData()&&t.renderable.setImage(null),!t.handle||t.renderable.getMTime()>t.textureBuildTime.getMTime()){if(null!==t.renderable.getImageBitmap()&&(t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(zu.LINEAR_MIPMAP_LINEAR)),t.renderable.getImageBitmap()&&t.renderable.getImageLoaded()&&(e.create2DFromImageBitmap(t.renderable.getImageBitmap()),e.activate(),e.sendParameters(),t.textureBuildTime.modified())),null!==t.renderable.getImage()&&(t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(zu.LINEAR_MIPMAP_LINEAR)),t.renderable.getImage()&&t.renderable.getImageLoaded()&&(e.create2DFromImage(t.renderable.getImage()),e.activate(),e.sendParameters(),t.textureBuildTime.modified())),null!==t.renderable.getCanvas()){t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(zu.LINEAR_MIPMAP_LINEAR));const n=t.renderable.getCanvas();e.create2DFromRaw({width:n.width,height:n.height,numComps:4,dataType:Wu.UNSIGNED_CHAR,data:n,flip:!0}),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}if(null!==t.renderable.getJsImageData()){const n=t.renderable.getJsImageData();t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(zu.LINEAR_MIPMAP_LINEAR)),e.create2DFromRaw({width:n.width,height:n.height,numComps:4,dataType:Wu.UNSIGNED_CHAR,data:n.data,flip:!0}),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}const n=t.renderable.getInputData(0);if(n&&n.getPointData().getScalars()){const r=n.getExtent(),o=n.getPointData().getScalars(),a=[];for(let e=0;e<t.renderable.getNumberOfInputPorts();++e){const n=t.renderable.getInputData(e),r=n?n.getPointData().getScalars().getData():null;r&&a.push(r)}t.renderable.getInterpolate()&&4===o.getNumberOfComponents()&&(t.generateMipmap=!0,e.setMinificationFilter(zu.LINEAR_MIPMAP_LINEAR)),a.length%6==0?e.createCubeFromRaw({width:r[1]-r[0]+1,height:r[3]-r[2]+1,numComps:o.getNumberOfComponents(),dataType:o.getDataType(),data:a}):e.create2DFromRaw({width:r[1]-r[0]+1,height:r[3]-r[2]+1,numComps:o.getNumberOfComponents(),dataType:o.getDataType(),data:o.getData()}),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}}t.handle&&e.activate()};const r=()=>{if(t.minificationFilter!==zu.LINEAR&&t.magnificationFilter!==zu.LINEAR||(void 0===Gu&&(Gu=function(){try{const e=4,t=2,n=1,r=new Int16Array([0,32767]),o=[1,1],a=document.createElement("canvas");a.width=e,a.height=e;const i=a.getContext("webgl2");if(!i)return!1;const s=i.getExtension("EXT_texture_norm16");if(!s)return!1;const l=`#version 300 es\n    void main() {\n      gl_PointSize = ${e.toFixed(1)};\n      gl_Position = vec4(0, 0, 0, 1);\n    }\n  `,c="#version 300 es\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n\n    uniform sampler2D u_image;\n\n    out vec4 color;\n\n    void main() {\n        vec4 intColor = texture(u_image, gl_PointCoord.xy);\n        color = vec4(vec3(intColor.rrr), 1);\n    }\n    ",u=i.createShader(i.VERTEX_SHADER);if(i.shaderSource(u,l),i.compileShader(u),!i.getShaderParameter(u,i.COMPILE_STATUS))return!1;const d=i.createShader(i.FRAGMENT_SHADER);if(i.shaderSource(d,c),i.compileShader(d),!i.getShaderParameter(d,i.COMPILE_STATUS))return!1;const p=i.createProgram();if(i.attachShader(p,u),i.attachShader(p,d),i.linkProgram(p),!i.getProgramParameter(p,i.LINK_STATUS))return!1;const f=i.createTexture();i.bindTexture(i.TEXTURE_2D,f),i.texImage2D(i.TEXTURE_2D,0,s.R16_SNORM_EXT,t,n,0,i.RED,i.SHORT,r),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MAG_FILTER,i.LINEAR),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MIN_FILTER,i.LINEAR),i.useProgram(p),i.drawArrays(i.POINTS,0,1);const g=new Uint8Array(4);i.readPixels(o[0],o[1],1,1,i.RGBA,i.UNSIGNED_BYTE,g);const[m,h,v]=g,T=i.getExtension("WEBGL_lose_context");return T&&T.loseContext(),m===h&&h===v&&0!==m}catch(e){return!1}}()),Gu))return t.oglNorm16Ext};function o(e){const[t,n,r,o,a,i]=e;return[n-t+1,o-r+1,i-a+1]}function a(e){const[t,n,r]=o(e);return t*n*r}function i(e,n){const r=new((arguments.length>2&&void 0!==arguments[2]?arguments[2]:null)||e.constructor)(n.reduce(((e,t)=>e+a(t)),0)),o=[t.width,t.height,t.depth];let i=0;return n.forEach((t=>{!function(e,t,n,r,o){const[a,i,s,l,c,u]=n,[d,p]=t,f=d*p;let g=o;for(let t=c;t<=u;t++){const n=t*f;for(let t=s;t<=l;t++){const o=n+t*d;for(let t=o+a,n=o+i;t<=n;t++,g++)r[g]=e[t]}}}(e,o,t,r,i),i+=a(t)})),r}function s(e){if(t._openGLRenderWindow.getWebgl2())return e;const n=[],r=t.width,o=t.height,a=t.components;if(e&&(!Ro(r)||!Ro(o))){const i=t.context.getExtension("OES_texture_half_float"),s=Po(r),l=Po(o),c=s*l*t.components;for(let u=0;u<e.length;u++)if(null!==e[u]){let d=null;const p=o/l,f=r/s;let g=!1;t.openGLDataType===t.context.FLOAT?d=new Float32Array(c):i&&t.openGLDataType===i.HALF_FLOAT_OES?(d=new Uint16Array(c),g=!0):d=new Uint8Array(c);for(let t=0;t<l;t++){const n=t*s*a,i=t*p;let l=Math.floor(i),c=Math.ceil(i);c>=o&&(c=o-1);const m=i-l,h=1-m;l=l*r*a,c=c*r*a;for(let t=0;t<s;t++){const o=t*a,i=t*f;let s=Math.floor(i),p=Math.ceil(i);p>=r&&(p=r-1);const v=i-s;s*=a,p*=a;for(let t=0;t<a;t++)d[n+o+t]=g?ku.toHalf(ku.fromHalf(e[u][l+s+t])*h*(1-v)+ku.fromHalf(e[u][l+p+t])*h*v+ku.fromHalf(e[u][c+s+t])*m*(1-v)+ku.fromHalf(e[u][c+p+t])*m*v):e[u][l+s+t]*h*(1-v)+e[u][l+p+t]*h*v+e[u][c+s+t]*m*(1-v)+e[u][c+p+t]*m*v}}n.push(d),t.width=s,t.height=l}else n.push(null)}if(0===n.length)for(let t=0;t<e.length;t++)n.push(e[t]);return n}function l(e){return!!t._openGLRenderWindow&&(!t.resizable&&!t.renderable?.getResizable()&&(!!t._openGLRenderWindow.getWebgl2()&&(!(t._openGLRenderWindow.getGLInformations().RENDERER.value.match(/WebKit/gi)&&navigator.platform.match(/Mac/gi)&&r())||e!==Wu.UNSIGNED_SHORT&&e!==Wu.SHORT)))}function c(n,r){const o=n.getNumberOfComponents(),a=n.getDataType(),i=n.getData(),s=new Array(o),l=new Array(o);for(let e=0;e<o;++e){const[t,r]=n.getRange(e);s[e]=t,l[e]=r}const c=function(e,t,n){const r=new Array(n),o=new Array(n);for(let a=0;a<n;++a)r[a]=e[a],o[a]=t[a]-e[a]||1;return{scale:o,offset:r}}(s,l,o);return function(n,r,o,a){e.getOpenGLDataType(n);const i=function(e,t){for(let n=0;n<e.length;n++){const r=e[n],o=t[n]+r;if(r<-2048||r>2048||o<-2048||o>2048)return!1}return!0}(r,o)||a;let s=!1;if(t._openGLRenderWindow.getWebgl2())s=t.openGLDataType===t.context.FLOAT&&null===t.context.getExtension("OES_texture_float_linear")&&i||t.openGLDataType===t.context.HALF_FLOAT;else{const e=t.context.getExtension("OES_texture_half_float");s=e&&t.openGLDataType===e.HALF_FLOAT_OES}t.canUseHalfFloat=s&&i}(a,c.offset,c.scale,r),e.useHalfFloat()||e.getOpenGLDataType(a,!0),{numComps:o,dataType:a,data:i,scaleOffsets:c}}e.destroyTexture=()=>{e.deactivate(),t.context&&t.handle&&t.context.deleteTexture(t.handle),t._prevTexParams=null,t.handle=0,t.numberOfDimensions=0,t.target=0,t.components=0,t.width=0,t.height=0,t.depth=0,e.resetFormatAndType()},e.createTexture=()=>{t.handle||(t.handle=t.context.createTexture(),t.target&&(t.context.bindTexture(t.target,t.handle),t.context.texParameteri(t.target,t.context.TEXTURE_MIN_FILTER,e.getOpenGLFilterMode(t.minificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_MAG_FILTER,e.getOpenGLFilterMode(t.magnificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_S,e.getOpenGLWrapMode(t.wrapS)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_T,e.getOpenGLWrapMode(t.wrapT)),t._openGLRenderWindow.getWebgl2()&&t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_R,e.getOpenGLWrapMode(t.wrapR)),t.context.bindTexture(t.target,null)))},e.getTextureUnit=()=>t._openGLRenderWindow?t._openGLRenderWindow.getTextureUnitForTexture(e):-1,e.activate=()=>{t._openGLRenderWindow.activateTexture(e),e.bind()},e.deactivate=()=>{t._openGLRenderWindow&&t._openGLRenderWindow.deactivateTexture(e)},e.releaseGraphicsResources=n=>{n&&t.handle&&(n.activateTexture(e),n.deactivateTexture(e),t.context.deleteTexture(t.handle),t._prevTexParams=null,t.handle=0,t.numberOfDimensions=0,t.target=0,t.internalFormat=0,t.format=0,t.openGLDataType=0,t.components=0,t.width=0,t.height=0,t.depth=0,t.allocatedGPUMemoryInBytes=0),t.shaderProgram&&(t.shaderProgram.releaseGraphicsResources(n),t.shaderProgram=null)},e.bind=()=>{t.context.bindTexture(t.target,t.handle),t.autoParameters&&e.getMTime()>t.sendParametersTime.getMTime()&&e.sendParameters()},e.isBound=()=>{let e=!1;if(t.context&&t.handle){let n=0;t.target===t.context.TEXTURE_2D?n=t.context.TEXTURE_BINDING_2D:Ku("impossible case"),e=t.context.getIntegerv(n)===t.handle}return e},e.sendParameters=()=>{t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_S,e.getOpenGLWrapMode(t.wrapS)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_T,e.getOpenGLWrapMode(t.wrapT)),t._openGLRenderWindow.getWebgl2()&&t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_R,e.getOpenGLWrapMode(t.wrapR)),t.context.texParameteri(t.target,t.context.TEXTURE_MIN_FILTER,e.getOpenGLFilterMode(t.minificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_MAG_FILTER,e.getOpenGLFilterMode(t.magnificationFilter)),t._openGLRenderWindow.getWebgl2()&&(t.context.texParameteri(t.target,t.context.TEXTURE_BASE_LEVEL,t.baseLevel),t.context.texParameteri(t.target,t.context.TEXTURE_MAX_LEVEL,t.maxLevel)),t.sendParametersTime.modified()},e.getInternalFormat=(n,r)=>(t._forceInternalFormat||(t.internalFormat=e.getDefaultInternalFormat(n,r)),t.internalFormat||Hu(`Unable to find suitable internal format for T=${n} NC= ${r}`),[t.context.R32F,t.context.RG32F,t.context.RGB32F,t.context.RGBA32F].includes(t.internalFormat)&&!t.context.getExtension("OES_texture_float_linear")&&Ku("Failed to load OES_texture_float_linear. Texture filtering is not available for *32F internal formats."),t.internalFormat),e.getDefaultInternalFormat=(n,o)=>{let a=0;return a=t._openGLRenderWindow.getDefaultTextureInternalFormat(n,o,r(),e.useHalfFloat()),a||(a||(Hu("Unsupported internal texture type!"),Hu(`Unable to find suitable internal format for T=${n} NC= ${o}`)),a)},e.useHalfFloat=()=>t.enableUseHalfFloat&&t.canUseHalfFloat,e.setInternalFormat=n=>{t._forceInternalFormat=!0,n!==t.internalFormat&&(t.internalFormat=n,e.modified())},e.getFormat=(n,r)=>(t.format=e.getDefaultFormat(n,r),t.format),e.getDefaultFormat=(e,n)=>{if(t._openGLRenderWindow.getWebgl2())switch(n){case 1:return t.context.RED;case 2:return t.context.RG;case 3:default:return t.context.RGB;case 4:return t.context.RGBA}else switch(n){case 1:return t.context.LUMINANCE;case 2:return t.context.LUMINANCE_ALPHA;case 3:default:return t.context.RGB;case 4:return t.context.RGBA}},e.resetFormatAndType=()=>{t._prevTexParams=null,t.format=0,t.internalFormat=0,t._forceInternalFormat=!1,t.openGLDataType=0},e.getDefaultDataType=n=>{const o=e.useHalfFloat();if(t._openGLRenderWindow.getWebgl2())switch(n){case Wu.UNSIGNED_CHAR:return t.context.UNSIGNED_BYTE;case r()&&!o&&Wu.SHORT:return t.context.SHORT;case r()&&!o&&Wu.UNSIGNED_SHORT:return t.context.UNSIGNED_SHORT;case o&&Wu.SHORT:case o&&Wu.UNSIGNED_SHORT:return t.context.HALF_FLOAT;case Wu.FLOAT:case Wu.VOID:default:return t.context.FLOAT}switch(n){case Wu.UNSIGNED_CHAR:return t.context.UNSIGNED_BYTE;case Wu.FLOAT:case Wu.VOID:default:if(t.context.getExtension("OES_texture_float")&&t.context.getExtension("OES_texture_float_linear"))return t.context.FLOAT;{const e=t.context.getExtension("OES_texture_half_float");if(e&&t.context.getExtension("OES_texture_half_float_linear"))return e.HALF_FLOAT_OES}return t.context.UNSIGNED_BYTE}},e.getOpenGLDataType=function(n){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return t.openGLDataType&&!r||(t.openGLDataType=e.getDefaultDataType(n)),t.openGLDataType},e.getShiftAndScale=()=>{let e=0,n=1;switch(t.openGLDataType){case t.context.BYTE:n=127.5,e=n-128;break;case t.context.UNSIGNED_BYTE:n=255,e=0;break;case t.context.SHORT:n=32767.5,e=n-32768;break;case t.context.UNSIGNED_SHORT:n=65536,e=0;break;case t.context.INT:n=2147483647.5,e=n-2147483648;break;case t.context.UNSIGNED_INT:n=4294967295,e=0;case t.context.FLOAT:}return{shift:e,scale:n}},e.getOpenGLFilterMode=e=>{switch(e){case zu.NEAREST:return t.context.NEAREST;case zu.LINEAR:return t.context.LINEAR;case zu.NEAREST_MIPMAP_NEAREST:return t.context.NEAREST_MIPMAP_NEAREST;case zu.NEAREST_MIPMAP_LINEAR:return t.context.NEAREST_MIPMAP_LINEAR;case zu.LINEAR_MIPMAP_NEAREST:return t.context.LINEAR_MIPMAP_NEAREST;case zu.LINEAR_MIPMAP_LINEAR:return t.context.LINEAR_MIPMAP_LINEAR;default:return t.context.NEAREST}},e.getOpenGLWrapMode=e=>{switch(e){case Uu.CLAMP_TO_EDGE:return t.context.CLAMP_TO_EDGE;case Uu.REPEAT:return t.context.REPEAT;case Uu.MIRRORED_REPEAT:return t.context.MIRRORED_REPEAT;default:return t.context.CLAMP_TO_EDGE}},e.updateArrayDataTypeForGL=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]&&arguments[2],o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[];const a=[];let s=t.width*t.height*t.components;r&&(s*=t.depth);const l=!!o.length;if(e!==Wu.FLOAT&&t.openGLDataType===t.context.FLOAT)for(let e=0;e<n.length;e++)if(n[e])if(l)a.push(i(n[e],o,Float32Array));else{const t=n[e].length>s?n[e].subarray(0,s):n[e];a.push(new Float32Array(t))}else a.push(null);if(e!==Wu.UNSIGNED_CHAR&&t.openGLDataType===t.context.UNSIGNED_BYTE)for(let e=0;e<n.length;e++)if(n[e])if(l)a.push(i(n[e],o,Uint8Array));else{const t=n[e].length>s?n[e].subarray(0,s):n[e];a.push(new Uint8Array(t))}else a.push(null);let c=!1;if(t._openGLRenderWindow.getWebgl2())c=t.openGLDataType===t.context.HALF_FLOAT;else{const e=t.context.getExtension("OES_texture_half_float");c=e&&t.openGLDataType===e.HALF_FLOAT_OES}if(c)for(let e=0;e<n.length;e++)if(n[e]){const t=l?i(n[e],o):n[e],r=new Uint16Array(l?t.length:s),c=r.length;for(let e=0;e<c;e++)r[e]=qu(t[e]);a.push(r)}else a.push(null);if(0===a.length)for(let e=0;e<n.length;e++)a.push(l&&n[e]?i(n[e],o):n[e]);return a},e.create2DFromRaw=function(){let{width:n=$u("width"),height:o=$u("height"),numComps:a=$u("numComps"),dataType:i=$u("dataType"),data:c=$u("data"),flip:u=!1}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(e.getOpenGLDataType(i,!0),e.getInternalFormat(i,a),e.getFormat(i,a),!t.internalFormat||!t.format||!t.openGLDataType)return ju("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_2D,t.components=a,t.width=n,t.height=o,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind();const d=[c],p=s(e.updateArrayDataTypeForGL(i,d));return t.context.pixelStorei(t.context.UNPACK_FLIP_Y_WEBGL,u),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),l(i)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=p[0]&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,p[0])):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,p[0]),t.generateMipmap&&t.context.generateMipmap(t.target),u&&t.context.pixelStorei(t.context.UNPACK_FLIP_Y_WEBGL,!1),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*a*t._openGLRenderWindow.getDefaultTextureByteSize(i,r(),e.useHalfFloat()),e.deactivate(),!0},e.createCubeFromRaw=function(){let{width:n=$u("width"),height:o=$u("height"),numComps:a=$u("numComps"),dataType:i=$u("dataType"),data:c=$u("data")}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(e.getOpenGLDataType(i),e.getInternalFormat(i,a),e.getFormat(i,a),!t.internalFormat||!t.format||!t.openGLDataType)return ju("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_CUBE_MAP,t.components=a,t.width=n,t.height=o,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),t.maxLevel=c.length/6-1,e.createTexture(),e.bind();const u=s(e.updateArrayDataTypeForGL(i,c)),d=[];let p=t.width,f=t.height;for(let e=0;e<u.length;e++){e%6==0&&0!==e&&(p/=2,f/=2),d[e]=it(i,f*p*t.components);for(let n=0;n<f;++n){const r=n*p*t.components,o=(f-n-1)*p*t.components;d[e].set(u[e].slice(o,o+p*t.components),r)}}t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),l(i)&&t.context.texStorage2D(t.target,6,t.internalFormat,t.width,t.height);for(let e=0;e<6;e++){let n=0,r=t.width,o=t.height;for(;r>=1&&o>=1;){let a=null;n<=t.maxLevel&&(a=d[6*n+e]),l(i)?null!=a&&t.context.texSubImage2D(t.context.TEXTURE_CUBE_MAP_POSITIVE_X+e,n,0,0,r,o,t.format,t.openGLDataType,a):t.context.texImage2D(t.context.TEXTURE_CUBE_MAP_POSITIVE_X+e,n,t.internalFormat,r,o,0,t.format,t.openGLDataType,a),n++,r/=2,o/=2}}return t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*a*t._openGLRenderWindow.getDefaultTextureByteSize(i,r(),e.useHalfFloat()),e.deactivate(),!0},e.createDepthFromRaw=function(){let{width:n=$u("width"),height:o=$u("height"),dataType:a=$u("dataType"),data:i=$u("data")}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return e.getOpenGLDataType(a),t.format=t.context.DEPTH_COMPONENT,t._openGLRenderWindow.getWebgl2()?a===Wu.FLOAT?t.internalFormat=t.context.DEPTH_COMPONENT32F:t.internalFormat=t.context.DEPTH_COMPONENT16:t.internalFormat=t.context.DEPTH_COMPONENT,t.internalFormat&&t.format&&t.openGLDataType?(t.target=t.context.TEXTURE_2D,t.components=1,t.width=n,t.height=o,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),l(a)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=i&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,i)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,i),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(a,r(),e.useHalfFloat()),e.deactivate(),!0):(ju("Failed to determine texture parameters."),!1)},e.create2DFromImage=n=>{if(e.getOpenGLDataType(Wu.UNSIGNED_CHAR),e.getInternalFormat(Wu.UNSIGNED_CHAR,4),e.getFormat(Wu.UNSIGNED_CHAR,4),!t.internalFormat||!t.format||!t.openGLDataType)return ju("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_2D,t.components=4,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind();const o=!(t._openGLRenderWindow.getWebgl2()||Ro(n.width)&&Ro(n.height));let a=n,i=n.width,s=n.height,c=!0;const u=window.chrome;if(o||u){const e=new OffscreenCanvas(Po(n.width),Po(n.height));i=e.width,s=e.height;const t=e.getContext("2d");t.translate(0,e.height),t.scale(1,-1),t.drawImage(n,0,0,n.width,n.height,0,0,e.width,e.height),a=e,c=!1}return t.width=i,t.height=s,t.context.pixelStorei(t.context.UNPACK_FLIP_Y_WEBGL,c),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),l(Wu.UNSIGNED_CHAR)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,a)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,a),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(Wu.UNSIGNED_CHAR,r(),e.useHalfFloat()),e.deactivate(),!0},e.create2DFromImageBitmap=n=>(e.getOpenGLDataType(Wu.UNSIGNED_CHAR),e.getInternalFormat(Wu.UNSIGNED_CHAR,4),e.getFormat(Wu.UNSIGNED_CHAR,4),t.internalFormat&&t.format&&t.openGLDataType?(t.target=t.context.TEXTURE_2D,t.components=4,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),t.width=n.width,t.height=n.height,l(Wu.UNSIGNED_CHAR)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,n)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,n),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(Wu.UNSIGNED_CHAR,r(),e.useHalfFloat()),e.deactivate(),!0):(ju("Failed to determine texture parameters."),!1)),e.create2DFilterableFromRaw=function(){let{width:t=$u("width"),height:n=$u("height"),numComps:r=$u("numComps"),dataType:o=$u("dataType"),data:a=$u("data"),preferSizeOverAccuracy:i=!1,ranges:s}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return e.create2DFilterableFromDataArray({width:t,height:n,dataArray:Ts.newInstance({numComps:r,dataType:o,values:a,ranges:s}),preferSizeOverAccuracy:i})},e.create2DFilterableFromDataArray=function(){let{width:t=$u("width"),height:n=$u("height"),dataArray:r=$u("dataArray"),preferSizeOverAccuracy:o=!1}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{numComps:a,dataType:i,data:s}=c(r,o);e.create2DFromRaw({width:t,height:n,numComps:a,dataType:i,data:s})},e.updateVolumeInfoForGL=(n,o)=>{let a=!1;const i=e.useHalfFloat();t.volumeInfo?.scale&&t.volumeInfo?.offset||(t.volumeInfo={scale:new Array(o),offset:new Array(o)});for(let e=0;e<o;++e)t.volumeInfo.scale[e]=1,t.volumeInfo.offset[e]=0;if(r()&&!i&&n===Wu.SHORT){for(let e=0;e<o;++e)t.volumeInfo.scale[e]=32767;a=!0}if(r()&&!i&&n===Wu.UNSIGNED_SHORT){for(let e=0;e<o;++e)t.volumeInfo.scale[e]=65535;a=!0}if(n===Wu.UNSIGNED_CHAR){for(let e=0;e<o;++e)t.volumeInfo.scale[e]=255;a=!0}return(n===Wu.FLOAT||i&&(n===Wu.SHORT||n===Wu.UNSIGNED_SHORT))&&(a=!0),a},e.create3DFromRaw=function(){let{width:i=$u("width"),height:c=$u("height"),depth:u=$u("depth"),numComps:d=$u("numComps"),dataType:p=$u("dataType"),data:f=$u("data"),updatedExtents:g=[]}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},m=p,h=f;if(!e.updateVolumeInfoForGL(m,d)&&h){const e=i*c*u,n=structuredClone(t.volumeInfo),r=new Float32Array(e*d);t.volumeInfo.offset=n.offset,t.volumeInfo.scale=n.scale;let o=0;const a=n.scale.map((e=>1/e));for(let t=0;t<e;t++)for(let e=0;e<d;e++)r[o]=(h[o]-n.offset[e])*a[e],o++;m=Wu.FLOAT,h=r}if(e.getOpenGLDataType(m),e.getInternalFormat(m,d),e.getFormat(m,d),!t.internalFormat||!t.format||!t.openGLDataType)return ju("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_3D,t.components=d,t.width=i,t.height=c,t.depth=u,t.numberOfDimensions=3,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind();const v=g.length>0,T=!v||!ke()(t._prevTexParams,n()),y=[h],b=s(e.updateArrayDataTypeForGL(m,y,!0,T?[]:g));if(t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),T)l(m)?(t.context.texStorage3D(t.target,1,t.internalFormat,t.width,t.height,t.depth),null!=b[0]&&t.context.texSubImage3D(t.target,0,0,0,0,t.width,t.height,t.depth,t.format,t.openGLDataType,b[0])):t.context.texImage3D(t.target,0,t.internalFormat,t.width,t.height,t.depth,0,t.format,t.openGLDataType,b[0]),t._prevTexParams=n();else if(v){const e=b[0];let n=0;for(let r=0;r<g.length;r++){const i=g[r],s=o(i),l=a(i),c=new e.constructor(e.buffer,n,l);n+=c.byteLength,t.context.texSubImage3D(t.target,0,i[0],i[2],i[4],s[0],s[1],s[2],t.format,t.openGLDataType,c)}}return t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(m,r(),e.useHalfFloat()),e.deactivate(),!0},e.create3DFilterableFromRaw=function(){let{width:t=$u("width"),height:n=$u("height"),depth:r=$u("depth"),numComps:o=$u("numComps"),dataType:a=$u("dataType"),data:i=$u("data"),preferSizeOverAccuracy:s=!1,ranges:l,updatedExtents:c=[]}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return e.create3DFilterableFromDataArray({width:t,height:n,depth:r,dataArray:Ts.newInstance({numComps:o,dataType:a,values:i,ranges:l}),preferSizeOverAccuracy:s,updatedExtents:c})},e.create3DFilterableFromDataArray=function(){let{width:n=$u("width"),height:r=$u("height"),depth:o=$u("depth"),dataArray:a=$u("dataArray"),preferSizeOverAccuracy:i=!1,updatedExtents:s=[]}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{numComps:u,dataType:d,data:p,scaleOffsets:f}=c(a,i),g=[],m=[];for(let e=0;e<u;++e)g[e]=0,m[e]=1;if(t.volumeInfo={scale:m,offset:g,dataComputedScale:f.scale,dataComputedOffset:f.offset,width:n,height:r,depth:o},t._openGLRenderWindow.getWebgl2())return e.create3DFromRaw({width:n,height:r,depth:o,numComps:u,dataType:d,data:p,updatedExtents:s});const h=n*r*o,v=structuredClone(f);let T=(e,t,n,r,o)=>{e[t]=n},y=Wu.UNSIGNED_CHAR;if(d===Wu.UNSIGNED_CHAR)for(let e=0;e<u;++e)v.offset[e]=0,v.scale[e]=255;else t.context.getExtension("OES_texture_float")&&t.context.getExtension("OES_texture_float_linear")?(y=Wu.FLOAT,T=(e,t,n,r,o)=>{e[t]=(n-r)/o}):(y=Wu.UNSIGNED_CHAR,T=(e,t,n,r,o)=>{e[t]=255*(n-r)/o});if(e.getOpenGLDataType(y),e.getInternalFormat(y,u),e.getFormat(y,u),!t.internalFormat||!t.format||!t.openGLDataType)return ju("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_2D,t.components=u,t.depth=1,t.numberOfDimensions=2;let b=t.context.getParameter(t.context.MAX_TEXTURE_SIZE);b>4096&&(y===Wu.FLOAT||u>=3)&&(b=4096);let x=1,C=1;h>b*b&&(x=Math.ceil(Math.sqrt(h/(b*b))),C=x);let S=Math.sqrt(h)/x;S=Po(S);const A=Math.floor(S*x/n),I=Math.ceil(o/A),w=Po(r*I/C);let O;t.width=S,t.height=w,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.volumeInfo.xreps=A,t.volumeInfo.yreps=I,t.volumeInfo.xstride=x,t.volumeInfo.ystride=C,t.volumeInfo.offset=v.offset,t.volumeInfo.scale=v.scale;const P=S*w*u;O=y===Wu.FLOAT?new Float32Array(P):new Uint8Array(P);let R=0;const M=Math.floor(n/x),E=Math.floor(r/C);for(let e=0;e<I;e++){const a=Math.min(A,o-e*A),i=u*(t.width-a*Math.floor(n/x));for(let t=0;t<E;t++){for(let o=0;o<a;o++){const a=u*((e*A+o)*n*r+C*t*n);for(let e=0;e<M;e++)for(let t=0;t<u;t++)T(O,R,p[a+x*e*u+t],v.offset[t],v.scale[t]),R++}R+=i}}return t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),l(y)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=O&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,O)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,O),e.deactivate(),!0},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.getMaximumTextureSize=e=>e&&e.isCurrent()?e.getIntegerv(e.MAX_TEXTURE_SIZE):-1,e.enableUseHalfFloat=e=>{t.enableUseHalfFloat=e}}const Yu={_openGLRenderWindow:null,_forceInternalFormat:!1,_prevTexParams:null,context:null,handle:0,sendParametersTime:null,textureBuildTime:null,numberOfDimensions:0,target:0,format:0,openGLDataType:0,components:0,width:0,height:0,depth:0,autoParameters:!0,wrapS:Uu.CLAMP_TO_EDGE,wrapT:Uu.CLAMP_TO_EDGE,wrapR:Uu.CLAMP_TO_EDGE,minificationFilter:zu.NEAREST,magnificationFilter:zu.NEAREST,minLOD:-1e3,maxLOD:1e3,baseLevel:0,maxLevel:1e3,generateMipmap:!1,oglNorm16Ext:null,allocatedGPUMemoryInBytes:0,enableUseHalfFloat:!0,canUseHalfFloat:!1};function Zu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Yu,n),Xt.extend(e,t,n),t.sendParametersTime={},vt(t.sendParametersTime,{mtime:0}),t.textureBuildTime={},vt(t.textureBuildTime,{mtime:0}),Ct(e,t,["format","openGLDataType"]),St(e,t,["keyMatrixTime","minificationFilter","magnificationFilter","wrapS","wrapT","wrapR","generateMipmap","oglNorm16Ext"]),yt(e,t,["width","height","volumeInfo","components","handle","target","allocatedGPUMemoryInBytes"]),Ot(0,t,["openGLRenderWindow"]),Xu(e,t)}const Qu=Et(Zu,"vtkOpenGLTexture");var Ju={newInstance:Qu,extend:Zu,...Nu};en("vtkTexture",Qu);var ed="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexMC;\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n// extra lighting parameters\n//VTK::Light::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\n// picking support\n//VTK::Picking::Dec\n\nvoid main()\n{\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  //VTK::PrimID::Impl\n\n  //VTK::PositionVC::Impl\n\n  //VTK::Light::Impl\n\n  //VTK::Picking::Impl\n}\n",td="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the polydata mappers fragment shader\n\nuniform int PrimitiveIDOffset;\n\n// VC position of this fragment\n//VTK::PositionVC::Dec\n\n// optional color passed in from the vertex shader, vertexColor\n//VTK::Color::Dec\n\n// optional surface normal declaration\n//VTK::Normal::Dec\n\n// extra lighting parameters\n//VTK::Light::Dec\n\n// define vtkImageLabelOutlineOn\n//VTK::ImageLabelOutlineOn\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// Depth Peeling Support\n//VTK::DepthPeeling::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// label outline \n//VTK::LabelOutline::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\n// handle coincident offsets\n//VTK::Coincident::Dec\n\n//VTK::ZBuffer::Dec\n\n//VTK::LabelOutlineHelperFunction\n\nvoid main()\n{\n  // VC position of this fragment. This should not branch/return/discard.\n  //VTK::PositionVC::Impl\n\n  // Place any calls that require uniform flow (e.g. dFdx) here.\n  //VTK::UniformFlow::Impl\n\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\n  //VTK::Depth::Impl\n\n  // Early depth peeling abort:\n  //VTK::DepthPeeling::PreColor\n\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  //VTK::Clip::Impl\n\n  //VTK::Color::Impl\n\n  // Generate the normal if we are not passed in one\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Light::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n\n  //VTK::DepthPeeling::Impl\n\n  //VTK::Picking::Impl\n\n  // handle coincident offsets\n  //VTK::Coincident::Impl\n\n  //VTK::ZBuffer::Impl\n\n  //VTK::RenderPassFragmentShader::Impl\n}\n",nd=function(e,t){e.replaceShaderCoincidentOffset=(n,r,o)=>{const a=e.getCoincidentParameters(r,o);if(a&&(0!==a.factor||0!==a.offset)){let e=n.Fragment;e=wu.substitute(e,"//VTK::Coincident::Dec",["uniform float cfactor;","uniform float coffset;"]).result,t.context.getExtension("EXT_frag_depth")&&(0!==a.factor?(e=wu.substitute(e,"//VTK::UniformFlow::Impl",["float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));","//VTK::UniformFlow::Impl"],!1).result,e=wu.substitute(e,"//VTK::Depth::Impl","gl_FragDepthEXT = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;").result):e=wu.substitute(e,"//VTK::Depth::Impl","gl_FragDepthEXT = gl_FragCoord.z + 0.000016*coffset;").result),t._openGLRenderWindow.getWebgl2()&&(0!==a.factor?(e=wu.substitute(e,"//VTK::UniformFlow::Impl",["float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));","//VTK::UniformFlow::Impl"],!1).result,e=wu.substitute(e,"//VTK::Depth::Impl","gl_FragDepth = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;").result):e=wu.substitute(e,"//VTK::Depth::Impl","gl_FragDepth = gl_FragCoord.z + 0.000016*coffset;").result),n.Fragment=e}}},rd=function(e,t){e.applyShaderReplacements=(e,t,n)=>{let r=null;if(t&&(r=t.ShaderReplacements),r)for(let t=0;t<r.length;t++){const o=r[t];if(n&&o.replaceFirst||!n&&!o.replaceFirst){const t=o.shaderType,n=e[t],r=wu.substitute(n,o.originalValue,o.replacementValue,o.replaceAll);e[t]=r.result}}},e.buildShaders=(n,r,o)=>{e.getReplacedShaderTemplate(n,r,o),t.lastRenderPassShaderReplacement=t.currentRenderPass?t.currentRenderPass.getShaderReplacement():null,t.lastRenderPassShaderReplacement&&t.lastRenderPassShaderReplacement(n);const a=t.renderable.getViewSpecificProperties().OpenGL;e.applyShaderReplacements(n,a,!0),e.replaceShaderValues(n,r,o),e.applyShaderReplacements(n,a)},e.getReplacedShaderTemplate=(n,r,o)=>{const a=t.renderable.getViewSpecificProperties().OpenGL;e.getShaderTemplate(n,r,o);let i=n.Vertex;if(a){const e=a.VertexShaderCode;void 0!==e&&""!==e&&(i=e)}n.Vertex=i;let s=n.Fragment;if(a){const e=a.FragmentShaderCode;void 0!==e&&""!==e&&(s=e)}n.Fragment=s;let l=n.Geometry;if(a){const e=a.GeometryShaderCode;void 0!==e&&(l=e)}n.Geometry=l}};const{FieldAssociations:od}=_s,{primTypes:ad}=Du,{Representation:id,Shading:sd}=ts,{ScalarMode:ld}=Fl,{Filter:cd,Wrap:ud}=Ju,{vtkErrorMacro:dd}=jt,pd={type:"StartEvent"},fd={type:"EndEvent"},{CoordinateSystem:gd}=Wi;const md={context:null,VBOBuildTime:0,VBOBuildString:null,primitives:null,primTypes:null,shaderRebuildString:null,tmpMat4:null,ambientColor:[],diffuseColor:[],specularColor:[],lightColor:[],lightDirection:[],lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastSelectionState:xl.MIN_KNOWN_PASS-1,selectionStateChanged:null,selectionWebGLIdsToVTKIds:null,pointPicking:!1};function hd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,md,n),Xt.extend(e,t,n),nd(e,t,n),rd(e,t,n),t.primitives=[],t.primTypes=ad,t.tmpMat3=pe(new Float64Array(9)),t.tmpMat4=g(new Float64Array(16));for(let e=ad.Start;e<ad.End;e++)t.primitives[e]=Du.newInstance(),t.primitives[e].setPrimitiveType(e),t.primitives[e].set({lastLightComplexity:0,lastLightCount:0,lastSelectionPass:!1},!0);St(e,t,["context"]),t.VBOBuildTime={},vt(t.VBOBuildTime,{mtime:0}),t.selectionStateChanged={},vt(t.selectionStateChanged,{mtime:0}),function(e,t){function n(e,t,n){return t.identity(n),e.reduce(((e,n,r)=>0===r?n?t.copy(e,n):t.identity(e):n?t.multiply(e,e,n):e),n)}t.classHierarchy.push("vtkOpenGLPolyDataMapper"),e.buildPass=n=>{n&&(t.currentRenderPass=null,t.openGLActor=e.getFirstAncestorOfType("vtkOpenGLActor"),t._openGLRenderer=t.openGLActor.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()))},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.render=()=>{const n=t._openGLRenderWindow.getContext();if(t.context!==n){t.context=n;for(let e=ad.Start;e<ad.End;e++)t.primitives[e].setOpenGLRenderWindow(t._openGLRenderWindow)}const r=t.openGLActor.getRenderable(),o=t._openGLRenderer.getRenderable();e.renderPiece(o,r)},e.getShaderTemplate=(e,t,n)=>{e.Vertex=ed,e.Fragment=td,e.Geometry=""},e.replaceShaderColor=(e,n,r)=>{let o=e.Vertex,a=e.Geometry,i=e.Fragment;const s=t.lastBoundBO.getReferenceByName("lastLightComplexity");let l=["uniform float ambient;","uniform float diffuse;","uniform float specular;","uniform float opacityUniform; // the fragment opacity","uniform vec3 ambientColorUniform;","uniform vec3 diffuseColorUniform;"];s&&(l=l.concat(["uniform vec3 specularColorUniform;","uniform float specularPowerUniform;"]));let c=["vec3 ambientColor;","  vec3 diffuseColor;","  float opacity;"];s&&(c=c.concat(["  vec3 specularColor;","  float specularPower;"])),c=c.concat(["  ambientColor = ambientColorUniform;","  diffuseColor = diffuseColorUniform;","  opacity = opacityUniform;"]),s&&(c=c.concat(["  specularColor = specularColorUniform;","  specularPower = specularPowerUniform;"])),0===t.lastBoundBO.getCABO().getColorComponents()||t.drawingEdges||(l=l.concat(["varying vec4 vertexColorVSOutput;"]),o=wu.substitute(o,"//VTK::Color::Dec",["attribute vec4 scalarColor;","varying vec4 vertexColorVSOutput;"]).result,o=wu.substitute(o,"//VTK::Color::Impl",["vertexColorVSOutput =  scalarColor;"]).result,a=wu.substitute(a,"//VTK::Color::Dec",["in vec4 vertexColorVSOutput[];","out vec4 vertexColorGSOutput;"]).result,a=wu.substitute(a,"//VTK::Color::Impl",["vertexColorGSOutput = vertexColorVSOutput[i];"]).result),0===t.lastBoundBO.getCABO().getColorComponents()||t.drawingEdges?(t.renderable.getAreScalarsMappedFromCells()||t.renderable.getInterpolateScalarsBeforeMapping())&&t.renderable.getColorCoordinates()&&!t.drawingEdges?i=wu.substitute(i,"//VTK::Color::Impl",c.concat(["  vec4 texColor = texture2D(texture1, tcoordVCVSOutput.st);","  diffuseColor = texColor.rgb;","  ambientColor = texColor.rgb;","  opacity = opacity*texColor.a;"])).result:(r.getBackfaceProperty()&&!t.drawingEdges&&(l=l.concat(["uniform float opacityUniformBF; // the fragment opacity","uniform float ambientIntensityBF; // the material ambient","uniform float diffuseIntensityBF; // the material diffuse","uniform vec3 ambientColorUniformBF; // ambient material color","uniform vec3 diffuseColorUniformBF; // diffuse material color"]),s?(l=l.concat(["uniform float specularIntensityBF; // the material specular intensity","uniform vec3 specularColorUniformBF; // intensity weighted color","uniform float specularPowerUniformBF;"]),c=c.concat(["if (gl_FrontFacing == false) {","  ambientColor = ambientIntensityBF * ambientColorUniformBF;","  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;","  specularColor = specularIntensityBF * specularColorUniformBF;","  specularPower = specularPowerUniformBF;","  opacity = opacityUniformBF; }"])):c=c.concat(["if (gl_FrontFacing == false) {","  ambientColor = ambientIntensityBF * ambientColorUniformBF;","  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;","  opacity = opacityUniformBF; }"])),t.haveCellScalars&&!t.drawingEdges&&(l=l.concat(["uniform samplerBuffer texture1;"])),i=wu.substitute(i,"//VTK::Color::Impl",c).result):i=wu.substitute(i,"//VTK::Color::Impl",c.concat(["  diffuseColor = vertexColorVSOutput.rgb;","  ambientColor = vertexColorVSOutput.rgb;","  opacity = opacity*vertexColorVSOutput.a;"])).result,i=wu.substitute(i,"//VTK::Color::Dec",l).result,e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderLight=(e,n,r)=>{let o=e.Fragment;const a=t.lastBoundBO.getReferenceByName("lastLightComplexity"),i=t.lastBoundBO.getReferenceByName("lastLightCount");let s=[];switch(a){case 0:o=wu.substitute(o,"//VTK::Light::Impl",["  gl_FragData[0] = vec4(ambientColor * ambient + diffuseColor * diffuse, opacity);","  //VTK::Light::Impl"],!1).result;break;case 1:o=wu.substitute(o,"//VTK::Light::Impl",["  float df = max(0.0, normalVCVSOutput.z);","  float sf = pow(df, specularPower);","  vec3 diffuseL = df * diffuseColor;","  vec3 specularL = sf * specularColor;","  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);","  //VTK::Light::Impl"],!1).result;break;case 2:for(let e=0;e<i;++e)s=s.concat([`uniform vec3 lightColor${e};`,`uniform vec3 lightDirectionVC${e}; // normalized`,`uniform vec3 lightHalfAngleVC${e}; // normalized`]);o=wu.substitute(o,"//VTK::Light::Dec",s).result,s=["vec3 diffuseL = vec3(0,0,0);","  vec3 specularL = vec3(0,0,0);","  float df;"];for(let e=0;e<i;++e)s=s.concat([`  df = max(0.0, dot(normalVCVSOutput, -lightDirectionVC${e}));`,`  diffuseL += ((df) * lightColor${e});`,`  if (dot(normalVCVSOutput, lightDirectionVC${e}) < 0.0)`,"    {",`    float sf = sign(df)*pow(max(1e-5,\n                                              dot(reflect(lightDirectionVC${e},normalVCVSOutput),\n                                                  normalize(-vertexVC.xyz))),\n                                         specularPower);`,`    specularL += (sf * lightColor${e});`,"    }"]);s=s.concat(["  diffuseL = diffuseL * diffuseColor;","  specularL = specularL * specularColor;","  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);","  //VTK::Light::Impl"]),o=wu.substitute(o,"//VTK::Light::Impl",s,!1).result;break;case 3:for(let e=0;e<i;++e)s=s.concat([`uniform vec3 lightColor${e};`,`uniform vec3 lightDirectionVC${e}; // normalized`,`uniform vec3 lightHalfAngleVC${e}; // normalized`,`uniform vec3 lightPositionVC${e};`,`uniform vec3 lightAttenuation${e};`,`uniform float lightConeAngle${e};`,`uniform float lightExponent${e};`,`uniform int lightPositional${e};`]);o=wu.substitute(o,"//VTK::Light::Dec",s).result,s=["vec3 diffuseL = vec3(0,0,0);","  vec3 specularL = vec3(0,0,0);","  vec3 vertLightDirectionVC;","  float attenuation;","  float df;"];for(let e=0;e<i;++e)s=s.concat(["  attenuation = 1.0;",`  if (lightPositional${e} == 0)`,"    {",`      vertLightDirectionVC = lightDirectionVC${e};`,"    }","  else","    {",`    vertLightDirectionVC = vertexVC.xyz - lightPositionVC${e};`,"    float distanceVC = length(vertLightDirectionVC);","    vertLightDirectionVC = normalize(vertLightDirectionVC);","    attenuation = 1.0 /",`      (lightAttenuation${e}.x`,`       + lightAttenuation${e}.y * distanceVC`,`       + lightAttenuation${e}.z * distanceVC * distanceVC);`,"    // per OpenGL standard cone angle is 90 or less for a spot light",`    if (lightConeAngle${e} <= 90.0)`,"      {",`      float coneDot = dot(vertLightDirectionVC, lightDirectionVC${e});`,"      // if inside the cone",`      if (coneDot >= cos(radians(lightConeAngle${e})))`,"        {",`        attenuation = attenuation * pow(coneDot, lightExponent${e});`,"        }","      else","        {","        attenuation = 0.0;","        }","      }","    }","    df = max(0.0, attenuation*dot(normalVCVSOutput, -vertLightDirectionVC));",`    diffuseL += ((df) * lightColor${e});`,"    if (dot(normalVCVSOutput, vertLightDirectionVC) < 0.0)","      {",`      float sf = sign(df)*attenuation*pow(max(1e-5,\n                                                           dot(reflect(lightDirectionVC${e},\n                                                                       normalVCVSOutput),\n                                                               normalize(-vertexVC.xyz))),\n                                                       specularPower);`,`    specularL += ((sf) * lightColor${e});`,"    }"]);s=s.concat(["  diffuseL = diffuseL * diffuseColor;","  specularL = specularL * specularColor;","  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);","  //VTK::Light::Impl"]),o=wu.substitute(o,"//VTK::Light::Impl",s,!1).result;break;default:dd("bad light complexity")}e.Fragment=o},e.replaceShaderNormal=(e,n,r)=>{if(t.lastBoundBO.getReferenceByName("lastLightComplexity")>0){let n=e.Vertex,o=e.Geometry,a=e.Fragment;t.lastBoundBO.getCABO().getNormalOffset()?(n=wu.substitute(n,"//VTK::Normal::Dec",["attribute vec3 normalMC;","uniform mat3 normalMatrix;","varying vec3 normalVCVSOutput;"]).result,n=wu.substitute(n,"//VTK::Normal::Impl",["normalVCVSOutput = normalMatrix * normalMC;"]).result,o=wu.substitute(o,"//VTK::Normal::Dec",["in vec3 normalVCVSOutput[];","out vec3 normalVCGSOutput;"]).result,o=wu.substitute(o,"//VTK::Normal::Impl",["normalVCGSOutput = normalVCVSOutput[i];"]).result,a=wu.substitute(a,"//VTK::Normal::Dec",["varying vec3 normalVCVSOutput;"]).result,a=wu.substitute(a,"//VTK::Normal::Impl",["vec3 normalVCVSOutput = normalize(normalVCVSOutput);","  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }"]).result):t.haveCellNormals?(a=wu.substitute(a,"//VTK::Normal::Dec",["uniform mat3 normalMatrix;","uniform samplerBuffer textureN;"]).result,a=wu.substitute(a,"//VTK::Normal::Impl",["vec3 normalVCVSOutput = normalize(normalMatrix *","    texelFetchBuffer(textureN, gl_PrimitiveID + PrimitiveIDOffset).xyz);","  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }"]).result):t.lastBoundBO.getOpenGLMode(r.getProperty().getRepresentation())===t.context.LINES?(a=wu.substitute(a,"//VTK::UniformFlow::Impl",["  vec3 fdx = dFdx(vertexVC.xyz);","  vec3 fdy = dFdy(vertexVC.xyz);","  //VTK::UniformFlow::Impl"]).result,a=wu.substitute(a,"//VTK::Normal::Impl",["vec3 normalVCVSOutput;","  if (abs(fdx.x) > 0.0)","    { fdx = normalize(fdx); normalVCVSOutput = normalize(cross(vec3(fdx.y, -fdx.x, 0.0), fdx)); }","  else { fdy = normalize(fdy); normalVCVSOutput = normalize(cross(vec3(fdy.y, -fdy.x, 0.0), fdy));}"]).result):(a=wu.substitute(a,"//VTK::Normal::Dec",["uniform int cameraParallel;"]).result,a=wu.substitute(a,"//VTK::UniformFlow::Impl",["  vec3 fdx = dFdx(vertexVC.xyz);","  vec3 fdy = dFdy(vertexVC.xyz);","  //VTK::UniformFlow::Impl"]).result,a=wu.substitute(a,"//VTK::Normal::Impl",["  fdx = normalize(fdx);","  fdy = normalize(fdy);","  vec3 normalVCVSOutput = normalize(cross(fdx,fdy));","  if (cameraParallel == 1 && normalVCVSOutput.z < 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }","  if (cameraParallel == 0 && dot(normalVCVSOutput,vertexVC.xyz) > 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }"]).result),e.Vertex=n,e.Geometry=o,e.Fragment=a}},e.replaceShaderPositionVC=(e,n,r)=>{t.lastBoundBO.replaceShaderPositionVC(e,n,r);let o=e.Vertex,a=e.Geometry,i=e.Fragment;t.lastBoundBO.getReferenceByName("lastLightComplexity")>0?(o=wu.substitute(o,"//VTK::PositionVC::Dec",["varying vec4 vertexVCVSOutput;"]).result,o=wu.substitute(o,"//VTK::PositionVC::Impl",["vertexVCVSOutput = MCVCMatrix * vertexMC;","  gl_Position = MCPCMatrix * vertexMC;"]).result,o=wu.substitute(o,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;","uniform mat4 MCVCMatrix;"]).result,a=wu.substitute(a,"//VTK::PositionVC::Dec",["in vec4 vertexVCVSOutput[];","out vec4 vertexVCGSOutput;"]).result,a=wu.substitute(a,"//VTK::PositionVC::Impl",["vertexVCGSOutput = vertexVCVSOutput[i];"]).result,i=wu.substitute(i,"//VTK::PositionVC::Dec",["varying vec4 vertexVCVSOutput;"]).result,i=wu.substitute(i,"//VTK::PositionVC::Impl",["vec4 vertexVC = vertexVCVSOutput;"]).result):(o=wu.substitute(o,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;"]).result,o=wu.substitute(o,"//VTK::PositionVC::Impl",["  gl_Position = MCPCMatrix * vertexMC;"]).result),e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderTCoord=(e,n,r)=>{if(t.lastBoundBO.getCABO().getTCoordOffset()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;if(t.drawingEdges)return;n=wu.substitute(n,"//VTK::TCoord::Impl","tcoordVCVSOutput = tcoordMC;").result;const a=t.openGLActor.getActiveTextures();let i=2,s=2;if(a&&a.length>0&&(i=a[0].getComponents(),a[0].getTarget()===t.context.TEXTURE_CUBE_MAP&&(s=3)),t.renderable.getColorTextureMap()&&(i=t.renderable.getColorTextureMap().getPointData().getScalars().getNumberOfComponents(),s=2),2===s){if(n=wu.substitute(n,"//VTK::TCoord::Dec","attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;").result,r=wu.substitute(r,"//VTK::TCoord::Dec",["in vec2 tcoordVCVSOutput[];","out vec2 tcoordVCGSOutput;"]).result,r=wu.substitute(r,"//VTK::TCoord::Impl","tcoordVCGSOutput = tcoordVCVSOutput[i];").result,o=wu.substitute(o,"//VTK::TCoord::Dec",["varying vec2 tcoordVCVSOutput;","uniform sampler2D texture1;"]).result,a&&a.length>=1)switch(i){case 1:o=wu.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;"]).result;break;case 2:o=wu.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;","  opacity = opacity * tcolor.g;"]).result;break;default:o=wu.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.rgb;","  diffuseColor = diffuseColor*tcolor.rgb;","  opacity = opacity * tcolor.a;"]).result}}else switch(n=wu.substitute(n,"//VTK::TCoord::Dec","attribute vec3 tcoordMC; varying vec3 tcoordVCVSOutput;").result,r=wu.substitute(r,"//VTK::TCoord::Dec",["in vec3 tcoordVCVSOutput[];","out vec3 tcoordVCGSOutput;"]).result,r=wu.substitute(r,"//VTK::TCoord::Impl","tcoordVCGSOutput = tcoordVCVSOutput[i];").result,o=wu.substitute(o,"//VTK::TCoord::Dec",["varying vec3 tcoordVCVSOutput;","uniform samplerCube texture1;"]).result,i){case 1:o=wu.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;"]).result;break;case 2:o=wu.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;","  opacity = opacity * tcolor.g;"]).result;break;default:o=wu.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.rgb;","  diffuseColor = diffuseColor*tcolor.rgb;","  opacity = opacity * tcolor.a;"]).result}e.Vertex=n,e.Geometry=r,e.Fragment=o}},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){const e=t.renderable.getNumberOfClippingPlanes();o=wu.substitute(o,"//VTK::Clip::Dec",["uniform int numClipPlanes;",`uniform vec4 clipPlanes[${e}];`,`varying float clipDistancesVSOutput[${e}];`]).result,o=wu.substitute(o,"//VTK::Clip::Impl",[`for (int planeNum = 0; planeNum < ${e}; planeNum++)`,"    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);","    }"]).result,a=wu.substitute(a,"//VTK::Clip::Dec",["uniform int numClipPlanes;",`varying float clipDistancesVSOutput[${e}];`]).result,a=wu.substitute(a,"//VTK::Clip::Impl",[`for (int planeNum = 0; planeNum < ${e}; planeNum++)`,"    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    if (clipDistancesVSOutput[planeNum] < 0.0) discard;","    }"]).result}e.Vertex=o,e.Fragment=a},e.getCoincidentParameters=(e,n)=>{let r={factor:0,offset:0};const o=n.getProperty();if(t.renderable.getResolveCoincidentTopology()==dl.PolygonOffset||o.getEdgeVisibility()&&o.getRepresentation()===id.SURFACE){const e=t.lastBoundBO.getPrimitiveType();e===ad.Points||o.getRepresentation()===id.POINTS?r=t.renderable.getCoincidentTopologyPointOffsetParameter():e===ad.Lines||o.getRepresentation()===id.WIREFRAME?r=t.renderable.getCoincidentTopologyLineOffsetParameters():e!==ad.Tris&&e!==ad.TriStrips||(r=t.renderable.getCoincidentTopologyPolygonOffsetParameters()),e!==ad.TrisEdges&&e!==ad.TriStripsEdges||(r=t.renderable.getCoincidentTopologyPolygonOffsetParameters(),r.factor/=2,r.offset/=2)}const a=t._openGLRenderer.getSelector();return a&&a.getFieldAssociation()===od.FIELD_ASSOCIATION_POINTS&&(r.offset-=2),r},e.replaceShaderPicking=(e,n,r)=>{let o=e.Fragment,a=e.Vertex;if(o=wu.substitute(o,"//VTK::Picking::Dec",["uniform int picking;","//VTK::Picking::Dec"]).result,t._openGLRenderer.getSelector()){switch(t.lastSelectionState!==xl.ID_LOW24&&t.lastSelectionState!==xl.ID_HIGH24||(a=wu.substitute(a,"//VTK::Picking::Dec",["flat out int vertexIDVSOutput;\n","uniform int VertexIDOffset;\n"]).result,a=wu.substitute(a,"//VTK::Picking::Impl","  vertexIDVSOutput = gl_VertexID + VertexIDOffset;\n").result,o=wu.substitute(o,"//VTK::Picking::Dec","flat in int vertexIDVSOutput;\n").result,o=wu.substitute(o,"//VTK::Picking::Impl",["  int idx = vertexIDVSOutput;","//VTK::Picking::Impl"]).result),t.lastSelectionState){case xl.ID_LOW24:o=wu.substitute(o,"//VTK::Picking::Impl","  gl_FragData[0] = vec4(float(idx%256)/255.0, float((idx/256)%256)/255.0, float((idx/65536)%256)/255.0, 1.0);").result;break;case xl.ID_HIGH24:o=wu.substitute(o,"//VTK::Picking::Impl","  gl_FragData[0] = vec4(float((idx/16777216)%256)/255.0, 0.0, 0.0, 1.0);").result;break;default:o=wu.substitute(o,"//VTK::Picking::Dec","uniform vec3 mapperIndex;").result,o=wu.substitute(o,"//VTK::Picking::Impl","  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];").result}e.Fragment=o,e.Vertex=a}},e.replaceShaderValues=(n,r,o)=>{if(e.replaceShaderColor(n,r,o),e.replaceShaderNormal(n,r,o),e.replaceShaderLight(n,r,o),e.replaceShaderTCoord(n,r,o),e.replaceShaderPicking(n,r,o),e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o),e.replaceShaderPositionVC(n,r,o),t.haveSeenDepthRequest){let e=n.Fragment;e=wu.substitute(e,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,e=wu.substitute(e,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result,n.Fragment=e}},e.getNeedToRebuildShaders=(e,n,r)=>{let o=0,a=0;const i=e.getPrimitiveType(),s=t.currentInput;let l=!1;const c=s.getPointData().getNormals(),u=s.getCellData().getNormals(),d=r.getProperty().getInterpolation()===sd.FLAT,p=r.getProperty().getRepresentation(),f=e.getOpenGLMode(p,i);if(f===t.context.TRIANGLES||u&&!c||!d&&c?l=!0:d||f!==t.context.LINES||(l=!0),r.getProperty().getLighting()&&l){o=0;const e=n.getLightsByReference();for(let t=0;t<e.length;++t){const n=e[t];n.getSwitch()>0&&(a++,0===o&&(o=1)),1===o&&(a>1||1!==n.getIntensity()||!n.lightTypeIsHeadLight())&&(o=2),o<3&&n.getPositional()&&(o=3)}}let g=!1;const m=t.lastBoundBO.getReferenceByName("lastLightComplexity"),h=t.lastBoundBO.getReferenceByName("lastLightCount");return m===o&&h===a||(t.lastBoundBO.set({lastLightComplexity:o},!0),t.lastBoundBO.set({lastLightCount:a},!0),g=!0),(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(g=!0),!!(t.lastHaveSeenDepthRequest!==t.haveSeenDepthRequest||e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime()||e.getShaderSourceTime().getMTime()<t.selectionStateChanged.getMTime()||g)&&(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,!0)},e.invokeShaderCallbacks=(e,n,r)=>{const o=t.renderable.getViewSpecificProperties().ShadersCallbacks;o&&o.forEach((t=>{t.callback(t.userData,e,n,r)}))},e.setMapperShaderParameters=(n,r,o)=>{if(n.getProgram().isUniformUsed("PrimitiveIDOffset")&&n.getProgram().setUniformi("PrimitiveIDOffset",t.primitiveIDOffset),n.getProgram().isUniformUsed("VertexIDOffset")&&n.getProgram().setUniformi("VertexIDOffset",t.vertexIDOffset),n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())){const e=t.lastBoundBO.getReferenceByName("lastLightComplexity");n.getProgram().isAttributeUsed("vertexMC")&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"vertexMC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,!1)||dd("Error setting vertexMC in shader VAO.")),n.getProgram().isAttributeUsed("normalMC")&&n.getCABO().getNormalOffset()&&e>0?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"normalMC",n.getCABO().getNormalOffset(),n.getCABO().getStride(),t.context.FLOAT,3,!1)||dd("Error setting normalMC in shader VAO."):n.getVAO().removeAttributeArray("normalMC"),t.renderable.getCustomShaderAttributes().forEach(((e,r)=>{n.getProgram().isAttributeUsed(`${e}MC`)&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),`${e}MC`,n.getCABO().getCustomData()[r].offset,n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getCustomData()[r].components,!1)||dd(`Error setting ${e}MC in shader VAO.`))})),n.getProgram().isAttributeUsed("tcoordMC")&&n.getCABO().getTCoordOffset()?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"tcoordMC",n.getCABO().getTCoordOffset(),n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getTCoordComponents(),!1)||dd("Error setting tcoordMC in shader VAO."):n.getVAO().removeAttributeArray("tcoordMC"),n.getProgram().isAttributeUsed("scalarColor")&&n.getCABO().getColorComponents()?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO().getColorBO(),"scalarColor",n.getCABO().getColorOffset(),n.getCABO().getColorBOStride(),t.context.UNSIGNED_BYTE,4,!0)||dd("Error setting scalarColor in shader VAO."):n.getVAO().removeAttributeArray("scalarColor"),n.getAttributeUpdateTime().modified()}if(t.renderable.getNumberOfClippingPlanes()){const e=t.renderable.getNumberOfClippingPlanes(),r=[],a=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null,i=a?d(t.tmpMat4,o.getMatrix()):o.getMatrix();a&&(m(i,i),y(i,i,a),m(i,i));for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(i,n,e);for(let t=0;t<4;t++)r.push(e[t])}n.getProgram().setUniformi("numClipPlanes",e),n.getProgram().setUniform4fv("clipPlanes",r)}t.internalColorTexture&&n.getProgram().isUniformUsed("texture1")&&n.getProgram().setUniformi("texture1",t.internalColorTexture.getTextureUnit());const a=t.openGLActor.getActiveTextures();if(a)for(let e=0;e<a.length;++e){const t=a[e].getTextureUnit(),r=`texture${t+1}`;n.getProgram().isUniformUsed(r)&&n.getProgram().setUniformi(r,t)}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",t.renderDepth?1:0),n.getProgram().isUniformUsed("coffset")){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf("coffset",t.offset),n.getProgram().isUniformUsed("cfactor")&&n.getProgram().setUniformf("cfactor",t.factor)}n.setMapperShaderParameters(r,o,t._openGLRenderer.getTiledSizeAndOrigin());const i=t._openGLRenderer.getSelector();n.getProgram().setUniform3fArray("mapperIndex",i?i.getPropColorValue():[0,0,0]),n.getProgram().setUniformi("picking",i?i.getCurrentPass()+1:0)},e.setLightingShaderParameters=(e,n,r)=>{const o=t.lastBoundBO.getReferenceByName("lastLightComplexity");if(o<2)return;const a=e.getProgram();let i=0;const s=n.getLightsByReference();for(let e=0;e<s.length;++e){const r=s[e];if(r.getSwitch()>0){const e=r.getColorByReference(),o=r.getIntensity();t.lightColor[0]=e[0]*o,t.lightColor[1]=e[1]*o,t.lightColor[2]=e[2]*o;const s=r.getDirection(),l=n.getActiveCamera().getViewMatrix(),c=[...s];r.lightTypeIsSceneLight()&&(c[0]=l[0]*s[0]+l[1]*s[1]+l[2]*s[2],c[1]=l[4]*s[0]+l[5]*s[1]+l[6]*s[2],c[2]=l[8]*s[0]+l[9]*s[1]+l[10]*s[2],ko(c)),t.lightDirection[0]=c[0],t.lightDirection[1]=c[1],t.lightDirection[2]=c[2],ko(t.lightDirection),a.setUniform3fArray(`lightColor${i}`,t.lightColor),a.setUniform3fArray(`lightDirectionVC${i}`,t.lightDirection),i++}}if(o<3)return;const l=n.getActiveCamera().getViewMatrix();m(l,l),i=0;for(let e=0;e<s.length;++e){const t=s[e];if(t.getSwitch()>0){const e=t.getTransformedPosition(),n=new Float64Array(3);wn(n,e,l),a.setUniform3fArray(`lightAttenuation${i}`,t.getAttenuationValuesByReference()),a.setUniformi(`lightPositional${i}`,t.getPositional()),a.setUniformf(`lightExponent${i}`,t.getExponent()),a.setUniformf(`lightConeAngle${i}`,t.getConeAngle()),a.setUniform3fArray(`lightPositionVC${i}`,[n[0],n[1],n[2]]),i++}}},e.setCameraShaderParameters=(e,a,i)=>{const s=e.getProgram(),l=t.openGLCamera.getKeyMatrices(a),c=a.getActiveCamera(),u=t.openGLCamera.getKeyMatrixTime().getMTime(),d=s.getLastCameraMTime(),p=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,f=i.getIsIdentity(),m=f?{mcwc:null,normalMatrix:null}:t.openGLActor.getKeyMatrices();if(i.getCoordinateSystem()===gd.DISPLAY){const e=t._openGLRenderer.getTiledSizeAndOrigin();g(t.tmpMat4),t.tmpMat4[0]=2/e.usize,t.tmpMat4[12]=-1,t.tmpMat4[5]=2/e.vsize,t.tmpMat4[13]=-1,y(t.tmpMat4,t.tmpMat4,p),s.setUniformMatrix("MCPCMatrix",t.tmpMat4)}else s.setUniformMatrix("MCPCMatrix",n([l.wcpc,m.mcwc,p],r,t.tmpMat4));s.isUniformUsed("MCVCMatrix")&&s.setUniformMatrix("MCVCMatrix",n([l.wcvc,m.mcwc,p],r,t.tmpMat4)),s.isUniformUsed("normalMatrix")&&s.setUniformMatrix3x3("normalMatrix",n([l.normalMatrix,m.normalMatrix],o,t.tmpMat3)),d!==u&&(s.isUniformUsed("cameraParallel")&&s.setUniformi("cameraParallel",c.getParallelProjection()),s.setLastCameraMTime(u)),f||s.setLastCameraMTime(0)},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram();let a=r.getProperty(),i=a.getOpacity(),s=t.drawingEdges?a.getEdgeColorByReference():a.getAmbientColorByReference(),l=t.drawingEdges?a.getEdgeColorByReference():a.getDiffuseColorByReference(),c=t.drawingEdges?1:a.getAmbient(),u=t.drawingEdges?0:a.getDiffuse(),d=t.drawingEdges?0:a.getSpecular();const p=a.getSpecularPower();o.setUniformf("opacityUniform",i),o.setUniform3fArray("ambientColorUniform",s),o.setUniform3fArray("diffuseColorUniform",l),o.setUniformf("ambient",c),o.setUniformf("diffuse",u);const f=t.lastBoundBO.getReferenceByName("lastLightComplexity");if(f<1)return;let g=a.getSpecularColorByReference();if(o.setUniform3fArray("specularColorUniform",g),o.setUniformf("specularPowerUniform",p),o.setUniformf("specular",d),o.isUniformUsed("ambientIntensityBF")){if(a=r.getBackfaceProperty(),i=a.getOpacity(),s=a.getAmbientColor(),c=a.getAmbient(),l=a.getDiffuseColor(),u=a.getDiffuse(),g=a.getSpecularColor(),d=a.getSpecular(),o.setUniformf("ambientIntensityBF",c),o.setUniformf("diffuseIntensityBF",u),o.setUniformf("opacityUniformBF",i),o.setUniform3fArray("ambientColorUniformBF",s),o.setUniform3fArray("diffuseColorUniformBF",l),f<1)return;o.setUniformf("specularIntensityBF",d),o.setUniform3fArray("specularColorUniformBF",g),o.setUniformf("specularPowerUniformBF",p)}},e.updateMaximumPointCellIds=(e,n)=>{const r=t._openGLRenderer.getSelector();if(r){if(t.selectionWebGLIdsToVTKIds?.points?.length){const e=t.selectionWebGLIdsToVTKIds.points.length;r.setMaximumPointId(e-1)}if(t.selectionWebGLIdsToVTKIds?.cells?.length){const e=t.selectionWebGLIdsToVTKIds.cells.length;r.setMaximumCellId(e-1)}r.getFieldAssociation()===od.FIELD_ASSOCIATION_POINTS&&(t.pointPicking=!0)}},e.renderPieceStart=(n,r)=>{t.primitiveIDOffset=0,t.vertexIDOffset=0;const o=function(e){const t=e.getSelector();return t?t.getCurrentPass():xl.MIN_KNOWN_PASS-1}(t._openGLRenderer);t.lastSelectionState!==o&&(t.selectionStateChanged.modified(),t.lastSelectionState=o),t._openGLRenderer.getSelector()&&t._openGLRenderer.getSelector().renderProp(r),e.updateBufferObjects(n,r),t.renderable.getColorTextureMap()&&t.internalColorTexture.activate(),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation(),a=r.getProperty().getEdgeVisibility()&&o===id.SURFACE,i=t._openGLRenderer.getSelector(),s=i&&i.getFieldAssociation()===od.FIELD_ASSOCIATION_POINTS&&(t.lastSelectionState===xl.ID_LOW24||t.lastSelectionState===xl.ID_HIGH24);for(let i=ad.Start;i<ad.End;i++)t.primitives[i].setPointPicking(s),t.primitives[i].getCABO().getElementCount()&&(t.drawingEdges=a&&(i===ad.TrisEdges||i===ad.TriStripsEdges),t.drawingEdges&&(t.renderDepth||t.lastSelectionState>=0)||(t.lastBoundBO=t.primitives[i],t.primitiveIDOffset+=t.primitives[i].drawArrays(n,r,o,e),t.vertexIDOffset+=t.primitives[i].getCABO().getElementCount()))},e.renderPieceFinish=(e,n)=>{t.LastBoundBO&&t.LastBoundBO.getVAO().release(),t.renderable.getColorTextureMap()&&t.internalColorTexture.deactivate()},e.renderPiece=(n,r)=>{if(e.invokeEvent(pd),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent(fd),!t.currentInput)return void dd("No input!");if(!t.currentInput.getPoints||!t.currentInput.getPoints().getNumberOfValues())return;const o=t.context,a=r.getProperty().getBackfaceCulling(),i=r.getProperty().getFrontfaceCulling();a||i?i?(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.FRONT)):(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.BACK)):t._openGLRenderWindow.disableCullFace(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n),e.updateMaximumPointCellIds()},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return o<e.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentInput.getMTime()},e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors();t.haveCellScalars=!1;const a=t.renderable.getScalarMode();t.renderable.getScalarVisibility()&&(a!==ld.USE_CELL_DATA&&a!==ld.USE_CELL_FIELD_DATA&&a!==ld.USE_FIELD_DATA&&r.getPointData().getScalars()||a===ld.USE_POINT_FIELD_DATA||!o||(t.haveCellScalars=!0));let i=n.getProperty().getInterpolation()!==sd.FLAT?r.getPointData().getNormals():null;null===i&&r.getCellData().getNormals()&&(t.haveCellNormals=!0,i=r.getCellData().getNormals());const s=n.getProperty().getRepresentation();let l=r.getPointData().getTCoords();t.openGLActor.getActiveTextures()||(l=null);let c=!1;if(t.renderable.getColorCoordinates()){l=t.renderable.getColorCoordinates(),c=t.renderable.getAreScalarsMappedFromCells(),t.internalColorTexture||(t.internalColorTexture=Ju.newInstance({resizable:!0}));const e=t.internalColorTexture;e.setMinificationFilter(cd.NEAREST),e.setMagnificationFilter(cd.NEAREST),e.setWrapS(ud.CLAMP_TO_EDGE),e.setWrapT(ud.CLAMP_TO_EDGE),e.setOpenGLRenderWindow(t._openGLRenderWindow);const n=t.renderable.getColorTextureMap(),r=n.getExtent(),o=n.getPointData().getScalars();e.create2DFromRaw({width:r[1]-r[0]+1,height:r[3]-r[2]+1,numComps:o.getNumberOfComponents(),dataType:o.getDataType(),data:o.getData()}),e.activate(),e.sendParameters(),e.deactivate()}const u=`${r.getMTime()}A${s}B${r.getMTime()}C${i?i.getMTime():1}D${o?o.getMTime():1}E${n.getProperty().getEdgeVisibility()}F${l?l.getMTime():1}`;if(t.VBOBuildString!==u){const e={points:r.getPoints(),normals:i,tcoords:l,colors:o,cellOffset:0,vertexOffset:0,useTCoordsPerCell:c,haveCellScalars:t.haveCellScalars,haveCellNormals:t.haveCellNormals,customAttributes:t.renderable.getCustomShaderAttributes().map((e=>r.getPointData().getArrayByName(e)))};t.renderable.getPopulateSelectionSettings()&&(t.selectionWebGLIdsToVTKIds={points:null,cells:null});const a=[{inRep:"verts",cells:r.getVerts()},{inRep:"lines",cells:r.getLines()},{inRep:"polys",cells:r.getPolys()},{inRep:"strips",cells:r.getStrips()},{inRep:"polys",cells:r.getPolys()},{inRep:"strips",cells:r.getStrips()}],d=n.getProperty().getEdgeVisibility()&&s===id.SURFACE;for(let n=ad.Start;n<ad.End;n++)n!==ad.TrisEdges&&n!==ad.TriStripsEdges?(e.cellOffset+=t.primitives[n].getCABO().createVBO(a[n].cells,a[n].inRep,s,e,t.selectionWebGLIdsToVTKIds),e.vertexOffset+=t.primitives[n].getCABO().getElementCount()):d?t.primitives[n].getCABO().createVBO(a[n].cells,a[n].inRep,id.WIREFRAME,{...e,tcoords:null,colors:null,haveCellScalars:!1,haveCellNormals:!1}):t.primitives[n].releaseGraphicsResources();t.renderable.getPopulateSelectionSettings()&&t.renderable.setSelectionWebGLIdsToVTKIds(t.selectionWebGLIdsToVTKIds),t.VBOBuildString=u}t.VBOBuildTime.modified()},e.getAllocatedGPUMemoryInBytes=()=>{let e=0;return t.primitives.forEach((t=>{e+=t.getAllocatedGPUMemoryInBytes()})),e}}(e,t)}const vd=Et(hd,"vtkOpenGLPolyDataMapper");var Td={newInstance:vd,extend:hd};en("vtkMapper",vd);const{ColorMode:yd,ScalarMode:bd,GetArray:xd}=Xs,Cd={static:!1,lookupTable:null,scalarVisibility:!1,scalarRange:[0,1],useLookupTableScalarRange:!1,colorMode:0,scalarMode:0,arrayAccessMode:1,renderTime:0,colorByArrayName:null,transformCoordinate:null,viewSpecificProperties:null,customShaderAttributes:[]};function Sd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Cd,n),bs(e,t,n),Ht.get(e,t,["colorMapColors"]),Ht.setGet(e,t,["arrayAccessMode","colorByArrayName","colorMode","lookupTable","renderTime","scalarMode","scalarVisibility","static","transformCoordinate","useLookupTableScalarRange","viewSpecificProperties","customShaderAttributes"]),Ht.setGetArray(e,t,["scalarRange"],2),t.viewSpecificProperties||(t.viewSpecificProperties={}),function(e,t){t.classHierarchy.push("vtkMapper2D"),e.createDefaultLookupTable=()=>{t.lookupTable=ul.newInstance()},e.getColorModeAsString=()=>Ht.enumToString(yd,t.colorMode),e.setColorModeToDefault=()=>e.setColorMode(0),e.setColorModeToMapScalars=()=>e.setColorMode(1),e.setColorModeToDirectScalars=()=>e.setColorMode(2),e.getScalarModeAsString=()=>Ht.enumToString(bd,t.scalarMode),e.setScalarModeToDefault=()=>e.setScalarMode(0),e.setScalarModeToUsePointData=()=>e.setScalarMode(1),e.setScalarModeToUseCellData=()=>e.setScalarMode(2),e.setScalarModeToUsePointFieldData=()=>e.setScalarMode(3),e.setScalarModeToUseCellFieldData=()=>e.setScalarMode(4),e.setScalarModeToUseFieldData=()=>e.setScalarMode(5),e.getAbstractScalars=(e,n,r,o,a)=>{if(!e||!t.scalarVisibility)return{scalars:null,cellFLag:!1};let i=null,s=!1;if(n===bd.DEFAULT)i=e.getPointData().getScalars(),i||(i=e.getCellData().getScalars(),s=!0);else if(n===bd.USE_POINT_DATA)i=e.getPointData().getScalars();else if(n===bd.USE_CELL_DATA)i=e.getCellData().getScalars(),s=!0;else if(n===bd.USE_POINT_FIELD_DATA){const t=e.getPointData();i=r===xd.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===bd.USE_CELL_FIELD_DATA){const t=e.getCellData();s=!0,i=r===xd.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===bd.USE_FIELD_DATA){const t=e.getFieldData();i=r===xd.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}return{scalars:i,cellFlag:s}},e.getLookupTable=()=>(t.lookupTable||e.createDefaultLookupTable(),t.lookupTable),e.getMTime=()=>{let e=t.mtime;if(null!==t.lookupTable){const n=t.lookupTable.getMTime();e=n>e?n:e}return e},e.mapScalars=(n,r)=>{const o=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;if(!o)return void(t.colorMapColors=null);const a=`${e.getMTime()}${o.getMTime()}${r}`;if(t.colorBuildString===a)return;t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]);const i=e.getLookupTable();i&&(i.build(),t.colorMapColors=i.mapScalars(o,t.colorMode,t.fieldDataTupleId)),t.colorBuildString=`${e.getMTime()}${o.getMTime()}${r}`},e.getPrimitiveCount=()=>{const t=e.getInputData();return{points:t.getPoints().getNumberOfValues()/3,verts:t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells(),lines:t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells(),triangles:t.getPolys().getNumberOfValues()-3*t.getPolys().getNumberOfCells()}}}(e,t)}var Ad={newInstance:Ht.newInstance(Sd,"vtkMapper2D"),extend:Sd};const Id=1,{primTypes:wd}=Du,{ScalarMode:Od}=Ad,{vtkErrorMacro:Pd}=jt,Rd={type:"StartEvent"},Md={type:"EndEvent"},Ed={context:null,VBOBuildTime:0,VBOBuildString:null,primitives:null,primTypes:null,shaderRebuildString:null};const Vd=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ed,n),Xt.extend(e,t,n),nd(e,t,n),rd(e,t,n),t.primitives=[],t.primTypes=wd,t.tmpMat4=g(new Float64Array(16));for(let e=wd.Start;e<wd.End;e++)t.primitives[e]=Du.newInstance(),t.primitives[e].setPrimitiveType(e),t.primitives[e].set({lastLightComplexity:0,lastLightCount:0,lastSelectionPass:!1},!0);St(e,t,["context"]),t.VBOBuildTime={},vt(t.VBOBuildTime,{mtime:0}),function(e,t){t.classHierarchy.push("vtkOpenGLPolyDataMapper2D"),e.buildPass=n=>{n&&(t.openGLActor2D=e.getFirstAncestorOfType("vtkOpenGLActor2D"),t._openGLRenderer=t.openGLActor2D.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()))},e.overlayPass=t=>{t&&e.render()},e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyData2DVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\n// all variables that represent positions or directions have a suffix\n// indicating the coordinate system they are in. The possible values are\n// MC - Model Coordinates\n// WC - WC world coordinates\n// VC - View Coordinates\n// DC - Display Coordinates\n\nin vec4 vertexWC;\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// material property values\n//VTK::Color::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\nuniform mat4 WCVCMatrix;  // World to view matrix\n\nvoid main()\n{\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  gl_Position = WCVCMatrix*vertexWC;\n\n  //VTK::TCoord::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::PositionVC::Impl\n}\n",e.Fragment="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyData2DFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nuniform int PrimitiveIDOffset;\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// Scalar coloring\n//VTK::Color::Dec\n\n// Depth Peeling\n//VTK::DepthPeeling::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\nvoid main()\n{\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  //VTK::Color::Impl\n  //VTK::TCoord::Impl\n\n  //VTK::DepthPeeling::Impl\n  //VTK::Picking::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n}\n",e.Geometry=""},e.render=()=>{const n=t._openGLRenderWindow.getContext();if(t.context!==n){t.context=n;for(let e=wd.Start;e<wd.End;e++)t.primitives[e].setOpenGLRenderWindow(t._openGLRenderWindow)}const r=t.openGLActor2D.getRenderable(),o=t._openGLRenderer.getRenderable();e.renderPiece(o,r)},e.renderPiece=(n,r)=>{e.invokeEvent(Rd),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent(Md),t.currentInput?t.currentInput.getPoints&&t.currentInput.getPoints().getNumberOfValues()&&(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)):Pd("No input!")},e.renderPieceStart=(n,r)=>{t.primitiveIDOffset=0,t._openGLRenderer.getSelector()&&(t._openGLRenderer.getSelector().getCurrentPass(),t._openGLRenderer.getSelector().renderProp(r)),e.updateBufferObjects(n,r),t.lastBoundBO=null},e.getNeedToRebuildShaders=(e,n,r)=>e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime(),e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return!!(o<e.getMTime()||o<t._openGLRenderWindow.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentInput.getMTime()||t.renderable.getTransformCoordinate()&&o<n.getMTime())},e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,n.getProperty().getOpacity());const o=t.renderable.getColorMapColors();t.haveCellScalars=!1;const a=t.renderable.getScalarMode();t.renderable.getScalarVisibility()&&(a!==Od.USE_CELL_DATA&&a!==Od.USE_CELL_FIELD_DATA&&a!==Od.USE_FIELD_DATA&&r.getPointData().getScalars()||a===Od.USE_POINT_FIELD_DATA||!o||(t.haveCellScalars=!0));const i=n.getProperty().getRepresentation();let s=r.getPointData().getTCoords();t.openGLActor2D.getActiveTextures()||(s=null);const l=t.renderable.getTransformCoordinate(),c=e.getRenderWindow().getViews()[0].getViewportSize(e),u=`${r.getMTime()}A${i}B${r.getMTime()}C${o?o.getMTime():1}D${s?s.getMTime():1}E${l?e.getMTime():1}F${c}`;if(t.VBOBuildString!==u){let n=r.getPoints();if(l){const t=$l.newInstance(),r=n.getNumberOfPoints();t.setNumberOfPoints(r);const o=[];for(let a=0;a<r;++a){n.getPoint(a,o),l.setValue(o);const r=l.getComputedDoubleViewportValue(e);t.setPoint(a,r[0],r[1],0)}n=t}const a={points:n,tcoords:s,colors:o,cellOffset:0,haveCellScalars:t.haveCellSCalars,customAttributes:t.renderable.getCustomShaderAttributes().map((e=>r.getPointData().getArrayByName(e)))};a.cellOffset+=t.primitives[wd.Points].getCABO().createVBO(r.getVerts(),"verts",i,a),a.cellOffset+=t.primitives[wd.Lines].getCABO().createVBO(r.getLines(),"lines",i,a),a.cellOffset+=t.primitives[wd.Tris].getCABO().createVBO(r.getPolys(),"polys",i,a),a.cellOffset+=t.primitives[wd.TriStrips].getCABO().createVBO(r.getStrips(),"strips",i,a),t.VBOBuildTime.modified(),t.VBOBuildString=u}},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation();t.context.depthMask(!0);for(let a=wd.Start;a<wd.End;a++)t.primitives[a].getCABO().getElementCount()&&(t.lastBoundBO=t.primitives[a],t.primitiveIDOffset+=t.primitives[a].drawArrays(n,r,o,e))},e.renderPieceFinish=(e,n)=>{t.lastBoundBO&&t.lastBoundBO.getVAO().release()},e.replaceShaderValues=(t,n,r)=>{e.replaceShaderColor(t,n,r),e.replaceShaderTCoord(t,n,r),e.replaceShaderPicking(t,n,r),e.replaceShaderPositionVC(t,n,r)},e.replaceShaderColor=(e,n,r)=>{let o=e.Vertex,a=e.Geometry,i=e.Fragment;t.haveCellScalars&&(i=wu.substitute(i,"//VTK::Color::Dec",["uniform samplerBuffer texture1;"]).result,i=wu.substitute(i,"//VTK::Color::Impl",["gl_FragData[0] = texelFetchBuffer(texture1, gl_PrimitiveID + PrimitiveIDOffset);"]).result),0!==t.lastBoundBO.getCABO().getColorComponents()?(o=wu.substitute(o,"//VTK::Color::Dec",["in vec4 diffuseColor;","out vec4 fcolorVSOutput;"]).result,o=wu.substitute(o,"//VTK::Color::Impl",["fcolorVSOutput = diffuseColor;"]).result,a=wu.substitute(a,"//VTK::Color::Dec",["in vec4 fcolorVSOutput[];\n","out vec4 fcolorGSOutput;"]).result,a=wu.substitute(a,"//VTK::Color::Impl",["fcolorGSOutput = fcolorVSOutput[i];"]).result,i=wu.substitute(i,"//VTK::Color::Dec",["in vec4 fcolorVSOutput;"]).result,i=wu.substitute(i,"//VTK::Color::Impl",["gl_FragData[0] = fcolorVSOutput;"]).result):(i=wu.substitute(i,"//VTK::Color::Dec",["uniform vec4 diffuseColor;"]).result,i=wu.substitute(i,"//VTK::Color::Impl",["gl_FragData[0] = diffuseColor;"]).result),e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderTCoord=(e,n,r)=>{if(t.lastBoundBO.getCABO().getTCoordOffset()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;const a=t.lastBoundBO.getCABO().getTCoordComponents();1===a?(n=wu.substitute(n,"//VTK::TCoord::Dec",["in float tcoordMC;","out float tcoordVCVSOutput;"]).result,n=wu.substitute(n,"//VTK::TCoord::Impl",["tcoordVCVSOutput = tcoordMC;"]).result,r=wu.substitute(r,"//VTK::TCoord::Dec",["in float tcoordVCVSOutput[];\n","out float tcoordVCGSOutput;"]).result,r=wu.substitute(r,["//VTK::TCoord::Impl","tcoordVCGSOutput = tcoordVCVSOutput[i];"]).result,o=wu.substitute(o,"//VTK::TCoord::Dec",["in float tcoordVCVSOutput;","uniform sampler2D texture1;"]).result,o=wu.substitute(o,"//VTK::TCoord::Impl",["gl_FragData[0] = gl_FragData[0]*texture2D(texture1, vec2(tcoordVCVSOutput,0));"]).result):2===a&&(n=wu.substitute(n,"//VTK::TCoord::Dec",["in vec2 tcoordMC;","out vec2 tcoordVCVSOutput;"]).result,n=wu.substitute(n,"//VTK::TCoord::Impl",["tcoordVCVSOutput = tcoordMC;"]).result,r=wu.substitute(r,"//VTK::TCoord::Dec",["in vec2 tcoordVCVSOutput[];\n","out vec2 tcoordVCGSOutput;"]).result,r=wu.substitute(r,"//VTK::TCoord::Impl",["tcoordVCGSOutput = tcoordVCVSOutput[i];"]).result,o=wu.substitute(o,"//VTK::TCoord::Dec",["in vec2 tcoordVCVSOutput;","uniform sampler2D texture1;"]).result,o=wu.substitute(o,"//VTK::TCoord::Impl",["gl_FragData[0] = gl_FragData[0]*texture2D(texture1, tcoordVCVSOutput.st);"]).result),t.haveCellScalars&&(r=wu.substitute(r,"//VTK::PrimID::Impl",["gl_PrimitiveID = gl_PrimitiveIDIn;"]).result),e.Vertex=n,e.Geometry=r,e.Fragment=o}},e.replaceShaderPicking=(e,t,n)=>{let r=e.Fragment;r=wu.substitute(r,"//VTK::Picking::Dec",["uniform vec3 mapperIndex;","uniform int picking;"]).result,r=wu.substitute(r,"//VTK::Picking::Impl","  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];").result,e.Fragment=r},e.replaceShaderPositionVC=(e,n,r)=>{t.lastBoundBO.replaceShaderPositionVC(e,n,r)},e.invokeShaderCallbacks=(e,n,r)=>{const o=t.renderable.getViewSpecificProperties().ShadersCallbacks;o&&o.forEach((t=>{t.callback(t.userData,e,n,r)}))},e.setMapperShaderParameters=(e,n,r)=>{if(e.getProgram().isUniformUsed("PrimitiveIDOffset")&&e.getProgram().setUniformi("PrimitiveIDOffset",t.primitiveIDOffset),e.getProgram().isAttributeUsed("vertexWC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"vertexWC",e.getCABO().getVertexOffset(),e.getCABO().getStride(),t.context.FLOAT,3,!1)||Pd("Error setting vertexWC in shader VAO.")),e.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())){t.renderable.getCustomShaderAttributes().forEach(((n,r)=>{e.getProgram().isAttributeUsed(`${n}MC`)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),`${n}MC`,e.getCABO().getCustomData()[r].offset,e.getCABO().getStride(),t.context.FLOAT,e.getCABO().getCustomData()[r].components,!1)||Pd(`Error setting ${n}MC in shader VAO.`))})),e.getProgram().isAttributeUsed("tcoordMC")&&e.getCABO().getTCoordOffset()?e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"tcoordMC",e.getCABO().getTCoordOffset(),e.getCABO().getStride(),t.context.FLOAT,e.getCABO().getTCoordComponents(),!1)||Pd("Error setting tcoordMC in shader VAO."):e.getVAO().removeAttributeArray("tcoordMC"),t.internalColorTexture&&e.getProgram().isUniformUsed("texture1")&&e.getProgram().setUniformi("texture1",t.internalColorTexture.getTextureUnit());const o=t.openGLActor2D.getActiveTextures();if(o)for(let t=0;t<o.length;++t){const n=o[t].getTextureUnit(),r=`texture${n+1}`;e.getProgram().isUniformUsed(r)&&e.getProgram().setUniformi(r,n)}e.setMapperShaderParameters(n,r,t._openGLRenderer.getTiledSizeAndOrigin());const a=t._openGLRenderer.getSelector();e.getProgram().setUniform3fArray("mapperIndex",a?a.getPropColorValue():[0,0,0]),e.getProgram().setUniformi("picking",a?a.getCurrentPass()+1:0)}},e.setPropertyShaderParameters=(e,n,r)=>{const o=t.renderable.getColorMapColors();if(!o||0===o.getNumberOfComponents()){const t=e.getProgram(),n=r.getProperty(),o=n.getOpacity(),a=n.getColor(),i=[a[0],a[1],a[2],o];t.setUniform4f("diffuseColor",i)}},e.setLightingShaderParameters=(e,t,n)=>{},e.setCameraShaderParameters=(e,n,o)=>{const a=e.getProgram(),i=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,s=n.getRenderWindow().getViews()[0].getViewportSize(n),l=n.getViewport(),c=o.getActualPositionCoordinate().getComputedDoubleViewportValue(n),u=[0,0,1,1],d=[0,0,1,1];if(d[0]=l[0]>=u[0]?l[0]:u[0],d[1]=l[1]>=u[1]?l[1]:u[1],d[2]=l[2]<=u[2]?l[2]:u[2],d[3]=l[3]<=u[3]?l[3]:u[3],d[0]>=d[2])return;if(d[1]>=d[3])return;s[0]=xo(s[0]*(d[2]-d[0])/(l[2]-l[0])),s[1]=xo(s[1]*(d[3]-d[1])/(l[3]-l[1]));const p=t._openGLRenderer.getParent().getSize(),f=xo(c[0]-(d[0]-l[0])*p[0]),h=xo(c[1]-(d[1]-l[1])*p[1]),v=-f;let T=-f+s[0];const y=-h;let b=-h+s[1];v===T&&(T=v+1),y===b&&(b=y+1);const x=g(new Float64Array(16));var C,S,A;x[0]=2/(T-v),x[5]=2/(b-y),x[3]=-1*(T+v)/(T-v),x[7]=-1*(b+y)/(b-y),x[10]=0,x[11]=o.getProperty().getDisplayLocation()===Id?-1:1,x[15]=1,m(x,x),a.setUniformMatrix("WCVCMatrix",(C=[x,i],S=r,A=t.tmpMat4,S.identity(A),C.reduce(((e,t,n)=>0===n?t?S.copy(e,t):S.identity(e):t?S.multiply(e,e,t):e),A)))},e.getAllocatedGPUMemoryInBytes=()=>{let e=0;return t.primitives.forEach((t=>{e+=t.getAllocatedGPUMemoryInBytes()})),e}}(e,t)}),"vtkOpenGLPolyDataMapper2D");en("vtkMapper2D",Vd);const{VectorMode:Dd}=il;function Ld(e,t){e.strokeStyle=t.strokeColor,e.lineWidth=t.strokeSize,e.fillStyle=t.fontColor,e.font=`${t.fontStyle} ${t.fontSize}px ${t.fontFamily}`}function Bd(e,t){return e=>{const n=e.getLastSize(),r=(n[0]/700)**.8,o=(n[1]/700)**.8,a=Math.min(r,o),i=e.getAxisTextStyle(),s=e.getTickTextStyle();Object.assign(i,t.axisTextStyle),Object.assign(s,t.tickTextStyle),i.fontSize=Math.max(24*a,12),e.getLastAspectRatio()>1?s.fontSize=Math.max(20*a,10):s.fontSize=Math.max(16*a,10);const l=e.updateTextureAtlas();e.setTopTitle(!1);const c=e.getBoxSizeByReference();if(e.getLastAspectRatio()>1)e.setTickLabelPixelOffset(.3*s.fontSize),l.titleWidth<=l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize?(e.setTopTitle(!0),e.setAxisTitlePixelOffset(.2*s.fontSize),c[0]=2*(l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize)/n[0],e.setBoxPosition([.98-c[0],-.92])):(e.setAxisTitlePixelOffset(.2*s.fontSize),c[0]=2*(l.titleHeight+e.getAxisTitlePixelOffset()+l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize)/n[0],e.setBoxPosition([.99-c[0],-.92])),c[1]=Math.max(1.2,Math.min(1.84/o,1.84));else{e.setAxisTitlePixelOffset(1.2*s.fontSize),e.setTickLabelPixelOffset(.1*s.fontSize);const t=2*(.8*s.fontSize+l.titleHeight+e.getAxisTitlePixelOffset())/n[1],r=2*l.tickWidth/n[0];c[0]=Math.min(1.9,Math.max(1.4,1.4*r*(e.getTicks().length+3))),c[1]=t,e.setBoxPosition([-.5*c[0],-.97])}e.recomputeBarSegments(l)}}function Nd(e,t){return e=>{const t=e.getLastTickBounds(),n=oo().domain([t[0],t[1]]),r=n.ticks(5),o=n.tickFormat(5);e.setTicks(r),e.setTickStrings(r.map(o))}}const Fd=Ht.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{renderable:null};Object.assign(t,{},n),Ht.obj(e,t),Ht.setGet(e,t,["axisTitlePixelOffset","tickLabelPixelOffset","renderable","topTitle","ticks","tickStrings","tickPositions"]),Ht.get(e,t,["lastSize","lastAspectRatio","lastTickBounds","axisTextStyle","tickTextStyle","barActor","tmActor"]),Ht.getArray(e,t,["boxPosition","boxSize"]),Ht.setArray(e,t,["boxPosition","boxSize"],2),t.forceUpdate=!1,t.lastRebuildTime={},Ht.obj(t.lastRebuildTime,{mtime:0}),t.lastSize=[-1,-1],t.tmCanvas=document.createElement("canvas"),t.tmContext=t.tmCanvas.getContext("2d"),t._tmAtlas=new Map,t.barMapper=Fl.newInstance(),t.barMapper.setInterpolateScalarsBeforeMapping(!0),t.barMapper.setUseLookupTableScalarRange(!0),t.polyData=kc.newInstance(),t.barMapper.setInputData(t.polyData),t.barActor=os.newInstance(),t.barActor.setMapper(t.barMapper),t.tmPolyData=kc.newInstance(),t.tmMapper=Fl.newInstance(),t.tmMapper.setInputData(t.tmPolyData),t.tmTexture=zc.newInstance({resizable:!0}),t.tmTexture.setInterpolate(!1),t.tmActor=os.newInstance({parentProp:e}),t.tmActor.setMapper(t.tmMapper),t.tmActor.addTexture(t.tmTexture),t.barPosition=[0,0],t.barSize=[0,0],t.boxPosition=[.88,-.92],t.boxSize=[.1,1.1],t.lastTickBounds=[],function(e,t){t.classHierarchy.push("vtkScalarBarActorHelper"),e.setRenderable=n=>{t.renderable!==n&&(t.renderable=n,t.barActor.setProperty(n.getProperty()),t.barActor.setParentProp(n),t.barActor.setCoordinateSystemToDisplay(),t.tmActor.setProperty(n.getProperty()),t.tmActor.setParentProp(n),t.tmActor.setCoordinateSystemToDisplay(),t.generateTicks=n.generateTicks,t.axisTextStyle={...n.getAxisTextStyle()},t.tickTextStyle={...n.getTickTextStyle()},e.modified())},e.updateAPISpecificData=(n,r,o)=>{t.lastSize[0]===n[0]&&t.lastSize[1]===n[1]||(t.lastSize[0]=n[0],t.lastSize[1]=n[1],t.lastAspectRatio=n[0]/n[1],t.forceUpdate=!0);const a=t.renderable.getScalarsToColors();if(a&&t.renderable.getVisibility()&&(t.barMapper.setLookupTable(a),t.camera=r,t.renderWindow=o,t.forceUpdate||Math.max(a.getMTime(),e.getMTime(),t.renderable.getMTime())>t.lastRebuildTime.getMTime())){const n=a.getMappingRange();if(t.lastTickBounds=[...n],t.renderable.getGenerateTicks()(e),t.renderable.getAutomated())t.renderable.getAutoLayout()(e);else{t.axisTextStyle={...t.renderable.getAxisTextStyle()},t.tickTextStyle={...t.renderable.getTickTextStyle()},t.barPosition=[...t.renderable.getBarPosition()],t.barSize=[...t.renderable.getBarSize()],t.boxPosition=[...t.renderable.getBoxPosition()],t.boxSize=[...t.renderable.getBoxSize()],t.axisTitlePixelOffset=t.renderable.getAxisTitlePixelOffset(),t.tickLabelPixelOffset=t.renderable.getTickLabelPixelOffset();const n=e.updateTextureAtlas();e.recomputeBarSegments(n)}e.updatePolyDataForLabels(),e.updatePolyDataForBarSegments(),t.lastRebuildTime.modified(),t.forceUpdate=!1}},e.updateTextureAtlas=()=>{t.tmContext.textBaseline="bottom",t.tmContext.textAlign="left";const n={},r=new Map;let o=0,a=1;Ld(t.tmContext,t.axisTextStyle);let i=t.tmContext.measureText(t.renderable.getAxisLabel()),s={height:i.actualBoundingBoxAscent+2,startingHeight:a,width:i.width+2,textStyle:t.axisTextStyle};r.set(t.renderable.getAxisLabel(),s),a+=s.height,o=s.width,n.titleWidth=s.width,n.titleHeight=s.height,n.tickWidth=0,n.tickHeight=0,Ld(t.tmContext,t.tickTextStyle);const l=[...e.getTickStrings(),"NaN","Below","Above"];for(let e=0;e<l.length;e++)r.has(l[e])||(i=t.tmContext.measureText(l[e]),s={height:i.actualBoundingBoxAscent+2,startingHeight:a,width:i.width+2,textStyle:t.tickTextStyle},r.set(l[e],s),a+=s.height,o<s.width&&(o=s.width),n.tickWidth<s.width&&(n.tickWidth=s.width),n.tickHeight<s.height&&(n.tickHeight=s.height));return o=Po(o),a=Po(a),r.forEach((e=>{e.tcoords=[0,(a-e.startingHeight-e.height)/a,e.width/o,(a-e.startingHeight-e.height)/a,e.width/o,(a-e.startingHeight)/a,0,(a-e.startingHeight)/a]})),t.tmCanvas.width=o,t.tmCanvas.height=a,t.tmContext.textBaseline="bottom",t.tmContext.textAlign="left",t.tmContext.clearRect(0,0,o,a),r.forEach(((e,n)=>{Ld(t.tmContext,e.textStyle),t.tmContext.fillText(n,1,e.startingHeight+e.height-1)})),t.tmTexture.setCanvas(t.tmCanvas),t.tmTexture.modified(),t._tmAtlas=r,n},e.computeBarSize=e=>{t.vertical=t.boxSize[1]>t.boxSize[0];const n=2*e.tickHeight/t.lastSize[1],r=[1,1];if(t.vertical){const o=2*(e.tickWidth+t.tickLabelPixelOffset)/t.lastSize[0];if(t.topTitle){const n=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[1];t.barSize[0]=t.boxSize[0]-o,t.barSize[1]=t.boxSize[1]-n}else{const n=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[0];t.barSize[0]=t.boxSize[0]-n-o,t.barSize[1]=t.boxSize[1]}t.barPosition[0]=t.boxPosition[0]+o,t.barPosition[1]=t.boxPosition[1],r[1]=n}else{const n=(2*e.tickWidth-8)/t.lastSize[0],o=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[1];t.barSize[0]=t.boxSize[0],t.barPosition[0]=t.boxPosition[0],t.barSize[1]=t.boxSize[1]-o,t.barPosition[1]=t.boxPosition[1],r[0]=n}return r},e.recomputeBarSegments=n=>{const r=e.computeBarSize(n);t.barSegments=[];const o=[0,0],a=t.vertical?1:0,i=t.vertical?.01:.02;function s(e,n){t.barSegments.push({corners:[[...o],[o[0]+r[0],o[1]],[o[0]+r[0],o[1]+r[1]],[o[0],o[1]+r[1]]],scalars:n,title:e}),o[a]+=r[a]+i}t.renderable.getDrawNanAnnotation()&&t.renderable.getScalarsToColors().getNanColor()&&s("NaN",[NaN,NaN,NaN,NaN]),t.renderable.getDrawBelowRangeSwatch()&&t.renderable.getScalarsToColors().getUseBelowRangeColor?.()&&s("Below",[-.1,-.1,-.1,-.1]);const l=t.renderable.getScalarsToColors().getUseAboveRangeColor?.();o[a]+=i;const c=r[a];r[a]=l?1-2*i-r[a]-o[a]:1-i-o[a],s("ticks",t.vertical?[0,0,.995,.995]:[0,.995,.995,0]),t.renderable.getDrawAboveRangeSwatch()&&l&&(r[a]=c,o[a]+=i,s("Above",[1.1,1.1,1.1,1.1]))};const n=new Float64Array(3);e.createPolyDataForOneLabel=(e,r,o,a,i,s)=>{const l=t._tmAtlas.get(e);if(!l)return;let c=s.ptIdx,u=s.cellIdx;n[0]=(.5*r[0]+.5)*t.lastSize[0],n[1]=(.5*r[1]+.5)*t.lastSize[1],n[2]=r[2],n[0]+=i[0],n[1]+=i[1];const d=[],p="vertical"===a?[1,0]:[0,1];"vertical"===a?(d[0]=l.width,d[1]=-l.height,"middle"===o[0]?n[1]-=l.width/2:"right"===o[0]&&(n[1]-=l.width),"middle"===o[1]?n[0]+=l.height/2:"top"===o[1]&&(n[0]+=l.height)):(d[0]=l.width,d[1]=l.height,"middle"===o[0]?n[0]-=l.width/2:"right"===o[0]&&(n[0]-=l.width),"middle"===o[1]?n[1]-=l.height/2:"top"===o[1]&&(n[1]-=l.height)),s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[0],s.tcoords[2*c+1]=l.tcoords[1],c++,n[p[0]]+=d[0],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[2],s.tcoords[2*c+1]=l.tcoords[3],c++,n[p[1]]+=d[1],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[4],s.tcoords[2*c+1]=l.tcoords[5],c++,n[p[0]]-=d[0],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[6],s.tcoords[2*c+1]=l.tcoords[7],c++,s.polys[4*u]=3,s.polys[4*u+1]=c-4,s.polys[4*u+2]=c-3,s.polys[4*u+3]=c-2,u++,s.polys[4*u]=3,s.polys[4*u+1]=c-4,s.polys[4*u+2]=c-2,s.polys[4*u+3]=c-1,s.ptIdx+=4,s.cellIdx+=2};const r=new Float64Array(3);e.updatePolyDataForLabels=()=>{const n=e.getTickStrings().length+t.barSegments.length,o=4*n,a=2*n,i=new Float64Array(3*o),s=new Uint16Array(4*a),l=new Float32Array(2*o),c={ptIdx:0,cellIdx:0,polys:s,points:i,tcoords:l},u=t.vertical?0:1,d=t.vertical?1:0;r[2]=-.99;const p=t.vertical?["right","middle"]:["middle","bottom"];let f=[0,1];const g=[0,0];t.vertical?(g[0]=-t.tickLabelPixelOffset,t.topTitle?(r[0]=t.boxPosition[0]+.5*t.boxSize[0],r[1]=t.barPosition[1]+t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,["middle","bottom"],"horizontal",[0,t.axisTitlePixelOffset],c)):(r[0]=t.barPosition[0]+t.barSize[0],r[1]=t.barPosition[1]+.5*t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,["middle","top"],"vertical",[t.axisTitlePixelOffset,0],c)),f=[-1,0]):(g[1]=t.tickLabelPixelOffset,r[0]=t.barPosition[0]+.5*t.barSize[0],r[1]=t.barPosition[1]+t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,["middle","bottom"],"horizontal",[0,t.axisTitlePixelOffset],c)),r[u]=t.barPosition[u]+(.5*f[u]+.5)*t.barSize[u],r[d]=t.barPosition[d]+.5*t.barSize[d];let m=null;for(let n=0;n<t.barSegments.length;n++){const o=t.barSegments[n];"ticks"===o.title?m=o:(r[d]=t.barPosition[d]+.5*t.barSize[d]*(o.corners[2][d]+o.corners[0][d]),e.createPolyDataForOneLabel(o.title,r,p,"horizontal",g,c))}const h=t.barPosition[d]+t.barSize[d]*m.corners[0][d],v=t.barSize[d]*(m.corners[2][d]-m.corners[0][d]),T=e.getTicks(),y=e.getTickStrings(),b=e.getTickPositions();for(let n=0;n<T.length;n++){const o=b?b[n]:(T[n]-t.lastTickBounds[0])/(t.lastTickBounds[1]-t.lastTickBounds[0]);r[d]=h+v*o,e.createPolyDataForOneLabel(y[n],r,p,"horizontal",g,c)}const x=Ts.newInstance({numberOfComponents:2,values:l,name:"TextureCoordinates"});t.tmPolyData.getPointData().setTCoords(x),t.tmPolyData.getPoints().setData(i,3),t.tmPolyData.getPoints().modified(),t.tmPolyData.getPolys().setData(s,1),t.tmPolyData.getPolys().modified(),t.tmPolyData.modified()},e.updatePolyDataForBarSegments=()=>{const e=t.renderable.getScalarsToColors();let n=0;t.renderable.getDrawNanAnnotation()&&e.getNanColor()&&(n+=1),t.renderable.getDrawBelowRangeSwatch()&&e.getUseBelowRangeColor?.()&&(n+=1),t.renderable.getDrawAboveRangeSwatch()&&e.getUseAboveRangeColor?.()&&(n+=1);const o=4*(1+n),a=o;let i=1;e.getVectorMode()===Dd.COMPONENT&&(i=e.getVectorComponent()+1);const s=new Float64Array(3*o),l=new Uint16Array(5*a),c=new Float32Array(o*i);let u=0,d=0;for(let e=0;e<t.barSegments.length;e++){const n=t.barSegments[e];for(let e=0;e<4;e++){r[0]=t.barPosition[0]+n.corners[e][0]*t.barSize[0],r[1]=t.barPosition[1]+n.corners[e][1]*t.barSize[1],s[3*u]=(.5*r[0]+.5)*t.lastSize[0],s[3*u+1]=(.5*r[1]+.5)*t.lastSize[1],s[3*u+2]=r[2];for(let r=0;r<i;r++)c[u*i+r]=t.lastTickBounds[0]+n.scalars[e]*(t.lastTickBounds[1]-t.lastTickBounds[0]);u++}l[5*d]=4,l[5*d+1]=u-4,l[5*d+2]=u-3,l[5*d+3]=u-2,l[5*d+4]=u-1,d++}const p=Ts.newInstance({numberOfComponents:i,values:c,name:"Scalars"});t.polyData.getPointData().setScalars(p),t.polyData.getPoints().setData(s,3),t.polyData.getPoints().modified(),t.polyData.getPolys().setData(l,1),t.polyData.getPolys().modified(),t.polyData.modified()}}(e,t)}),"vtkScalarBarActorHelper");function _d(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,function(e){return{automated:!0,autoLayout:null,axisLabel:"Scalar Value",barPosition:[0,0],barSize:[0,0],boxPosition:[.88,-.92],boxSize:[.1,1.1],scalarToColors:null,axisTitlePixelOffset:36,axisTextStyle:{fontColor:"white",fontStyle:"normal",fontSize:18,fontFamily:"serif"},tickLabelPixelOffset:14,tickTextStyle:{fontColor:"white",fontStyle:"normal",fontSize:14,fontFamily:"serif"},generateTicks:null,drawNanAnnotation:!0,drawBelowRangeSwatch:!0,drawAboveRangeSwatch:!0,...e}}(n)),t.autoLayout||(t.autoLayout=Bd(0,t)),t.generateTicks||(t.generateTicks=Nd()),os.extend(e,t,n),e.getProperty().setDiffuse(0),e.getProperty().setAmbient(1),Ht.setGet(e,t,["automated","autoLayout","axisTitlePixelOffset","axisLabel","scalarsToColors","tickLabelPixelOffset","generateTicks","drawNanAnnotation","drawBelowRangeSwatch","drawAboveRangeSwatch"]),Ht.get(e,t,["axisTextStyle","tickTextStyle"]),Ht.getArray(e,t,["barPosition","barSize","boxPosition","boxSize"]),Ht.setArray(e,t,["barPosition","barSize","boxPosition","boxSize"],2),function(e,t){t.classHierarchy.push("vtkScalarBarActor"),e.setTickTextStyle=n=>{t.tickTextStyle={...t.tickTextStyle,...n},e.modified()},e.setAxisTextStyle=n=>{t.axisTextStyle={...t.axisTextStyle,...n},e.modified()},e.resetAutoLayoutToDefault=()=>{e.setAutoLayout(Bd(0,t))},e.resetGenerateTicksToDefault=()=>{e.setGenerateTicks(Nd())}}(e,t)}var kd={newInstance:Ht.newInstance(_d,"vtkScalarBarActor"),extend:_d,newScalarBarActorHelper:Fd};const Gd={};const Ud=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Gd,n),Xt.extend(e,t,n),t.scalarBarActorHelper=kd.newScalarBarActorHelper(),function(e,t){t.classHierarchy.push("vtkOpenGLScalarBarActor"),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.scalarBarActorHelper.getRenderable()||t.scalarBarActorHelper.setRenderable(t.renderable),e.prepareNodes(),e.addMissingNode(t.scalarBarActorHelper.getBarActor()),e.addMissingNode(t.scalarBarActorHelper.getTmActor()),e.removeUnusedNodes())},e.opaquePass=(e,n)=>{if(e){const e=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,n=t._openGLRenderer.getTiledSizeAndOrigin();t.scalarBarActorHelper.updateAPISpecificData([n.usize,n.vsize],e,t._openGLRenderWindow.getRenderable())}}}(e,t)}),"vtkOpenGLScalarBarActor");en("vtkScalarBarActor",Ud);const{vtkErrorMacro:zd}=jt,Wd={context:null};const Hd=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Wd,n),Xt.extend(e,t,n),t.openGLTexture=Ju.newInstance(),t.tris=Du.newInstance(),t.keyMatrixTime={},vt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={normalMatrix:pe(new Float64Array(9)),mcwc:g(new Float64Array(16))},St(e,t,["context"]),yt(e,t,["activeTextures"]),function(e,t){t.classHierarchy.push("vtkOpenGLSkybox"),e.buildPass=n=>{if(n){t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(n.getActiveCamera())}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementOpaqueActorCount()}},e.opaquePass=(n,r)=>{if(n&&!t._openGLRenderer.getSelector()){e.updateBufferObjects(),t.context.depthMask(!0),t._openGLRenderWindow.getShaderCache().readyShaderProgram(t.tris.getProgram()),t.openGLTexture.render(t._openGLRenderWindow);const n=t.openGLTexture.getTextureUnit();t.tris.getProgram().setUniformi("sbtexture",n);const r=t._openGLRenderer.getRenderable(),o=t.openGLCamera.getKeyMatrices(r),a=new Float64Array(16);if(h(a,o.wcpc),t.tris.getProgram().setUniformMatrix("IMCPCMatrix",a),"box"===t.lastFormat){const e=r.getActiveCamera().getPosition();t.tris.getProgram().setUniform3f("camPos",e[0],e[1],e[2])}t.tris.getVAO().bind(),t.context.drawArrays(t.context.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),t.openGLTexture.deactivate()}},e.updateBufferObjects=()=>{if(!t.tris.getCABO().getElementCount()){const e=new Float32Array(12);for(let t=0;t<4;t++)e[3*t]=t%2*2-1,e[3*t+1]=t>1?1:-1,e[3*t+2]=1;const n=Ts.newInstance({numberOfComponents:3,values:e});n.setName("points");const r=new Uint16Array(8);r[0]=3,r[1]=0,r[2]=1,r[3]=3,r[4]=3,r[5]=0,r[6]=3,r[7]=2;const o=Ts.newInstance({numberOfComponents:1,values:r});t.tris.getCABO().createVBO(o,"polys",qi.SURFACE,{points:n,cellOffset:0})}t.renderable.getFormat()!==t.lastFormat&&(t.lastFormat=t.renderable.getFormat(),"box"===t.lastFormat&&t.tris.setProgram(t._openGLRenderWindow.getShaderCache().readyShaderProgramArray("//VTK::System::Dec\n             attribute vec3 vertexMC;\n             uniform mat4 IMCPCMatrix;\n             varying vec3 TexCoords;\n             void main () {\n              gl_Position = vec4(vertexMC.xyz, 1.0);\n              vec4 wpos = IMCPCMatrix * gl_Position;\n              TexCoords = wpos.xyz/wpos.w;\n             }","//VTK::System::Dec\n             //VTK::Output::Dec\n             varying vec3 TexCoords;\n             uniform samplerCube sbtexture;\n             uniform vec3 camPos;\n             void main () {\n               // skybox looks from inside out\n               // which means we have to adjust\n               // our tcoords. Otherwise text would\n               // be flipped\n               vec3 tc = normalize(TexCoords - camPos);\n               if (abs(tc.z) < max(abs(tc.x),abs(tc.y)))\n               {\n                 tc = vec3(1.0, 1.0, -1.0) * tc;\n               }\n               else\n               {\n                 tc = vec3(-1.0, 1.0, 1.0) * tc;\n               }\n               gl_FragData[0] = textureCube(sbtexture, tc);\n             }","")),"background"===t.lastFormat&&t.tris.setProgram(t._openGLRenderWindow.getShaderCache().readyShaderProgramArray("//VTK::System::Dec\n             attribute vec3 vertexMC;\n             uniform mat4 IMCPCMatrix;\n             varying vec2 TexCoords;\n             void main () {\n              gl_Position = vec4(vertexMC.xyz, 1.0);\n              vec4 wpos = IMCPCMatrix * gl_Position;\n              TexCoords = vec2(vertexMC.x, vertexMC.y)*0.5 + 0.5;\n             }","//VTK::System::Dec\n             //VTK::Output::Dec\n             varying vec2 TexCoords;\n             uniform sampler2D sbtexture;\n             void main () {\n               gl_FragData[0] = texture2D(sbtexture, TexCoords);\n             }","")),t.tris.getShaderSourceTime().modified(),t.tris.getVAO().bind(),t.tris.getVAO().addAttributeArray(t.tris.getProgram(),t.tris.getCABO(),"vertexMC",t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||zd("Error setting vertexMC in shader VAO."));const e=t.renderable.getTextures();e.length||zd("vtkSkybox requires a texture map"),t.openGLTexture.getRenderable()!==e[0]&&(t.openGLTexture.releaseGraphicsResources(t._openGLRenderWindow),t.openGLTexture.setRenderable(e[0]))}}(e,t)}));en("vtkSkybox",Hd);const{FieldAssociations:jd}=_s,Kd={fieldAssociation:jd.FIELD_ASSOCIATION_CELLS,captureZValues:!1};function $d(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kd,n),Ht.obj(e,t),Ht.setGet(e,t,["fieldAssociation","captureZValues"]),function(e,t){t.classHierarchy.push("vtkHardwareSelector"),e.getSourceDataAsync=async(e,t,n,r,o)=>{},e.selectAsync=async(t,n,r,o,a)=>{const i=await e.getSourceDataAsync(t,n,r,o,a);return i?i.generateSelection(n,r,o,a):[]}}(e,t)}var qd={newInstance:Ht.newInstance($d,"vtkHardwareSelector"),extend:$d};const Xd={glFramebuffer:null,colorBuffers:null,depthTexture:null,previousDrawBinding:0,previousReadBinding:0,previousDrawBuffer:0,previousReadBuffer:0,previousActiveFramebuffer:null};function Yd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xd,n),vt(e,t),t.colorBuffers&&tt("you cannot initialize colorBuffers through the constructor. You should call setColorBuffer() instead."),t.colorBuffers=[],At(e,t,["colorBuffers"]),function(e,t){t.classHierarchy.push("vtkFramebuffer"),e.getBothMode=()=>t.context.FRAMEBUFFER,e.saveCurrentBindingsAndBuffers=t=>{const n=void 0!==t?t:e.getBothMode();e.saveCurrentBindings(n),e.saveCurrentBuffers(n)},e.saveCurrentBindings=e=>{if(!t.context)return void tt("you must set the OpenGLRenderWindow before calling saveCurrentBindings");const n=t.context;t.previousDrawBinding=n.getParameter(t.context.FRAMEBUFFER_BINDING),t.previousActiveFramebuffer=t._openGLRenderWindow.getActiveFramebuffer()},e.saveCurrentBuffers=e=>{},e.restorePreviousBindingsAndBuffers=t=>{const n=void 0!==t?t:e.getBothMode();e.restorePreviousBindings(n),e.restorePreviousBuffers(n)},e.restorePreviousBindings=e=>{if(!t.context)return void tt("you must set the OpenGLRenderWindow before calling restorePreviousBindings");const n=t.context;n.bindFramebuffer(n.FRAMEBUFFER,t.previousDrawBinding),t._openGLRenderWindow.setActiveFramebuffer(t.previousActiveFramebuffer)},e.restorePreviousBuffers=e=>{},e.bind=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;null===n&&(n=t.context.FRAMEBUFFER),t.context.bindFramebuffer(n,t.glFramebuffer);for(let e=0;e<t.colorBuffers.length;e++)t.colorBuffers[e].bind();t._openGLRenderWindow.setActiveFramebuffer(e)},e.create=(e,n)=>{t.context?(t.glFramebuffer=t.context.createFramebuffer(),t.glFramebuffer.width=e,t.glFramebuffer.height=n):tt("you must set the OpenGLRenderWindow before calling create")},e.setColorBuffer=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const r=t.context;if(!r)return void tt("you must set the OpenGLRenderWindow before calling setColorBuffer");let o=r.COLOR_ATTACHMENT0;if(n>0){if(!t._openGLRenderWindow.getWebgl2())return void tt("Using multiple framebuffer attachments requires WebGL 2");o+=n}t.colorBuffers[n]=e,r.framebufferTexture2D(r.FRAMEBUFFER,o,r.TEXTURE_2D,e.getHandle(),0)},e.removeColorBuffer=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const n=t.context;if(!n)return void tt("you must set the OpenGLRenderWindow before calling removeColorBuffer");let r=n.COLOR_ATTACHMENT0;if(e>0){if(!t._openGLRenderWindow.getWebgl2())return void tt("Using multiple framebuffer attachments requires WebGL 2");r+=e}n.framebufferTexture2D(n.FRAMEBUFFER,r,n.TEXTURE_2D,null,0),t.colorBuffers=t.colorBuffers.splice(e,1)},e.setDepthBuffer=e=>{if(t.context)if(t._openGLRenderWindow.getWebgl2()){const n=t.context;n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,e.getHandle(),0)}else tt("Attaching depth buffer textures to fbo requires WebGL 2");else tt("you must set the OpenGLRenderWindow before calling setDepthBuffer")},e.removeDepthBuffer=()=>{if(t.context)if(t._openGLRenderWindow.getWebgl2()){const e=t.context;e.framebufferTexture2D(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.TEXTURE_2D,null,0)}else tt("Attaching depth buffer textures to framebuffers requires WebGL 2");else tt("you must set the OpenGLRenderWindow before calling removeDepthBuffer")},e.getGLFramebuffer=()=>t.glFramebuffer,e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.releaseGraphicsResources=()=>{t.glFramebuffer&&t.context.deleteFramebuffer(t.glFramebuffer)},e.getSize=()=>null==t.glFramebuffer?null:[t.glFramebuffer.width,t.glFramebuffer.height],e.populateFramebuffer=()=>{if(!t.context)return void tt("you must set the OpenGLRenderWindow before calling populateFrameBuffer");e.bind();const n=t.context,r=Ju.newInstance();r.setOpenGLRenderWindow(t._openGLRenderWindow),r.setMinificationFilter(Bu.LINEAR),r.setMagnificationFilter(Bu.LINEAR),r.create2DFromRaw({width:t.glFramebuffer.width,height:t.glFramebuffer.height,numComps:4,dataType:is.UNSIGNED_CHAR,data:null}),e.setColorBuffer(r),t.depthTexture=n.createRenderbuffer(),n.bindRenderbuffer(n.RENDERBUFFER,t.depthTexture),n.renderbufferStorage(n.RENDERBUFFER,n.DEPTH_COMPONENT16,t.glFramebuffer.width,t.glFramebuffer.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.RENDERBUFFER,t.depthTexture)},e.getColorTexture=()=>t.colorBuffers[0]}(e,t)}var Zd={newInstance:Et(Yd,"vtkFramebuffer"),extend:Yd};const Qd={contentType:-1,fieldType:-1,properties:null,selectionList:[]};function Jd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Qd,n),Ht.obj(e,t),t.properties={},Ht.setGet(e,t,["contentType","fieldType","properties","selectionList"]),function(e,t){t.classHierarchy.push("vtkSelectionNode"),e.getBounds=()=>t.points.getBounds()}(e,t)}var ep={newInstance:Ht.newInstance(Jd,"vtkSelectionNode"),extend:Jd,SelectionContent:{GLOBALIDS:0,PEDIGREEIDS:1,VALUES:2,INDICES:3,FRUSTUM:4,LOCATIONS:5,THRESHOLDS:6,BLOCKS:7,QUERY:8},SelectionField:{CELL:0,POINT:1,FIELD:2,VERTEX:3,EDGE:4,ROW:5}};const{PassTypes:tp}=Cl,{SelectionContent:np,SelectionField:rp}=ep,{FieldAssociations:op}=_s,{vtkErrorMacro:ap}=Ht;function ip(e){return`${e.propID} ${e.compositeID}`}function sp(e,t,n,r){return n?n[4*(t*(r[2]-r[0]+1)+e)+3]:0}function lp(e,t,n,r){if(!n)return 0;const o=4*(t*(r[2]-r[0]+1)+e),a=n[o],i=n[o+1];return 256*(256*n[o+2]+i)+a}function cp(e,t){let n=t;return n<<=24,n|=e,n}function up(e,t,n,r){const o=n<0?0:n;if(0===o){if(r[0]=t[0],r[1]=t[1],t[0]<e.area[0]||t[0]>e.area[2]||t[1]<e.area[1]||t[1]>e.area[3])return null;const n=[t[0]-e.area[0],t[1]-e.area[1]],o=lp(n[0],n[1],e.pixBuffer[tp.ACTOR_PASS],e.area);if(o<=0||o-1>=e.props.length)return null;const a={valid:!0};a.propID=o-1,a.prop=e.props[a.propID];let i=lp(n[0],n[1],e.pixBuffer[tp.COMPOSITE_INDEX_PASS],e.area);if((i<0||i>16777215)&&(i=0),a.compositeID=i-1,e.captureZValues){const r=4*(n[1]*(e.area[2]-e.area[0]+1)+n[0]);a.zValue=(256*e.zBuffer[r]+e.zBuffer[r+1])/65535,a.displayPosition=t}if(e.pixBuffer[tp.ID_LOW24]&&0===sp(n[0],n[1],e.pixBuffer[tp.ID_LOW24],e.area))return a;const s=lp(n[0],n[1],e.pixBuffer[tp.ID_LOW24],e.area),l=lp(n[0],n[1],e.pixBuffer[tp.ID_HIGH24],e.area);return a.attributeID=cp(s,l),a}const a=[t[0],t[1]],i=[0,0];let s=up(e,t,0,r);if(s&&s.valid)return s;for(let t=1;t<o;++t){for(let n=a[1]>t?a[1]-t:0;n<=a[1]+t;++n){if(i[1]=n,a[0]>=t&&(i[0]=a[0]-t,s=up(e,i,0,r),s&&s.valid))return s;if(i[0]=a[0]+t,s=up(e,i,0,r),s&&s.valid)return s}for(let n=a[0]>=t?a[0]-(t-1):0;n<=a[0]+(t-1);++n){if(i[0]=n,a[1]>=t&&(i[1]=a[1]-t,s=up(e,i,0,r),s&&s.valid))return s;if(i[1]=a[1]+t,s=up(e,i,0,r),s&&s.valid)return s}}return r[0]=t[0],r[1]=t[1],null}function dp(e,t,n,r,o){const a=[];let i=0;return t.forEach(((t,s)=>{const l=ep.newInstance();switch(l.setContentType(np.INDICES),e){case op.FIELD_ASSOCIATION_CELLS:l.setFieldType(rp.CELL);break;case op.FIELD_ASSOCIATION_POINTS:l.setFieldType(rp.POINT);break;default:ap("Unknown field association")}l.getProperties().propID=t.info.propID,l.getProperties().prop=t.info.prop,l.getProperties().compositeID=t.info.compositeID,l.getProperties().attributeID=t.info.attributeID,l.getProperties().pixelCount=t.pixelCount,n&&(l.getProperties().displayPosition=[t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue],l.getProperties().worldPosition=o.displayToWorld(t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue,r)),l.setSelectionList(t.attributeIDs),a[i]=l,i++})),a}const pp={area:void 0,currentPass:-1,propColorValue:null,props:null,maximumPointId:0,maximumCellId:0,idOffset:1};function fp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,pp,n),qd.extend(e,t,n),t.propColorValue=[0,0,0],t.props=[],t.area||(t.area=[0,0,0,0]),Ht.setGetArray(e,t,["area"],4),Ht.setGet(e,t,["_renderer","currentPass","_openGLRenderWindow","maximumPointId","maximumCellId"]),Ht.setGetArray(e,t,["propColorValue"],3),Ht.moveToProtected(e,t,["renderer","openGLRenderWindow"]),Ht.event(e,t,"event"),function(e,t){t.classHierarchy.push("vtkOpenGLHardwareSelector"),e.releasePixBuffers=()=>{t.rawPixBuffer=[],t.pixBuffer=[],t.zBuffer=null},e.beginSelection=()=>{t._openGLRenderer=t._openGLRenderWindow.getViewNodeFor(t._renderer),t.maxAttributeId=0;const n=t._openGLRenderWindow.getSize();if(t.framebuffer){t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.saveCurrentBindingsAndBuffers();const e=t.framebuffer.getSize();e&&e[0]===n[0]&&e[1]===n[1]?t.framebuffer.bind():(t.framebuffer.create(n[0],n[1]),t.framebuffer.populateFramebuffer())}else t.framebuffer=Zd.newInstance(),t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.create(n[0],n[1]),t.framebuffer.populateFramebuffer();if(t._openGLRenderer.clear(),t._openGLRenderer.setSelector(e),t.hitProps={},t.propPixels={},t.props=[],e.releasePixBuffers(),t.fieldAssociation===op.FIELD_ASSOCIATION_POINTS){const e=t._openGLRenderWindow.getContext(),n=e.isEnabled(e.BLEND);e.disable(e.BLEND),t._openGLRenderWindow.traverseAllPasses(),n&&e.enable(e.BLEND)}},e.endSelection=()=>{t.hitProps={},t._openGLRenderer.setSelector(null),t.framebuffer.restorePreviousBindingsAndBuffers()},e.preCapturePass=()=>{const e=t._openGLRenderWindow.getContext();t.originalBlending=e.isEnabled(e.BLEND),e.disable(e.BLEND)},e.postCapturePass=()=>{const e=t._openGLRenderWindow.getContext();t.originalBlending&&e.enable(e.BLEND)},e.select=()=>{let n=null;return e.captureBuffers()&&(n=e.generateSelection(t.area[0],t.area[1],t.area[2],t.area[3]),e.releasePixBuffers()),n},e.getSourceDataAsync=async(n,r,o,a,i)=>{if(t._renderer=n,void 0===r){const n=t._openGLRenderWindow.getSize();e.setArea(0,0,n[0]-1,n[1]-1)}else e.setArea(r,o,a,i);if(!e.captureBuffers())return!1;const s={area:[...t.area],pixBuffer:[...t.pixBuffer],captureZValues:t.captureZValues,zBuffer:t.zBuffer,props:[...t.props],fieldAssociation:t.fieldAssociation,renderer:n,openGLRenderWindow:t._openGLRenderWindow,generateSelection:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return function(e,t,n,r,o){const a=Math.floor(t),i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=new Map,u=[0,0];for(let t=i;t<=l;t++)for(let n=a;n<=s;n++){const r=up(e,[n,t],0,u);if(r&&r.valid){const t=ip(r);if(c.has(t)){const n=c.get(t);n.pixelCount++,e.captureZValues&&r.zValue<n.info.zValue&&(n.info=r),-1===n.attributeIDs.indexOf(r.attributeID)&&n.attributeIDs.push(r.attributeID)}else c.set(t,{info:r,pixelCount:1,attributeIDs:[r.attributeID]})}}return dp(e.fieldAssociation,c,e.captureZValues,e.renderer,e.openGLRenderWindow)}(s,...t)}};return s},e.captureBuffers=()=>{if(!t._renderer||!t._openGLRenderWindow)return ap("Renderer and view must be set before calling Select."),!1;t._openGLRenderer=t._openGLRenderWindow.getViewNodeFor(t._renderer),t._openGLRenderWindow.getRenderable().preRender(),e.invokeEvent({type:"StartEvent"}),t.originalBackground=t._renderer.getBackgroundByReference(),t._renderer.setBackground(0,0,0,0);const n=t._openGLRenderWindow.getRenderPasses();e.beginSelection();const r=[];for(t.currentPass=tp.MIN_KNOWN_PASS;t.currentPass<=tp.MAX_KNOWN_PASS;t.currentPass++)e.passRequired(t.currentPass)&&(e.preCapturePass(t.currentPass),t.captureZValues&&t.currentPass===tp.ACTOR_PASS&&"function"==typeof n[0].requestDepth&&"function"==typeof n[0].getFramebuffer?(n[0].requestDepth(),t._openGLRenderWindow.traverseAllPasses()):t._openGLRenderWindow.traverseAllPasses(),e.postCapturePass(t.currentPass),e.savePixelBuffer(t.currentPass),r.push(t.currentPass));return r.forEach((n=>{t.currentPass=n,e.processPixelBuffers()})),t.currentPass=tp.MAX_KNOWN_PASS,e.endSelection(),t._renderer.setBackground(t.originalBackground),e.invokeEvent({type:"EndEvent"}),!0},e.processPixelBuffers=()=>{t.props.forEach(((n,r)=>{e.isPropHit(r)&&n.processSelectorPixelBuffers(e,t.propPixels[r])}))},e.passRequired=e=>{if(e===tp.ID_HIGH24){if(t.fieldAssociation===op.FIELD_ASSOCIATION_POINTS)return t.maximumPointId>16777215;if(t.fieldAssociation===op.FIELD_ASSOCIATION_CELLS)return t.maximumCellId>16777215}return!0},e.savePixelBuffer=n=>{if(t.pixBuffer[n]=t._openGLRenderWindow.getPixelData(t.area[0],t.area[1],t.area[2],t.area[3]),!t.rawPixBuffer[n]){const e=(t.area[2]-t.area[0]+1)*(t.area[3]-t.area[1]+1)*4;t.rawPixBuffer[n]=new Uint8Array(e),t.rawPixBuffer[n].set(t.pixBuffer[n])}if(n===tp.ACTOR_PASS){if(t.captureZValues){const e=t._openGLRenderWindow.getRenderPasses();if("function"==typeof e[0].requestDepth&&"function"==typeof e[0].getFramebuffer){const n=e[0].getFramebuffer();n.saveCurrentBindingsAndBuffers(),n.bind(),t.zBuffer=t._openGLRenderWindow.getPixelData(t.area[0],t.area[1],t.area[2],t.area[3]),n.restorePreviousBindingsAndBuffers()}}e.buildPropHitList(t.rawPixBuffer[n])}},e.buildPropHitList=e=>{let n=0;for(let r=0;r<=t.area[3]-t.area[1];r++)for(let o=0;o<=t.area[2]-t.area[0];o++){let a=lp(o,r,e,t.area);a>0&&(a--,a in t.hitProps||(t.hitProps[a]=!0,t.propPixels[a]=[]),t.propPixels[a].push(4*n)),++n}},e.renderProp=n=>{t.currentPass===tp.ACTOR_PASS&&(e.setPropColorValueFromInt(t.props.length+1),t.props.push(n))},e.renderCompositeIndex=n=>{t.currentPass===tp.COMPOSITE_INDEX_PASS&&e.setPropColorValueFromInt(n+1)},e.renderAttributeId=e=>{e<0||(t.maxAttributeId=e>t.maxAttributeId?e:t.maxAttributeId)},e.passTypeToString=e=>Ht.enumToString(tp,e),e.isPropHit=e=>Boolean(t.hitProps[e]),e.setPropColorValueFromInt=e=>{t.propColorValue[0]=e%256/255,t.propColorValue[1]=Math.floor(e/256)%256/255,t.propColorValue[2]=Math.floor(e/65536)%256/255},e.getPixelInformation=(n,r,o)=>{const a=r<0?0:r;if(0===a){if(o[0]=n[0],o[1]=n[1],n[0]<t.area[0]||n[0]>t.area[2]||n[1]<t.area[1]||n[1]>t.area[3])return null;const e=[n[0]-t.area[0],n[1]-t.area[1]],r=lp(e[0],e[1],t.pixBuffer[tp.ACTOR_PASS],t.area);if(r<=0||r-1>=t.props.length)return null;const a={valid:!0};a.propID=r-1,a.prop=t.props[a.propID];let i=lp(e[0],e[1],t.pixBuffer[tp.COMPOSITE_INDEX_PASS],t.area);if((i<0||i>16777215)&&(i=0),a.compositeID=i-1,t.captureZValues){const r=4*(e[1]*(t.area[2]-t.area[0]+1)+e[0]);a.zValue=(256*t.zBuffer[r]+t.zBuffer[r+1])/65535,a.displayPosition=n}if(t.pixBuffer[tp.ID_LOW24]&&0===sp(e[0],e[1],t.pixBuffer[tp.ID_LOW24],t.area))return a;const s=lp(e[0],e[1],t.pixBuffer[tp.ID_LOW24],t.area),l=lp(e[0],e[1],t.pixBuffer[tp.ID_HIGH24],t.area);return a.attributeID=cp(s,l),a}const i=[n[0],n[1]],s=[0,0];let l=e.getPixelInformation(n,0,o);if(l&&l.valid)return l;for(let t=1;t<a;++t){for(let n=i[1]>t?i[1]-t:0;n<=i[1]+t;++n){if(s[1]=n,i[0]>=t&&(s[0]=i[0]-t,l=e.getPixelInformation(s,0,o),l&&l.valid))return l;if(s[0]=i[0]+t,l=e.getPixelInformation(s,0,o),l&&l.valid)return l}for(let n=i[0]>=t?i[0]-(t-1):0;n<=i[0]+(t-1);++n){if(s[0]=n,i[1]>=t&&(s[1]=i[1]-t,l=e.getPixelInformation(s,0,o),l&&l.valid))return l;if(s[1]=i[1]+t,l=e.getPixelInformation(s,0,o),l&&l.valid)return l}}return o[0]=n[0],o[1]=n[1],null},e.generateSelection=(n,r,o,a)=>{const i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=Math.floor(a),u=new Map,d=[0,0];for(let n=s;n<=c;n++)for(let r=i;r<=l;r++){const o=[r,n],a=e.getPixelInformation(o,0,d);if(a&&a.valid){const e=ip(a);if(u.has(e)){const n=u.get(e);n.pixelCount++,t.captureZValues&&a.zValue<n.info.zValue&&(n.info=a),-1===n.attributeIDs.indexOf(a.attributeID)&&n.attributeIDs.push(a.attributeID)}else u.set(e,{info:a,pixelCount:1,attributeIDs:[a.attributeID]})}}return dp(t.fieldAssociation,u,t.captureZValues,t._renderer,t._openGLRenderWindow)},e.getRawPixelBuffer=e=>t.rawPixBuffer[e],e.getPixelBuffer=e=>t.pixBuffer[e],e.attach=(e,n)=>{t._openGLRenderWindow=e,t._renderer=n};const n=e.setArea;e.setArea=function(){return!!n(...arguments)&&(t.area[0]=Math.floor(t.area[0]),t.area[1]=Math.floor(t.area[1]),t.area[2]=Math.floor(t.area[2]),t.area[3]=Math.floor(t.area[3]),!0)}}(e,t)}var gp={newInstance:Ht.newInstance(fp,"vtkOpenGLHardwareSelector"),extend:fp,...Cl};const{vtkErrorMacro:mp}=jt,{Representation:hp}=ts,{ObjectType:vp}=fu,{PassTypes:Tp}=gp,yp={type:"StartEvent"},bp={type:"EndEvent"},xp={normalMatrix:null,mcpcMatrix:null,mcwcMatrix:null};const Cp=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,xp,n),Td.extend(e,t,n),t.tmpMat3=pe(new Float64Array(9)),t.normalMatrix=pe(new Float64Array(9)),t.mcpcMatrix=g(new Float64Array(16)),t.mcvcMatrix=g(new Float64Array(16)),t.tmpColor=[],t.glyphBOBuildTime={},vt(t.glyphBOBuildTime,{mtime:0}),function(e,t){t.classHierarchy.push("vtkOpenGLGlyph3DMapper");const n={...e};e.renderPiece=(n,r)=>{if(e.invokeEvent(yp),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(1),e.invokeEvent(bp),!t.currentInput)return void mp("No input!");if(!t.currentInput.getPoints||!t.currentInput.getPoints().getNumberOfValues())return;const o=t.context;t._openGLRenderWindow.getWebgl2()?(t.hardwareSupport=!0,t.extension=null):t.extension||(t.extension=t.context.getExtension("ANGLE_instanced_arrays"),t.hardwareSupport=!!t.extension);const a=r.getProperty().getBackfaceCulling(),i=r.getProperty().getFrontfaceCulling();a||i?i?(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.FRONT)):(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.BACK)):t._openGLRenderWindow.disableCullFace(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)},e.multiply4x4WithOffset=(e,t,n,r)=>{const o=t[0],a=t[1],i=t[2],s=t[3],l=t[4],c=t[5],u=t[6],d=t[7],p=t[8],f=t[9],g=t[10],m=t[11],h=t[12],v=t[13],T=t[14],y=t[15];let b=n[r],x=n[r+1],C=n[r+2],S=n[r+3];e[0]=b*o+x*l+C*p+S*h,e[1]=b*a+x*c+C*f+S*v,e[2]=b*i+x*u+C*g+S*T,e[3]=b*s+x*d+C*m+S*y,b=n[r+4],x=n[r+5],C=n[r+6],S=n[r+7],e[4]=b*o+x*l+C*p+S*h,e[5]=b*a+x*c+C*f+S*v,e[6]=b*i+x*u+C*g+S*T,e[7]=b*s+x*d+C*m+S*y,b=n[r+8],x=n[r+9],C=n[r+10],S=n[r+11],e[8]=b*o+x*l+C*p+S*h,e[9]=b*a+x*c+C*f+S*v,e[10]=b*i+x*u+C*g+S*T,e[11]=b*s+x*d+C*m+S*y,b=n[r+12],x=n[r+13],C=n[r+14],S=n[r+15],e[12]=b*o+x*l+C*p+S*h,e[13]=b*a+x*c+C*f+S*v,e[14]=b*i+x*u+C*g+S*T,e[15]=b*s+x*d+C*m+S*y},e.replaceShaderNormal=(e,r,o)=>{if(t.hardwareSupport&&t.lastBoundBO.getReferenceByName("lastLightComplexity")>0){let n=e.Vertex;t.lastBoundBO.getCABO().getNormalOffset()&&(n=wu.substitute(n,"//VTK::Normal::Dec",["attribute vec3 normalMC;","attribute mat3 gNormal;","uniform mat3 normalMatrix;","varying vec3 normalVCVSOutput;"]).result,n=wu.substitute(n,"//VTK::Normal::Impl",["normalVCVSOutput = normalMatrix * gNormal * normalMC;"]).result),e.Vertex=n}n.replaceShaderNormal(e,r,o)},e.replaceShaderColor=(e,r,o)=>{if(t.hardwareSupport&&t.renderable.getColorArray()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;const a=t.lastBoundBO.getReferenceByName("lastLightComplexity");let i=["uniform float ambient;","uniform float diffuse;","uniform float specular;","uniform float opacityUniform; // the fragment opacity"];a&&(i=i.concat(["uniform vec3 specularColorUniform;","uniform float specularPowerUniform;"]));let s=["vec3 ambientColor;","  vec3 diffuseColor;","  float opacity;"];a&&(s=s.concat(["  vec3 specularColor;","  float specularPower;"])),s=s.concat(["  opacity = opacityUniform;"]),a&&(s=s.concat(["  specularColor = specularColorUniform;","  specularPower = specularPowerUniform;"])),t.drawingEdges||(i=i.concat(["varying vec4 vertexColorVSOutput;"]),n=wu.substitute(n,"//VTK::Color::Dec",["attribute vec4 gColor;","varying vec4 vertexColorVSOutput;"]).result,n=wu.substitute(n,"//VTK::Color::Impl",["vertexColorVSOutput = gColor;"]).result,r=wu.substitute(r,"//VTK::Color::Dec",["in vec4 vertexColorVSOutput[];","out vec4 vertexColorGSOutput;"]).result,r=wu.substitute(r,"//VTK::Color::Impl",["vertexColorGSOutput = vertexColorVSOutput[i];"]).result,s=s.concat(["  diffuseColor = vertexColorVSOutput.rgb;","  ambientColor = vertexColorVSOutput.rgb;","  opacity = opacity*vertexColorVSOutput.a;"])),o=wu.substitute(o,"//VTK::Color::Impl",s).result,o=wu.substitute(o,"//VTK::Color::Dec",i).result,e.Vertex=n,e.Geometry=r,e.Fragment=o}n.replaceShaderColor(e,r,o)},e.replaceShaderPositionVC=(e,r,o)=>{if(t.hardwareSupport){let n=e.Vertex;t.lastBoundBO.getReferenceByName("lastLightComplexity")>0?(n=wu.substitute(n,"//VTK::PositionVC::Impl",["vec4 gVertexMC = gMatrix * vertexMC;","vertexVCVSOutput = MCVCMatrix * gVertexMC;","  gl_Position = MCPCMatrix * gVertexMC;"]).result,n=wu.substitute(n,"//VTK::Camera::Dec",["attribute mat4 gMatrix;","uniform mat4 MCPCMatrix;","uniform mat4 MCVCMatrix;"]).result):(n=wu.substitute(n,"//VTK::Camera::Dec",["attribute mat4 gMatrix;","uniform mat4 MCPCMatrix;"]).result,n=wu.substitute(n,"//VTK::PositionVC::Impl",["vec4 gVertexMC = gMatrix * vertexMC;","  gl_Position = MCPCMatrix * gVertexMC;"]).result),e.Vertex=n}n.replaceShaderPositionVC(e,r,o)},e.replaceShaderPicking=(e,r,o)=>{if(t.hardwareSupport){let t=e.Fragment,n=e.Vertex;n=wu.substitute(n,"//VTK::Picking::Dec",["attribute vec3 mapperIndexVS;","varying vec3 mapperIndexVSOutput;"]).result,n=wu.substitute(n,"//VTK::Picking::Impl","  mapperIndexVSOutput = mapperIndexVS;").result,e.Vertex=n,t=wu.substitute(t,"//VTK::Picking::Dec",["varying vec3 mapperIndexVSOutput;","uniform vec3 mapperIndex;","uniform int picking;"]).result,t=wu.substitute(t,"//VTK::Picking::Impl",["  vec4 pickColor = picking == 2 ? vec4(mapperIndexVSOutput,1.0) : vec4(mapperIndex,1.0);","  gl_FragData[0] = picking != 0 ? pickColor : gl_FragData[0];"]).result,e.Fragment=t}else n.replaceShaderPicking(e,r,o)},e.updateGlyphShaderParameters=(n,r,o,a,i,s,l,c)=>{const u=o.getProgram();if(n){const e=t.normalMatrix,n=s,r=9*l,o=t.tmpMat3,a=e[0],i=e[1],c=e[2],d=e[3],p=e[4],f=e[5],g=e[6],m=e[7],h=e[8],v=n[r],T=n[r+1],y=n[r+2],b=n[r+3],x=n[r+4],C=n[r+5],S=n[r+6],A=n[r+7],I=n[r+8];o[0]=v*a+T*d+y*g,o[1]=v*i+T*p+y*m,o[2]=v*c+T*f+y*h,o[3]=b*a+x*d+C*g,o[4]=b*i+x*p+C*m,o[5]=b*c+x*f+C*h,o[6]=S*a+A*d+I*g,o[7]=S*i+A*p+I*m,o[8]=S*c+A*f+I*h,u.setUniformMatrix3x3("normalMatrix",t.tmpMat3)}if(e.multiply4x4WithOffset(t.tmpMat4,t.mcpcMatrix,i,16*l),u.setUniformMatrix("MCPCMatrix",t.tmpMat4),r&&(e.multiply4x4WithOffset(t.tmpMat4,t.mcvcMatrix,i,16*l),u.setUniformMatrix("MCVCMatrix",t.tmpMat4)),a){const e=a.getData();t.tmpColor[0]=e[4*l]/255,t.tmpColor[1]=e[4*l+1]/255,t.tmpColor[2]=e[4*l+2]/255,u.setUniform3fArray("ambientColorUniform",t.tmpColor),u.setUniform3fArray("diffuseColorUniform",t.tmpColor)}c&&u.setUniform3fArray("mapperIndex",c.getPropColorValue())},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation(),a=t.context,i=r.getProperty().getEdgeVisibility()&&o===hp.SURFACE,s=t.openGLCamera.getKeyMatrices(n),l=t.openGLActor.getKeyMatrices();ve(t.normalMatrix,s.normalMatrix,l.normalMatrix),y(t.mcpcMatrix,s.wcpc,l.mcwc),y(t.mcvcMatrix,s.wcvc,l.mcwc);const c=t.renderable.getMatrixArray(),u=t.renderable.getNormalArray(),d=t.renderable.getColorArray(),p=c.length/16;let f=!1;t._openGLRenderer.getSelector()&&t._openGLRenderer.getSelector().getCurrentPass()===Tp.COMPOSITE_INDEX_PASS&&(f=!0);for(let s=t.primTypes.Start;s<t.primTypes.End;s++){const l=t.primitives[s].getCABO();if(l.getElementCount()){t.drawingEdges=i&&(s===t.primTypes.TrisEdges||s===t.primTypes.TriStripsEdges),t.lastBoundBO=t.primitives[s],t.primitives[s].updateShaders(n,r,e);const g=t.primitives[s].getProgram(),m=t.primitives[s].getOpenGLMode(o),h=g.isUniformUsed("normalMatrix"),v=g.isUniformUsed("MCVCMatrix");if(t.hardwareSupport)t.extension?t.extension.drawArraysInstancedANGLE(m,0,l.getElementCount(),p):a.drawArraysInstanced(m,0,l.getElementCount(),p);else for(let n=0;n<p;++n)f&&t._openGLRenderer.getSelector().renderCompositeIndex(n),e.updateGlyphShaderParameters(h,v,t.primitives[s],d,c,u,n,f?t._openGLRenderer.getSelector():null),a.drawArrays(m,0,l.getElementCount())}}},e.setMapperShaderParameters=(e,r,o)=>{if(e.getCABO().getElementCount()&&(t.glyphBOBuildTime.getMTime()>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime()))return e.getProgram().isAttributeUsed("gMatrix")?e.getVAO().addAttributeMatrixWithDivisor(e.getProgram(),t.matrixBuffer,"gMatrix",0,64,t.context.FLOAT,4,!1,1)||mp("Error setting gMatrix in shader VAO."):e.getVAO().removeAttributeArray("gMatrix"),e.getProgram().isAttributeUsed("gNormal")?e.getVAO().addAttributeMatrixWithDivisor(e.getProgram(),t.normalBuffer,"gNormal",0,36,t.context.FLOAT,3,!1,1)||mp("Error setting gNormal in shader VAO."):e.getVAO().removeAttributeArray("gNormal"),e.getProgram().isAttributeUsed("gColor")?e.getVAO().addAttributeArrayWithDivisor(e.getProgram(),t.colorBuffer,"gColor",0,4,t.context.UNSIGNED_BYTE,4,!0,1,!1)||mp("Error setting gColor in shader VAO."):e.getVAO().removeAttributeArray("gColor"),e.getProgram().isAttributeUsed("mapperIndexVS")?e.getVAO().addAttributeArrayWithDivisor(e.getProgram(),t.pickBuffer,"mapperIndexVS",0,4,t.context.UNSIGNED_BYTE,4,!0,1,!1)||mp("Error setting mapperIndexVS in shader VAO."):e.getVAO().removeAttributeArray("mapperIndexVS"),n.setMapperShaderParameters(e,r,o),void e.getAttributeUpdateTime().modified();n.setMapperShaderParameters(e,r,o)},e.getNeedToRebuildBufferObjects=(e,r)=>(t.renderable.buildArrays(),t.VBOBuildTime.getMTime()<t.renderable.getBuildTime().getMTime()||n.getNeedToRebuildBufferObjects(e,r)),e.getNeedToRebuildShaders=(e,r,o)=>!!(n.getNeedToRebuildShaders(e,r,o)||e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime()),e.buildBufferObjects=(e,r)=>{if(t.hardwareSupport){const e=t.renderable.getMatrixArray(),n=t.renderable.getNormalArray(),r=t.renderable.getColorArray();if(t.matrixBuffer||(t.matrixBuffer=fu.newInstance(),t.matrixBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.normalBuffer=fu.newInstance(),t.normalBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.colorBuffer=fu.newInstance(),t.colorBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.pickBuffer=fu.newInstance(),t.pickBuffer.setOpenGLRenderWindow(t._openGLRenderWindow)),t.renderable.getBuildTime().getMTime()>t.glyphBOBuildTime.getMTime()){t.matrixBuffer.upload(e,vp.ARRAY_BUFFER),t.normalBuffer.upload(n,vp.ARRAY_BUFFER),r?t.colorBuffer.upload(r.getData(),vp.ARRAY_BUFFER):t.colorBuffer.releaseGraphicsResources();const o=e.length/16,a=new Uint8Array(4*o);for(let e=0;e<o;++e){let t=e+1;const n=4*e;a[n]=t%256,t-=a[n],t/=256,a[n+1]=t%256,t-=a[n+1],t/=256,a[n+2]=t%256,a[n+3]=255}t.pickBuffer.upload(a,vp.ARRAY_BUFFER),t.glyphBOBuildTime.modified()}}return n.buildBufferObjects(e,r)}}(e,t)}),"vtkOpenGLGlyph3DMapper");en("vtkGlyph3DMapper",Cp);const{vtkErrorMacro:Sp}=Ht;class Ap{constructor(){this.segmentMapping={},this.segments=[null],this.faces=[]}addSegment(e){const t=e[0],n=e[e.length-1];if(t===n||e.length<2)return;const r=this.segmentMapping[t],o=this.segmentMapping[n];if(void 0!==r&&void 0!==o)if(Math.abs(r)===Math.abs(o)){const a=r<o?o:r,i=this.segments[a];if(r>0)for(let t=1;t<e.length-1;t++)i.push(e[t]);else for(let t=1;t<e.length-1;t++)i.unshift(e[e.length-1-t]);this.faces.push(i),this.segments[a]=null,this.segmentMapping[t]=void 0,this.segmentMapping[n]=void 0}else{const t=Math.abs(r),n=Math.abs(o),a=this.segments[t],i=this.segments[n];this.segments[t]=null,this.segments[n]=null,this.segmentMapping[a[0]]=void 0,this.segmentMapping[i[0]]=void 0,this.segmentMapping[a[a.length-1]]=void 0,this.segmentMapping[i[i.length-1]]=void 0,this.addSegment(e),this.addSegment(a),this.addSegment(i)}else if(void 0!==r){if(r>0){const t=this.segments[r];for(let n=1;n<e.length;n++)t.push(e[n]);this.segmentMapping[n]=r}else{const t=this.segments[-r];this.segmentMapping[n]=r;for(let n=1;n<e.length;n++)t.unshift(e[n])}this.segmentMapping[t]=void 0}else if(void 0!==o){if(o>0){const n=this.segments[o];for(let t=1;t<e.length;t++)n.push(e[e.length-1-t]);this.segmentMapping[t]=o}else{const n=this.segments[-o];this.segmentMapping[t]=o;for(let t=1;t<e.length;t++)n.unshift(e[e.length-t-1])}this.segmentMapping[n]=void 0}else{const r=this.segments.length;this.segments.push(e),this.segmentMapping[t]=-r,this.segmentMapping[n]=r}}}const Ip={};function wp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ip,n),Ht.obj(e,t),Ht.algo(e,t,1,1),function(e,t){t.classHierarchy.push("vtkClosedPolyLineToSurfaceFilter"),e.requestData=(e,t)=>{const n=e[0];if(!n)return void Sp("Invalid or missing input");const r=kc.newInstance();r.shallowCopy(n);const o=new Ap,a=n.getLines().getData();let i=0;for(;i<a.length;){const e=a[i++],t=[];for(let n=0;n<e;n++)t.push(a[i+n]);o.addSegment(t),i+=e}const{faces:s}=o;let l=s.length;for(let e=0;e<s.length;e++)l+=s[e].length;const c=new Uint16Array(l);i=0;for(let e=0;e<s.length;e++){const t=s[e];c[i++]=t.length;for(let e=0;e<t.length;e++)c[i++]=t[e]}r.setPolys(zl.newInstance({values:c,name:"faces"})),t[0]=r}}(e,t)}var Op={newInstance:Ht.newInstance(wp,"vtkClosedPolyLineToSurfaceFilter"),extend:wp};const{vtkErrorMacro:Pp}=jt;function Rp(e,t){t.classHierarchy.push("vtkCutter");const n={...e};e.getMTime=()=>{let e=n.getMTime();return t.cutFunction?(e=Math.max(e,t.cutFunction.getMTime()),e):e},e.requestData=(e,n)=>{const r=e[0];if(!r)return void Pp("Invalid or missing input");if(!t.cutFunction)return void Pp("Missing cut function");const o=kc.newInstance();(function(e,n){const r=e.getPoints(),o=r.getData(),a=r.getNumberOfPoints(),i=[],s=[],l=[];(!t.cutScalars||t.cutScalars.length<a)&&(t.cutScalars=new Float32Array(a));let c=0,u=0;for(;c<o.length;)t.cutScalars[u++]=t.cutFunction.evaluateFunction(o[c++],o[c++],o[c++]);const d=[],p=new Array(3),f=new Array(3),g=[];for(const n=function(e){const t=e.getPolys().getData(),n=e.getStrips().getData(),r={cellSize:0,cell:[],done:!1,polyIdx:0,stripIdx:0,remainingStripLength:0,next(){if(r.polyIdx<t.length){r.cellSize=t[r.polyIdx];const e=r.polyIdx+1,n=e+r.cellSize;r.polyIdx=n;let o=0;for(let a=e;a<n;++a)r.cell[o++]=t[a]}else if(r.stripIdx<n.length){r.cellSize=3,0===r.remainingStripLength&&(r.remainingStripLength=n[r.stripIdx]-2,r.stripIdx+=3);const e=r.stripIdx-2,t=r.stripIdx+1;r.stripIdx++,r.remainingStripLength--;let o=0;for(let a=e;a<t;++a)r.cell[o++]=n[a]}else{if(r.done)throw new Error("Iterator is done");r.done=!0}}};return r.next(),r}(e);!n.done;n.next()){if(n.cellSize<=2)continue;for(let e=0;e<n.cellSize;)g[e]=t.cutScalars[n.cell[e++]];const e=g[0]>0;let r=!0;for(let t=1;t<n.cell.length;t++)if(g[t]>0!==e){r=!1;break}if(r)continue;const a=[];for(let e=0;e<n.cellSize;e++){const r=e+1===n.cellSize?0:e+1,i=g[e]>0;if(g[r]>0===i)continue;let s=e,l=r,c=g[l]-g[s];c<=0&&(s=r,l=e,c*=-1);let u=0;0!==c&&(u=(t.cutValue-g[s])/c);const d=n.cell[s],m=n.cell[l];p[0]=o[3*d],p[1]=o[3*d+1],p[2]=o[3*d+2],f[0]=o[3*m],f[1]=o[3*m+1],f[2]=o[3*m+2];const h=[p[0]+u*(f[0]-p[0]),p[1]+u*(f[1]-p[1]),p[2]+u*(f[2]-p[2])];a.push({pointEdge1:d,pointEdge2:m,intersectedPoint:h,newPointID:-1})}for(let e=0;e<a.length;e++){const t=a[e];let n=!1;for(let r=0;r<d.length;r++){const o=d[r],i=t.pointEdge1===o.pointEdge1&&t.pointEdge2===o.pointEdge2,s=t.intersectedPoint[0]===o.intersectedPoint[0]&&t.intersectedPoint[1]===o.intersectedPoint[1]&&t.intersectedPoint[2]===o.intersectedPoint[2];if(i||s){n=!0,a[e].newPointID=d[r].newPointID;break}}n||(i.push(t.intersectedPoint[0]),i.push(t.intersectedPoint[1]),i.push(t.intersectedPoint[2]),a[e].newPointID=i.length/3-1,d.push(a[e]))}const c=a.length;2===c?s.push(c,a[0].newPointID,a[1].newPointID):c>2&&(l.push(c),a.forEach((e=>{l.push(e.newPointID)})))}n.getPoints().setData(st(r.getDataType(),i),3),0!==s.length&&n.getLines().setData(Uint16Array.from(s)),0!==l.length&&n.getPolys().setData(Uint16Array.from(l))})(r,o),n[0]=o}}const Mp={cutFunction:null,cutScalars:null,cutValue:0};function Ep(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Mp,n),vt(e,t),Pt(e,t,1,1),St(e,t,["cutFunction","cutValue"]),Rp(e,t)}var Vp={newInstance:Et(Ep,"vtkCutter"),extend:Ep};const Dp=e=>e,Lp=1e-6;class Bp{constructor(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.matrix=g(new Float64Array(16)),this.tmp=new Float64Array(3),this.angleConv=e?l:Dp}rotateFromDirections(e,t){const n=new Float64Array(3),r=new Float64Array(3),o=new Float64Array(16);vn(n,e[0],e[1],e[2]),vn(r,t[0],t[1],t[2]),Sn(n,n),Sn(r,r);const a=An(n,r);return a>=1||(In(this.tmp,n,r),mn(this.tmp)<Lp&&(In(this.tmp,[1,0,0],e),mn(this.tmp)<Lp&&In(this.tmp,[0,1,0],e)),P(o,Math.acos(a),this.tmp),y(this.matrix,this.matrix,o)),this}rotate(e,t){return vn(this.tmp,...t),Sn(this.tmp,this.tmp),C(this.matrix,this.matrix,this.angleConv(e),this.tmp),this}rotateX(e){return S(this.matrix,this.matrix,this.angleConv(e)),this}rotateY(e){return A(this.matrix,this.matrix,this.angleConv(e)),this}rotateZ(e){return I(this.matrix,this.matrix,this.angleConv(e)),this}translate(e,t,n){return vn(this.tmp,e,t,n),b(this.matrix,this.matrix,this.tmp),this}scale(e,t,n){return vn(this.tmp,e,t,n),x(this.matrix,this.matrix,this.tmp),this}multiply(e){return y(this.matrix,this.matrix,e),this}multiply3x3(e){return y(this.matrix,this.matrix,[e[0],e[1],e[2],0,e[3],e[4],e[5],0,e[6],e[7],e[8],0,0,0,0,1]),this}invert(){return h(this.matrix,this.matrix),this}identity(){return g(this.matrix),this}apply(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(Yo(so,this.matrix))return this;const r=-1===n?e.length:t+3*n;for(let n=t;n<r;n+=3)vn(this.tmp,e[n],e[n+1],e[n+2]),wn(this.tmp,this.tmp,this.matrix),e[n]=this.tmp[0],e[n+1]=this.tmp[1],e[n+2]=this.tmp[2];return this}getMatrix(){return this.matrix}setMatrix(e){return e&&16===e.length&&d(this.matrix,e),this}}var Np=function(){return new Bp(!0)},Fp=function(){return new Bp(!1)};const _p=[2,0,1,2,2,3,2,4,5,2,6,7,2,0,2,2,1,3,2,4,6,2,5,7,2,0,4,2,1,5,2,2,6,2,3,7],kp=[4,0,1,3,2,4,4,6,7,5,4,8,10,11,9,4,12,13,15,14,4,16,18,19,17,4,20,21,23,22],Gp={xLength:1,yLength:1,zLength:1,pointType:"Float64Array",generate3DTextureCoordinates:!1,generateFaces:!0,generateLines:!1};function Up(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Gp,n),Ht.obj(e,t),Ht.setGet(e,t,["xLength","yLength","zLength","generate3DTextureCoordinates","generateFaces","generateLines"]),Ht.setGetArray(e,t,["center","rotations"],3),Ht.setGetArray(e,t,["matrix"],16),t._polys=zl.newInstance({values:Uint16Array.from(kp)}),t._lineCells=zl.newInstance({values:Uint16Array.from(_p)}),Ht.moveToProtected(e,t,["polys","lineCells"]),Ht.algo(e,t,0,1),function(e,t){t.classHierarchy.push("vtkCubeSource"),e.setBounds=function(){let t=[];if(Array.isArray(arguments.length<=0?void 0:arguments[0]))t=arguments.length<=0?void 0:arguments[0];else for(let e=0;e<arguments.length;e++)t.push(e<0||arguments.length<=e?void 0:arguments[e]);6===t.length&&(e.setXLength(t[1]-t[0]),e.setYLength(t[3]-t[2]),e.setZLength(t[5]-t[4]),e.setCenter([(t[0]+t[1])/2,(t[2]+t[3])/2,(t[4]+t[5])/2]))},e.requestData=function(e,n){if(t.deleted)return;const r=kc.newInstance();n[0]=r;const o=Ht.newTypedArray(t.pointType,72);r.getPoints().setData(o,3);const a=Ht.newTypedArray(t.pointType,72),i=Ts.newInstance({name:"Normals",values:a,numberOfComponents:3});r.getPointData().setNormals(i);let s=2;!0===t.generate3DTextureCoordinates&&(s=3);const l=Ht.newTypedArray(t.pointType,24*s),c=Ts.newInstance({name:"TextureCoordinates",values:l,numberOfComponents:s});r.getPointData().setTCoords(c);const u=[0,0,0],d=[0,0,0],p=[0,0];let f=0;u[0]=-t.xLength/2,d[0]=-1,d[1]=0,d[2]=0;for(let e=0;e<2;e++){u[1]=-t.yLength/2;for(let n=0;n<2;n++){p[1]=u[1]+.5,u[2]=-t.zLength/2;for(let r=0;r<2;r++)p[0]=(u[2]+.5)*(1-2*e),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*e-1,l[f*s+1]=2*n-1,l[f*s+2]=2*r-1),f++,u[2]+=t.zLength;u[1]+=t.yLength}u[0]+=t.xLength,d[0]+=2}u[1]=-t.yLength/2,d[1]=-1,d[0]=0,d[2]=0;for(let e=0;e<2;e++){u[0]=-t.xLength/2;for(let n=0;n<2;n++){p[0]=(u[0]+.5)*(2*e-1),u[2]=-t.zLength/2;for(let r=0;r<2;r++)p[1]=-1*(u[2]+.5),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*n-1,l[f*s+1]=2*e-1,l[f*s+2]=2*r-1),f++,u[2]+=t.zLength;u[0]+=t.xLength}u[1]+=t.yLength,d[1]+=2}u[2]=-t.zLength/2,d[2]=-1,d[0]=0,d[1]=0;for(let e=0;e<2;e++){u[1]=-t.yLength/2;for(let n=0;n<2;n++){p[1]=u[1]+.5,u[0]=-t.xLength/2;for(let r=0;r<2;r++)p[0]=(u[0]+.5)*(2*e-1),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*r-1,l[f*s+1]=2*n-1,l[f*s+2]=2*e-1),f++,u[0]+=t.xLength;u[1]+=t.yLength}u[2]+=t.zLength,d[2]+=2}if(t.rotations&&Np().rotateX(t.rotations[0]).rotateY(t.rotations[1]).rotateZ(t.rotations[2]).apply(o).apply(a),t.center&&Fp().translate(...t.center).apply(o),t.matrix){Fp().setMatrix(t.matrix).apply(o);const e=[t.matrix[0],t.matrix[1],t.matrix[2],0,t.matrix[4],t.matrix[5],t.matrix[6],0,t.matrix[8],t.matrix[9],t.matrix[10],0,0,0,0,1];Fp().setMatrix(e).apply(a)}t.generateFaces?r.getPolys().deepCopy(t._polys):r.getPolys().initialize(),t.generateLines?(r.getLines().deepCopy(t._lineCells),r.getPointData().setNormals(null)):r.getLines().initialize(),r.modified()}}(e,t)}var zp={newInstance:Ht.newInstance(Up,"vtkCubeSource"),extend:Up};const{vtkErrorMacro:Wp}=Ht,Hp={};function jp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Hp,n),Ht.obj(e,t),Ht.algo(e,t,1,1),t._cubeSource=zp.newInstance(),Ht.moveToProtected(e,t,["cubeSource","tmpOut"]),function(e,t){t.classHierarchy.push("vtkImageDataOutlineFilter");const n={...e};e.requestData=(e,n)=>{const r=e[0];if(!r||!r.isA("vtkImageData"))return void Wp("Invalid or missing input");const o=r.getSpatialExtent();o?(t._cubeSource.setBounds(o),t._cubeSource.setMatrix(r.getIndexToWorld()),n[0]=t._cubeSource.getOutputData()):Wp("Unable to fetch spatial extents of input image.")},e.getMTime=()=>Math.max(n.getMTime(),t._cubeSource.getMTime()),e.setGenerateFaces=t._cubeSource.setGenerateFaces,e.setGenerateLines=t._cubeSource.setGenerateLines,e.getGenerateFaces=t._cubeSource.getGenerateFaces,e.getGenerateLines=t._cubeSource.getGenerateLines}(e,t)}var Kp={newInstance:Ht.newInstance(jp,"vtkImageDataOutlineFilter"),extend:jp};let $p;const qp={preMultiplyFlag:!1,matrix:[...so]};function Xp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,qp,n),Ht.obj(e,t),Ht.setGet(e,t,["preMultiplyFlag"]),Ht.setGetArray(e,t,["matrix"],16),function(e,t){t.classHierarchy.push("vtkAbstractTransform","vtkHomogeneousTransform","vtkTransform"),e.transformPoint=(e,n)=>(wn(n,e,t.matrix),n),e.transformPoints=(e,n)=>{const r=new Float64Array(3),o=new Float64Array(3);for(let a=0;a<e.length;a+=3)r[0]=e[a],r[1]=e[a+1],r[2]=e[a+2],wn(o,r,t.matrix),n[a]=o[0],n[a+1]=o[1],n[a+2]=o[2];return n},e.preMultiply=()=>{e.setPreMultiplyFlag(!0)},e.postMultiply=()=>{e.setPreMultiplyFlag(!1)},e.transformMatrix=(e,n)=>(t.preMultiplyFlag?y(n,t.matrix,e):y(n,e,t.matrix),n),e.transformMatrices=(e,n)=>{const r=new Float64Array(16),o=new Float64Array(16),a=t.preMultiplyFlag?()=>y(o,t.matrix,r):()=>y(o,r,t.matrix);for(let t=0;t<e.length;t+=16){for(let n=0;n<16;++n)r[n]=e[t+n];a();for(let e=0;e<16;++e)n[t+e]=o[e]}return n},e.getInverse=()=>$p({matrix:La.invertMatrix(Array.from(t.matrix),[],4),preMultiplyFlag:t.preMultiplyFlag})}(e,t)}$p=Ht.newInstance(Xp,"vtkTransform");var Yp={newInstance:$p,extend:Xp};function Zp(e,t,n){return e.length>0?`${e.map((e=>e?.getMTime()??"x")).join("/")}-${t}-${n}`:"0"}function Qp(e,t){return`${t.getMTime()}`}const Jp={NEAREST:0,LINEAR:1};var ef={InterpolationType:Jp};const{vtkErrorMacro:tf}=jt;function nf(e,t,n){return t.identity(n),e.reduce(((e,n,r)=>0===r?n?t.copy(e,n):t.identity(e):n?t.multiply(e,e,n):e),n)}const rf={VBOBuildTime:{},VBOBuildString:null,haveSeenDepthRequest:!1,lastHaveSeenDepthRequest:!1,lastIndependentComponents:!1,lastNumberOfComponents:0,lastMultiTexturePerVolumeEnabled:!1,lastSlabThickness:0,lastSlabTrapezoidIntegration:0,lastSlabType:-1,scalarTextures:[],_scalarTexturesCore:[],colorTexture:null,_colorTextureCore:null,pwfTexture:null,_pwfTextureCore:null,_externalOpenGLTexture:!1,resliceGeom:null,resliceGeomUpdateString:null,tris:null};const of=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,rf,n),Xt.extend(e,t,n),nd(e,t,n),rd(e,t,n),t.tris=Du.newInstance(),t.scalarTextures=[],t.colorTexture=null,t.pwfTexture=null,t.VBOBuildTime={},vt(t.VBOBuildTime),t.tmpMat4=g(new Float64Array(16)),t.outlineFilter=Kp.newInstance(),t.outlineFilter.setGenerateFaces(!0),t.outlineFilter.setGenerateLines(!1),t.cubePolyData=kc.newInstance(),t.cutter=Vp.newInstance(),t.lineToSurfaceFilter=Op.newInstance(),t.transform=Yp.newInstance(),yt(e,t,["scalarTextures"]),function(e,t){t.classHierarchy.push("vtkOpenGLImageResliceMapper");const n=new Map;function o(t,r,o){r!==o&&(function(t,r){if(!r)return;const o=(n.get(r)??0)-1;o<=0?(t.unregisterGraphicsResourceUser(r,e),n.delete(r)):n.set(r,o)}(t,r),function(t,r){if(!r)return;const o=n.get(r)??0,a=o+1;n.set(r,a),o<=0&&t.registerGraphicsResourceUser(r,e)}(t,o))}function a(t){[...n.keys()].forEach((n=>t.unregisterGraphicsResourceUser(n,e)))}e.buildPass=n=>{if(n){t.currentRenderPass=null,t._openGLImageSlice=e.getFirstAncestorOfType("vtkOpenGLImageSlice"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer");const n=t._openGLRenderer.getRenderable();t._openGLCamera=t._openGLRenderer.getViewNodeFor(n.getActiveCamera());const r=t._openGLRenderWindow;t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),r&&!r.isDeleted()&&r!==t._openGLRenderWindow&&a(r),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow)}},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()==dl.PolygonOffset?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t._openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.renderPiece=(n,r)=>{e.invokeEvent({type:"StartEvent"}),t.renderable.update();const o=t.renderable.getNumberOfInputPorts();t.currentValidInputs=[];for(let e=0;e<o;++e){const n=t.renderable.getInputData(e);n&&!n.isDeleted()&&t.currentValidInputs.push({imageData:n,inputIndex:e})}const a=t.currentValidInputs.length;if(a<=0)return void tf("No input!");const i=t.currentValidInputs[0].imageData.getPointData().getScalars();t.multiTexturePerVolumeEnabled=a>1,t.numberOfComponents=t.multiTexturePerVolumeEnabled?a:i.getNumberOfComponents(),e.updateResliceGeometry(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r),e.invokeEvent({type:"EndEvent"})},e.renderPieceStart=(n,r)=>{e.updateBufferObjects(n,r);const o=r.getProperties();t.currentValidInputs.forEach((e=>{let{inputIndex:n}=e;const r=o[n].getInterpolationType(),a=t.scalarTextures[n];r===Jp.NEAREST?(a.setMinificationFilter(Bu.NEAREST),a.setMagnificationFilter(Bu.NEAREST)):(a.setMinificationFilter(Bu.LINEAR),a.setMagnificationFilter(Bu.LINEAR))}));const a=t.currentValidInputs[0];o[a.inputIndex].getInterpolationType()===Jp.NEAREST?(t.colorTexture.setMinificationFilter(Bu.NEAREST),t.colorTexture.setMagnificationFilter(Bu.NEAREST),t.pwfTexture.setMinificationFilter(Bu.NEAREST),t.pwfTexture.setMagnificationFilter(Bu.NEAREST)):(t.colorTexture.setMinificationFilter(Bu.LINEAR),t.colorTexture.setMagnificationFilter(Bu.LINEAR),t.pwfTexture.setMinificationFilter(Bu.LINEAR),t.pwfTexture.setMagnificationFilter(Bu.LINEAR)),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=t.context,a=[...t.scalarTextures,t.colorTexture,t.pwfTexture];a.forEach((e=>e.activate())),e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),a.forEach((e=>e.deactivate()))},e.renderPieceFinish=(e,t)=>{},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty(t.currentValidInputs[0].inputIndex)?.getMTime()||t.currentValidInputs.some((e=>{let{imageData:n}=e;return t.VBOBuildTime.getMTime()<n.getMTime()}))||t.VBOBuildTime.getMTime()<t.resliceGeom.getMTime()||t.scalarTextures.length!==t.currentValidInputs.length||!t.scalarTextures.every((e=>!!e?.getHandle()))||!t.colorTexture?.getHandle()||!t.pwfTexture?.getHandle(),e.buildBufferObjects=(e,n)=>{const r=n.getProperties();t.currentValidInputs.forEach(((e,n)=>{let{imageData:a}=e;const i=a.getPointData().getScalars(),s=t._openGLRenderWindow.getGraphicsResourceForObject(i),l=Qp(0,i),c=!s?.oglObject?.getHandle()||s?.hash!==l,u=r[n],d=u.getUpdatedExtents(),p=!!d.length;if(c&&!p){const e=Ju.newInstance();e.setOpenGLRenderWindow(t._openGLRenderWindow);const r=a.getDimensions();e.setOglNorm16Ext(t.context.getExtension("EXT_texture_norm16")),e.resetFormatAndType(),e.create3DFilterableFromDataArray({width:r[0],height:r[1],depth:r[2],dataArray:i}),t._openGLRenderWindow.setGraphicsResourceForObject(i,e,l),t.scalarTextures[n]=e}else t.scalarTextures[n]=s.oglObject;if(p){u.setUpdatedExtents([]);const e=a.getDimensions();t.scalarTextures[n].create3DFilterableFromDataArray({width:e[0],height:e[1],depth:e[2],dataArray:i,updatedExtents:d})}o(t._openGLRenderWindow,t._scalarTexturesCore[n],i),t._scalarTexturesCore[n]=i}));const a=t.currentValidInputs[0],i=r[a.inputIndex],s=i.getIndependentComponents(),l=s?t.numberOfComponents:1,c=s?2*l:1,u=[];for(let e=0;e<l;++e)u.push(i.getRGBTransferFunction(e));const d=Zp(u,s,l),p=i.getRGBTransferFunction(),f=t._openGLRenderWindow.getGraphicsResourceForObject(p);if(f?.oglObject?.getHandle()&&f?.hash===d)t.colorTexture=f.oglObject;else{let e=t.renderable.getColorTextureWidth();e<=0&&(e=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const n=new Uint8ClampedArray(e*c*3),r=Ju.newInstance();if(r.setOpenGLRenderWindow(t._openGLRenderWindow),p){const t=new Float32Array(3*e);for(let r=0;r<l;r++){const o=i.getRGBTransferFunction(r),a=o.getRange();if(o.getTable(a[0],a[1],e,t,1),s)for(let o=0;o<3*e;o++)n[r*e*6+o]=255*t[o],n[r*e*6+o+3*e]=255*t[o];else for(let o=0;o<3*e;o++)n[r*e*3+o]=255*t[o]}r.resetFormatAndType(),r.create2DFromRaw({width:e,height:c,numComps:3,dataType:is.UNSIGNED_CHAR,data:n})}else{for(let t=0;t<3*e;++t){const r=255*t/(3*(e-1));for(let o=0;o<c;++o)n[o*e*3+t+0]=r,n[o*e*3+t+1]=r,n[o*e*3+t+2]=r}r.resetFormatAndType(),r.create2DFromRaw({width:e,height:1,numComps:3,dataType:is.UNSIGNED_CHAR,data:n})}p&&t._openGLRenderWindow.setGraphicsResourceForObject(p,r,d),t.colorTexture=r}o(t._openGLRenderWindow,t._colorTextureCore,p),t._colorTextureCore=p;const g=[];for(let e=0;e<l;++e)g.push(i.getPiecewiseFunction(e));const m=Zp(g,s,l),h=i.getPiecewiseFunction(),v=t._openGLRenderWindow.getGraphicsResourceForObject(h);if(v?.oglObject?.getHandle()&&v?.hash===m)t.pwfTexture=v.oglObject;else{let e=t.renderable.getOpacityTextureWidth();e<=0&&(e=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const n=e*c,r=new Uint8ClampedArray(n),o=Ju.newInstance();if(o.setOpenGLRenderWindow(t._openGLRenderWindow),h){const t=new Float32Array(n),r=new Float32Array(e);for(let n=0;n<l;++n){const o=i.getPiecewiseFunction(n);if(null===o)t.fill(1);else{const a=o.getRange();if(o.getTable(a[0],a[1],e,r,1),s)for(let o=0;o<e;o++)t[n*e*2+o]=r[o],t[n*e*2+o+e]=r[o];else for(let n=0;n<e;n++)t[n]=r[n]}}o.resetFormatAndType(),o.create2DFromRaw({width:e,height:c,numComps:1,dataType:is.FLOAT,data:t})}else r.fill(255),o.resetFormatAndType(),o.create2DFromRaw({width:e,height:c,numComps:1,dataType:is.UNSIGNED_CHAR,data:r});h&&t._openGLRenderWindow.setGraphicsResourceForObject(h,o,m),t.pwfTexture=o}o(t._openGLRenderWindow,t._pwfTextureCore,h),t._pwfTextureCore=h;const T=`${t.resliceGeom.getMTime()}A${t.renderable.getSlabThickness()}`;if(!t.tris.getCABO().getElementCount()||t.VBOBuildString!==T){const e=Ts.newInstance({numberOfComponents:3,values:t.resliceGeom.getPoints().getData()});e.setName("points");const n=Ts.newInstance({numberOfComponents:1,values:t.resliceGeom.getPolys().getData()}),r={points:e,cellOffset:0};if(t.renderable.getSlabThickness()>0){const e=t.resliceGeom.getPointData().getNormals();e?r.normals=e:tf("Slab mode requested without normals")}t.tris.getCABO().createVBO(n,"polys",qi.SURFACE,r)}t.VBOBuildString=T,t.VBOBuildTime.modified()},e.updateShaders=(n,r,o)=>{if(t.lastBoundBO=n,e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram(),i=t.currentValidInputs[0].imageData;if(n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())){t.scalarTextures.forEach(((e,t)=>{a.setUniformi(`volumeTexture[${t}]`,e.getTextureUnit())})),a.isAttributeUsed("vertexWC")&&(n.getVAO().addAttributeArray(a,n.getCABO(),"vertexWC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||tf("Error setting vertexWC in shader VAO.")),a.isAttributeUsed("normalWC")&&(n.getVAO().addAttributeArray(a,n.getCABO(),"normalWC",n.getCABO().getNormalOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||tf("Error setting normalWC in shader VAO.")),a.isUniformUsed("slabThickness")&&a.setUniformf("slabThickness",t.renderable.getSlabThickness()),a.isUniformUsed("spacing")&&a.setUniform3fv("spacing",i.getSpacing()),a.isUniformUsed("slabType")&&a.setUniformi("slabType",t.renderable.getSlabType()),a.isUniformUsed("slabType")&&a.setUniformi("slabType",t.renderable.getSlabType()),a.isUniformUsed("slabTrapezoid")&&a.setUniformi("slabTrapezoid",t.renderable.getSlabTrapezoidIntegration());const e=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null;if(a.isUniformUsed("WCTCMatrix")){const n=i.getDimensions();d(t.tmpMat4,i.getIndexToWorld()),b(t.tmpMat4,t.tmpMat4,[-.5,-.5,-.5]),x(t.tmpMat4,t.tmpMat4,n),h(t.tmpMat4,t.tmpMat4),e&&y(t.tmpMat4,t.tmpMat4,e),a.setUniformMatrix("WCTCMatrix",t.tmpMat4)}a.isUniformUsed("vboScaling")&&a.setUniform3fv("vboScaling",n.getCABO().getCoordScale()??[1,1,1]),n.getAttributeUpdateTime().modified()}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",t.renderDepth?1:0),n.getProgram().isUniformUsed("coffset")){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf("coffset",t.offset),n.getProgram().isUniformUsed("cfactor")&&n.getProgram().setUniformf("cfactor",t.factor)}},e.setCameraShaderParameters=(e,n,o)=>{const a=t._openGLCamera.getKeyMatrices(n),i=t._openGLImageSlice.getKeyMatrices(),s=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,l=e.getProgram();l.isUniformUsed("MCPCMatrix")&&(g(t.tmpMat4),l.setUniformMatrix("MCPCMatrix",nf([a.wcpc,i.mcwc,s],r,t.tmpMat4))),l.isUniformUsed("MCVCMatrix")&&(g(t.tmpMat4),l.setUniformMatrix("MCVCMatrix",nf([a.wcvc,i.mcwc,s],r,t.tmpMat4)))},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=r.getProperty(t.currentValidInputs[0].inputIndex),i=a.getOpacity();o.setUniformf("opacity",i);const s=t.numberOfComponents,l=a.getIndependentComponents();if(l)for(let e=0;e<s;++e)o.setUniformf(`mix${e}`,a.getComponentWeight(e));for(let e=0;e<s;e++){const n=t.multiTexturePerVolumeEnabled,r=n?e:0,i=n?0:e,s=t.scalarTextures[r].getVolumeInfo(),c=s.scale[i],u=s.offset[i],d=l?e:0;let p=a.getColorWindow(),f=a.getColorLevel();const g=a.getRGBTransferFunction(d);if(g&&a.getUseLookupTableScalarRange()){const e=g.getRange();p=e[1]-e[0],f=.5*(e[1]+e[0])}const m=c/p,h=(u-f)/p+.5;o.setUniformf(`cshift${e}`,h),o.setUniformf(`cscale${e}`,m);let v=1,T=0;const y=a.getPiecewiseFunction(d);if(y){const e=y.getRange(),t=e[1]-e[0];v=c/t,T=(u-.5*(e[0]+e[1]))/t+.5}o.setUniformf(`pwfshift${e}`,T),o.setUniformf(`pwfscale${e}`,v)}const c=t.colorTexture.getTextureUnit();o.setUniformi("colorTexture1",c);const u=t.pwfTexture.getTextureUnit();o.setUniformi("pwfTexture1",u),o.setUniform4fv("backgroundColor",t.renderable.getBackgroundColor())},e.getNeedToRebuildShaders=(e,n,r)=>{const o=r.getProperty(t.currentValidInputs[0].inputIndex).getIndependentComponents(),a=t.renderable.getSlabThickness(),i=t.renderable.getSlabType(),s=t.renderable.getSlabTrapezoidIntegration();let l=!1;return(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(l=!0),!(!l&&t.lastHaveSeenDepthRequest===t.haveSeenDepthRequest&&t.lastNumberOfComponents===t.numberOfComponents&&t.lastMultiTexturePerVolumeEnabled===t.multiTexturePerVolumeEnabled&&0!==e.getProgram()?.getHandle()&&t.lastIndependentComponents===o&&t.lastSlabThickness===a&&t.lastSlabType===i&&t.lastSlabTrapezoidIntegration===s||(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastNumberOfComponents=t.numberOfComponents,t.lastMultiTexturePerVolumeEnabled=t.multiTexturePerVolumeEnabled,t.lastIndependentComponents=o,t.lastSlabThickness=a,t.lastSlabType=i,t.lastSlabTrapezoidIntegration=s,0))},e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkImageResliceMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\n// all variables that represent positions or directions have a suffix\n// indicating the coordinate system they are in. The possible values are\n// MC - Model coordinates\n// WC - World coordinates\n// VC - View coordinates\n// DC - Display coordinates\n// TC - Texture coordinates\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvoid main()\n{\n  //VTK::PositionVC::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Picking::Impl\n}\n",e.Fragment="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkImageResliceMapperFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the gpu image mapper fragment shader\n\n// VC position of this fragment\n//VTK::PositionVC::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// handle coincident offsets\n//VTK::Coincident::Dec\n\n//VTK::ZBuffer::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\nvoid main()\n{\n  // VC position of this fragment. This should not branch/return/discard.\n  //VTK::PositionVC::Impl\n\n  // Place any calls that require uniform flow (e.g. dFdx) here.\n  //VTK::UniformFlow::Impl\n\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\n  //VTK::Depth::Impl\n\n  // Early depth peeling abort:\n  //VTK::DepthPeeling::PreColor\n\n  //VTK::TCoord::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n\n  //VTK::DepthPeeling::Impl\n\n  //VTK::Picking::Impl\n\n  // handle coincident offsets\n  //VTK::Coincident::Impl\n\n  //VTK::ZBuffer::Impl\n\n  //VTK::RenderPassFragmentShader::Impl\n}\n",e.Geometry=""},e.replaceShaderValues=(n,r,o)=>{if(e.replaceShaderTCoord(n,r,o),e.replaceShaderPositionVC(n,r,o),t.haveSeenDepthRequest){let e=n.Fragment;e=wu.substitute(e,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,e=wu.substitute(e,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result,n.Fragment=e}e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderTCoord=(e,n,r)=>{let o=e.Vertex;const a=e.Geometry;let i=e.Fragment;const s=t.renderable.getSlabThickness();o=wu.substitute(o,"//VTK::TCoord::Dec",["uniform mat4 WCTCMatrix;","out vec3 fragTexCoord;"]).result,o=wu.substitute(o,"//VTK::TCoord::Impl",["fragTexCoord = (WCTCMatrix * vertexWC).xyz;"]).result;const l=t.numberOfComponents,c=r.getProperty(t.currentValidInputs[0].inputIndex).getIndependentComponents();let u=["in vec3 fragTexCoord;",`uniform highp sampler3D volumeTexture[${t.scalarTextures.length}];`,"uniform mat4 WCTCMatrix;","uniform float cshift0;","uniform float cscale0;","uniform float pwfshift0;","uniform float pwfscale0;","uniform sampler2D colorTexture1;","uniform sampler2D pwfTexture1;","uniform float opacity;","uniform vec4 backgroundColor;"];if(u.push("vec4 rawSampleTexture(vec3 pos) {"),t.multiTexturePerVolumeEnabled){u.push("vec4 rawSample;");for(let e=0;e<t.scalarTextures.length;++e)u.push(`rawSample[${e}] = texture(volumeTexture[${e}], pos)[0];`);u.push("return rawSample;","}")}else u.push("return texture(volumeTexture[0], pos);","}");if(c){for(let e=1;e<l;e++)u=u.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(l){case 1:u=u.concat(["uniform float mix0;","#define height0 0.5"]);break;case 2:u=u.concat(["uniform float mix0;","uniform float mix1;","#define height0 0.25","#define height1 0.75"]);break;case 3:u=u.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","#define height0 0.17","#define height1 0.5","#define height2 0.83"]);break;case 4:u=u.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","uniform float mix3;","#define height0 0.125","#define height1 0.375","#define height2 0.625","#define height3 0.875"]);break;default:tf("Unsupported number of independent coordinates.")}}s>0&&(u=u.concat(["uniform vec3 spacing;","uniform float slabThickness;","uniform int slabType;","uniform int slabTrapezoid;","uniform vec3 vboScaling;"]),u=u.concat(["vec4 compositeValue(vec4 currVal, vec4 valToComp, int trapezoid)","{","  vec4 retVal = vec4(1.0);","  if (slabType == 0) // min","  {","    retVal = min(currVal, valToComp);","  }","  else if (slabType == 1) // max","  {","    retVal = max(currVal, valToComp);","  }","  else if (slabType == 3) // sum","  {","    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); ","  }","  else // mean","  {","    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); ","  }","  return retVal;","}"])),i=wu.substitute(i,"//VTK::TCoord::Dec",u).result;let d=["if (any(greaterThan(fragTexCoord, vec3(1.0))) || any(lessThan(fragTexCoord, vec3(0.0))))","{","  // set the background color and exit","  gl_FragData[0] = backgroundColor;","  return;","}","vec4 tvalue = rawSampleTexture(fragTexCoord);"];if(s>0&&(d=d.concat(["// Get the first and last samples","int numSlices = 1;","float scaling = min(min(spacing.x, spacing.y), spacing.z) * 0.5;","vec3 normalxspacing = scaling * normalWCVSOutput;","float distTraveled = length(normalxspacing);","int trapezoid = 0;","while (distTraveled < slabThickness * 0.5)","{","  distTraveled += length(normalxspacing);","  float fnumSlices = float(numSlices);","  if (distTraveled > slabThickness * 0.5)","  {","    // Before stepping outside the slab, sample at the boundaries","    normalxspacing = normalWCVSOutput * slabThickness * 0.5 / fnumSlices;","    trapezoid = slabTrapezoid;","  }","  vec3 fragTCoordNeg = (WCTCMatrix * vec4(vertexWCVSOutput.xyz - fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;","  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))","  {","    vec4 newVal = rawSampleTexture(fragTCoordNeg);","    tvalue = compositeValue(tvalue, newVal, trapezoid);","    numSlices += 1;","  }","  vec3 fragTCoordPos = (WCTCMatrix * vec4(vertexWCVSOutput.xyz + fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;","  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))","  {","    vec4 newVal = rawSampleTexture(fragTCoordPos);","    tvalue = compositeValue(tvalue, newVal, trapezoid);","    numSlices += 1;","  }","}","// Finally, if slab type is *mean*, divide the sum by the numSlices","if (slabType == 2)","{","  tvalue = tvalue / float(numSlices);","}"])),c){const e=["r","g","b","a"];for(let t=0;t<l;++t)d=d.concat([`vec3 tcolor${t} = texture2D(colorTexture1, vec2(tvalue.${e[t]} * cscale${t} + cshift${t}, height${t})).rgb;`,`float compWeight${t} = mix${t} * texture2D(pwfTexture1, vec2(tvalue.${e[t]} * pwfscale${t} + pwfshift${t}, height${t})).r;`]);switch(l){case 1:d=d.concat(["gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);"]);break;case 2:d=d.concat(["float weightSum = compWeight0 + compWeight1;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);break;case 3:d=d.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);break;case 4:d=d.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);break;default:tf("Unsupported number of independent coordinates.")}}else switch(l){case 1:d=d.concat(["// Dependent components","float intensity = tvalue.r;","vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;","float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;","gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);"]);break;case 2:d=d.concat(["float intensity = tvalue.r*cscale0 + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);"]);break;case 3:d=d.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"]);break;default:d=d.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"])}i=wu.substitute(i,"//VTK::TCoord::Impl",d).result,e.Vertex=o,e.Fragment=i,e.Geometry=a},e.replaceShaderPositionVC=(n,r,o)=>{let a=n.Vertex;const i=n.Geometry;let s=n.Fragment;const l=t.renderable.getSlabThickness();let c=["attribute vec4 vertexWC;"];c=c.concat([`//${e.getMTime()}${t.resliceGeomUpdateString}`]),l>0&&(c=c.concat(["attribute vec3 normalWC;","varying vec3 normalWCVSOutput;","varying vec4 vertexWCVSOutput;"])),a=wu.substitute(a,"//VTK::PositionVC::Dec",c).result;let u=["gl_Position = MCPCMatrix * vertexWC;"];l>0&&(u=u.concat(["normalWCVSOutput = normalWC;","vertexWCVSOutput = vertexWC;"])),a=wu.substitute(a,"//VTK::PositionVC::Impl",u).result,a=wu.substitute(a,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;","uniform mat4 MCVCMatrix;"]).result;let d=[];l>0&&(d=d.concat(["varying vec3 normalWCVSOutput;","varying vec4 vertexWCVSOutput;"])),s=wu.substitute(s,"//VTK::PositionVC::Dec",d).result,n.Vertex=a,n.Geometry=i,n.Fragment=s},e.updateResliceGeometry=()=>{let e="";const n=t.currentValidInputs[0].imageData,r=n?.getBounds();let o=!0,a=2;const i=t.renderable.getSlicePolyData(),s=t.renderable.getSlicePlane();if(i)e=e.concat(`PolyData${i.getMTime()}`);else if(s){e=e.concat(`Plane${s.getMTime()}`);const t=ie();n&&(e=e.concat(`Image${n.getMTime()}`),de(t,...n.getDirection()),ge(t,t));const r=[...s.getNormal()];On(r,r,t),[o,a]=function(e){La.normalize(e);const t=[0,0,0];for(let r=0;r<3;++r){(n=t)[0]=0,n[1]=0,n[2]=0,t[r]=1;const o=La.dot(e,t);if(o<-.999999||o>.999999)return[!0,r]}var n;return[!1,2]}(r)}else{const o=ti.newInstance();o.setNormal(0,0,1);let a=[0,1,0,1,0,1];n&&(a=r),o.setOrigin(a[0],a[2],.5*(a[5]+a[4])),t.renderable.setSlicePlane(o),e=e.concat(`Plane${s?.getMTime()}`),n&&(e=e.concat(`Image${n.getMTime()}`))}if(!t.resliceGeom||t.resliceGeomUpdateString!==e){if(i)t.resliceGeom||(t.resliceGeom=kc.newInstance()),t.resliceGeom.getPoints().setData(i.getPoints().getData(),3),t.resliceGeom.getPolys().setData(i.getPolys().getData(),1),t.resliceGeom.getPointData().setNormals(i.getPointData().getNormals());else if(s)if(o){const e=new Float32Array(12),r=n.worldToIndex(s.getOrigin(),[0,0,0]),o=[(a+1)%3,(a+2)%3].sort(),i=n.getSpatialExtent();let l=0;for(let t=0;t<2;++t)for(let n=0;n<2;++n)e[l+a]=r[a],e[l+o[0]]=i[2*o[0]+n],e[l+o[1]]=i[2*o[1]+t],l+=3;t.transform.setMatrix(n.getIndexToWorld()),t.transform.transformPoints(e,e);const c=new Uint16Array(8);c[0]=3,c[1]=0,c[2]=1,c[3]=3,c[4]=3,c[5]=0,c[6]=3,c[7]=2;const u=s.getNormal();La.normalize(u);const d=new Float32Array(12);for(let e=0;e<4;++e)d[3*e]=u[0],d[3*e+1]=u[1],d[3*e+2]=u[2];t.resliceGeom||(t.resliceGeom=kc.newInstance()),t.resliceGeom.getPoints().setData(e,3),t.resliceGeom.getPolys().setData(c,1);const p=Ts.newInstance({numberOfComponents:3,values:d,name:"Normals"});t.resliceGeom.getPointData().setNormals(p)}else{t.outlineFilter.setInputData(n),t.cutter.setInputConnection(t.outlineFilter.getOutputPort()),t.cutter.setCutFunction(s),t.lineToSurfaceFilter.setInputConnection(t.cutter.getOutputPort()),t.lineToSurfaceFilter.update(),t.resliceGeom||(t.resliceGeom=kc.newInstance());const e=t.lineToSurfaceFilter.getOutputData();t.resliceGeom.getPoints().setData(e.getPoints().getData(),3),t.resliceGeom.getPolys().setData(e.getPolys().getData(),1),t.resliceGeom.getPointData().setNormals(e.getPointData().getNormals());const r=s.getNormal(),o=t.resliceGeom.getNumberOfPoints();La.normalize(r);const a=new Float32Array(3*o);for(let e=0;e<o;++e)a[3*e]=r[0],a[3*e+1]=r[1],a[3*e+2]=r[2];const i=Ts.newInstance({numberOfComponents:3,values:a,name:"Normals"});t.resliceGeom.getPointData().setNormals(i)}else tf("Something went wrong.","A default slice plane should have been created in the beginning of","updateResliceGeometry.");t.resliceGeomUpdateString=e,t.resliceGeom?.modified()}},e.setScalarTextures=e=>{t.scalarTextures=[...e],t._externalOpenGLTexture=!0},e.delete=Vt((()=>{t._openGLRenderWindow&&a(t._openGLRenderWindow)}),e.delete)}(e,t)}),"vtkOpenGLImageResliceMapper");en("vtkImageResliceMapper",of);var af={SlicingMode:{NONE:-1,I:0,J:1,K:2,X:3,Y:4,Z:5}};const{vtkErrorMacro:sf}=jt,{SlicingMode:lf}=af;function cf(e){const t=e.split("\n"),n=[];for(let e=0;e<t.length;++e){const r=t[e].trim();r.length>0&&n.push(r)}return n}const uf={VBOBuildTime:0,VBOBuildString:null,openGLTexture:null,tris:null,imagemat:null,imagematinv:null,colorTexture:null,pwfTexture:null,labelOutlineThicknessTexture:null,labelOutlineThicknessTextureString:null,lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastTextureComponents:0};const df=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,uf,n),Xt.extend(e,t,n),nd(e,t,n),rd(e,t,n),t.tris=Du.newInstance(),t.imagemat=g(new Float64Array(16)),t.imagematinv=g(new Float64Array(16)),t.projectionToWorld=g(new Float64Array(16)),t.idxToView=g(new Float64Array(16)),t.idxNormalMatrix=pe(new Float64Array(9)),t.modelToView=g(new Float64Array(16)),t.projectionToView=g(new Float64Array(16)),St(e,t,[]),t.VBOBuildTime={},vt(t.VBOBuildTime),function(e,t){function n(n){t.openGLTexture.releaseGraphicsResources(n),[t._colorTransferFunc,t._pwFunc,t._labelOutlineThicknessArray].forEach((t=>n.unregisterGraphicsResourceUser(t,e)))}t.classHierarchy.push("vtkOpenGLImageMapper"),e.buildPass=r=>{if(r){t.currentRenderPass=null,t.openGLImageSlice=e.getFirstAncestorOfType("vtkOpenGLImageSlice"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer");const r=t._openGLRenderWindow;t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),r&&!r.isDeleted()&&r!==t._openGLRenderWindow&&n(r),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow);const o=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(o.getActiveCamera()),t.renderable.isA("vtkImageMapper")&&t.renderable.getSliceAtFocalPoint()&&t.renderable.setSliceFromCamera(o.getActiveCamera())}},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()==dl.PolygonOffset?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t.openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.getShaderTemplate=(e,t,n)=>{e.Vertex=ed,e.Fragment=td,e.Geometry=""},e.replaceShaderValues=(n,r,o)=>{let a=n.Vertex,i=n.Fragment;a=wu.substitute(a,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;"]).result,a=wu.substitute(a,"//VTK::PositionVC::Impl",["  gl_Position = MCPCMatrix * vertexMC;"]).result,a=wu.substitute(a,"//VTK::TCoord::Impl","tcoordVCVSOutput = tcoordMC;").result,a=wu.substitute(a,"//VTK::TCoord::Dec","attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;").result;const s=t.openGLTexture.getComponents(),l=o.getProperty().getIndependentComponents();let c=["varying vec2 tcoordVCVSOutput;","uniform float cshift0;","uniform float cscale0;","uniform float pwfshift0;","uniform float pwfscale0;","uniform sampler2D texture1;","uniform sampler2D colorTexture1;","uniform sampler2D pwfTexture1;","uniform sampler2D labelOutlineTexture1;","uniform float opacity;","uniform float outlineOpacity;"];if(l){for(let e=1;e<s;e++)c=c.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(s){case 1:c=c.concat(["uniform float mix0;","#define height0 0.5"]);break;case 2:c=c.concat(["uniform float mix0;","uniform float mix1;","#define height0 0.25","#define height1 0.75"]);break;case 3:c=c.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","#define height0 0.17","#define height1 0.5","#define height2 0.83"]);break;case 4:c=c.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","uniform float mix3;","#define height0 0.125","#define height1 0.375","#define height2 0.625","#define height3 0.875"]);break;default:sf("Unsupported number of independent coordinates.")}}if(i=wu.substitute(i,"//VTK::TCoord::Dec",c).result,!0===o.getProperty().getUseLabelOutline()&&(i=wu.substitute(i,"//VTK::LabelOutline::Dec",["uniform int outlineThickness;","uniform float vpWidth;","uniform float vpHeight;","uniform float vpOffsetX;","uniform float vpOffsetY;","uniform mat4 PCWCMatrix;","uniform mat4 vWCtoIDX;","uniform ivec3 imageDimensions;","uniform int sliceAxis;"]).result,i=wu.substitute(i,"//VTK::ImageLabelOutlineOn","#define vtkImageLabelOutlineOn").result,i=wu.substitute(i,"//VTK::LabelOutlineHelperFunction",["#ifdef vtkImageLabelOutlineOn","vec3 fragCoordToIndexSpace(vec4 fragCoord) {","  vec4 pcPos = vec4(","    (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,","    (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,","    (fragCoord.z - 0.5) * 2.0,","    1.0);","","  vec4 worldCoord = PCWCMatrix * pcPos;","  vec4 vertex = (worldCoord/worldCoord.w);","","  vec3 index = (vWCtoIDX * vertex).xyz;","","  // half voxel fix for labelmapOutline","  return (index + vec3(0.5)) / vec3(imageDimensions);","}","vec2 getSliceCoords(vec3 coord, int axis) {","  if (axis == 0) return coord.yz;","  if (axis == 1) return coord.xz;","  if (axis == 2) return coord.xy;","}","#endif"]).result),l){const e=["r","g","b","a"];let t=["vec4 tvalue = texture2D(texture1, tcoordVCVSOutput);"];for(let n=0;n<s;n++)t=t.concat([`vec3 tcolor${n} = mix${n} * texture2D(colorTexture1, vec2(tvalue.${e[n]} * cscale${n} + cshift${n}, height${n})).rgb;`,`float compWeight${n} = mix${n} * texture2D(pwfTexture1, vec2(tvalue.${e[n]} * pwfscale${n} + pwfshift${n}, height${n})).r;`]);switch(s){case 1:t=t.concat(["gl_FragData[0] = vec4(tcolor0.rgb, opacity);"]);break;case 2:t=t.concat(["float weightSum = compWeight0 + compWeight1;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);break;case 3:t=t.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);break;case 4:t=t.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);break;default:sf("Unsupported number of independent coordinates.")}i=wu.substitute(i,"//VTK::TCoord::Impl",t).result}else switch(s){case 1:i=wu.substitute(i,"//VTK::TCoord::Impl",[...cf("\n                #ifdef vtkImageLabelOutlineOn\n                  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord);\n                  float centerValue = texture2D(texture1, getSliceCoords(centerPosIS, sliceAxis)).r;\n                  bool pixelOnBorder = false;\n                  vec3 tColor = texture2D(colorTexture1, vec2(centerValue * cscale0 + cshift0, 0.5)).rgb;\n                  float scalarOpacity = texture2D(pwfTexture1, vec2(centerValue * pwfscale0 + pwfshift0, 0.5)).r;\n                  float opacityToUse = scalarOpacity * opacity;\n                  int segmentIndex = int(centerValue * 255.0);\n                  float textureCoordinate = float(segmentIndex - 1) / 1024.0;\n                  float textureValue = texture2D(labelOutlineTexture1, vec2(textureCoordinate, 0.5)).r;\n                  int actualThickness = int(textureValue * 255.0);\n\n                  if (segmentIndex == 0){\n                    gl_FragData[0] = vec4(0.0, 0.0, 0.0, 0.0);\n                    return;\n                  }\n\n                  for (int i = -actualThickness; i <= actualThickness; i++) {\n                    for (int j = -actualThickness; j <= actualThickness; j++) {\n                      if (i == 0 || j == 0) {\n                        continue;\n                      }\n                      vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),\n                        gl_FragCoord.y + float(j),\n                        gl_FragCoord.z, gl_FragCoord.w);\n                      vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\n                      float value = texture2D(texture1, getSliceCoords(neighborPosIS, sliceAxis)).r;\n                      if (value != centerValue) {\n                        pixelOnBorder = true;\n                        break;\n                      }\n                    }\n                    if (pixelOnBorder == true) {\n                      break;\n                    }\n                  }\n                  if (pixelOnBorder == true) {\n                    gl_FragData[0] = vec4(tColor, outlineOpacity);\n                  }\n                  else {\n                    gl_FragData[0] = vec4(tColor, opacityToUse);\n                  }\n                #else\n                  float intensity = texture2D(texture1, tcoordVCVSOutput).r;\n                  vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;\n                  float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;\n                  gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);\n                #endif\n                ")]).result;break;case 2:i=wu.substitute(i,"//VTK::TCoord::Impl",["vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","float intensity = tcolor.r*cscale0 + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tcolor.g + pwfshift0);"]).result;break;case 3:i=wu.substitute(i,"//VTK::TCoord::Impl",["vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"]).result;break;default:i=wu.substitute(i,"//VTK::TCoord::Impl",["vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"]).result}t.haveSeenDepthRequest&&(i=wu.substitute(i,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,i=wu.substitute(i,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),n.Vertex=a,n.Fragment=i,e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(tt("OpenGL has a limit of 6 clipping planes"),e=6),o=wu.substitute(o,"//VTK::Clip::Dec",["uniform int numClipPlanes;","uniform vec4 clipPlanes[6];","varying float clipDistancesVSOutput[6];"]).result,o=wu.substitute(o,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);","    }"]).result,a=wu.substitute(a,"//VTK::Clip::Dec",["uniform int numClipPlanes;","varying float clipDistancesVSOutput[6];"]).result,a=wu.substitute(a,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    if (clipDistancesVSOutput[planeNum] < 0.0) discard;","    }"]).result}e.Vertex=o,e.Fragment=a},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.openGLTexture.getComponents(),a=r.getProperty().getIndependentComponents();let i=!1;return(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(i=!0),!(!i&&t.lastHaveSeenDepthRequest===t.haveSeenDepthRequest&&0!==e.getProgram()?.getHandle()&&t.lastTextureComponents===o&&t.lastIndependentComponents===a||(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,0))},e.updateShaders=(n,r,o)=>{if(t.lastBoundBO=n,e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{n.getCABO().getElementCount()&&(t.VBOBuildTime>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(n.getProgram().isAttributeUsed("vertexMC")&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"vertexMC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||sf("Error setting vertexMC in shader VAO.")),n.getProgram().isAttributeUsed("tcoordMC")&&n.getCABO().getTCoordOffset()&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"tcoordMC",n.getCABO().getTCoordOffset(),n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getTCoordComponents(),t.context.FALSE)||sf("Error setting tcoordMC in shader VAO.")),n.getAttributeUpdateTime().modified());const a=t.openGLTexture.getTextureUnit();n.getProgram().setUniformi("texture1",a);const i=t.openGLTexture.getComponents(),s=o.getProperty().getIndependentComponents();if(s)for(let e=0;e<i;e++)n.getProgram().setUniformf(`mix${e}`,o.getProperty().getComponentWeight(e));const l=t.openGLTexture.getShiftAndScale();for(let e=0;e<i;e++){let t=o.getProperty().getColorWindow(),r=o.getProperty().getColorLevel();const a=s?e:0,i=o.getProperty().getRGBTransferFunction(a);if(i&&o.getProperty().getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],r=.5*(e[1]+e[0])}const c=l.scale/t,u=(l.shift-r)/t+.5;n.getProgram().setUniformf(`cshift${e}`,u),n.getProgram().setUniformf(`cscale${e}`,c)}for(let e=0;e<i;e++){let t=1,r=0;const a=s?e:0,i=o.getProperty().getPiecewiseFunction(a);if(i){const e=i.getRange(),n=e[1]-e[0],o=.5*(e[0]+e[1]);t=l.scale/n,r=(l.shift-o)/n+.5}n.getProgram().setUniformf(`pwfshift${e}`,r),n.getProgram().setUniformf(`pwfscale${e}`,t)}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",t.renderDepth?1:0),n.getProgram().isUniformUsed("coffset")){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf("coffset",t.offset),n.getProgram().isUniformUsed("cfactor")&&n.getProgram().setUniformf("cfactor",t.factor)}const c=t.colorTexture.getTextureUnit();n.getProgram().setUniformi("colorTexture1",c);const u=t.pwfTexture.getTextureUnit();n.getProgram().setUniformi("pwfTexture1",u);const p=t.labelOutlineThicknessTexture.getTextureUnit();if(n.getProgram().setUniformi("labelOutlineTexture1",p),t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(tt("OpenGL has a limit of 6 clipping planes"),e=6);const r=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null,a=r?d(t.imagematinv,o.getMatrix()):o.getMatrix();r&&(m(a,a),y(a,a,r),m(a,a)),m(t.imagemat,t.currentInput.getIndexToWorld()),y(t.imagematinv,a,t.imagemat);const i=[];for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(t.imagematinv,n,e);for(let t=0;t<4;t++)i.push(e[t])}n.getProgram().setUniformi("numClipPlanes",e),n.getProgram().setUniform4fv("clipPlanes",i)}if(!0===o.getProperty().getUseLabelOutline()){const e=o.getProperty().getLabelOutlineOpacity();n.getProgram().setUniformf("outlineOpacity",e)}},e.setCameraShaderParameters=(n,r,o)=>{const a=n.getProgram(),i=t.openGLImageSlice.getKeyMatrices(),s=t.currentInput,l=s.getIndexToWorld();y(t.imagemat,i.mcwc,l);const c=t.openGLCamera.getKeyMatrices(r);if(y(t.imagemat,c.wcpc,t.imagemat),n.getCABO().getCoordShiftAndScaleEnabled()){const e=n.getCABO().getInverseShiftAndScaleMatrix();y(t.imagemat,t.imagemat,e)}if(a.setUniformMatrix("MCPCMatrix",t.imagemat),!0===o.getProperty().getUseLabelOutline()){const n=s.getWorldToIndex(),o=s.getDimensions();let i=t.renderable.getClosestIJKAxis().ijkMode;i===lf.NONE&&(i=lf.K),a.setUniform3i("imageDimensions",o[0],o[1],o[2]),a.setUniformi("sliceAxis",i),a.setUniformMatrix("vWCtoIDX",n);const l=t.openGLCamera.getKeyMatrices(r);h(t.projectionToWorld,l.wcpc),t.openGLCamera.getKeyMatrices(r),a.setUniformMatrix("PCWCMatrix",t.projectionToWorld);const c=e.getRenderTargetSize();a.setUniformf("vpWidth",c[0]),a.setUniformf("vpHeight",c[1]);const u=e.getRenderTargetOffset();a.setUniformf("vpOffsetX",u[0]/c[0]),a.setUniformf("vpOffsetY",u[1]/c[1])}},e.setPropertyShaderParameters=(e,t,n)=>{const r=e.getProgram(),o=n.getProperty().getOpacity();r.setUniformf("opacity",o)},e.renderPieceStart=(n,r)=>{e.updateBufferObjects(n,r),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=t.context;t.openGLTexture.activate(),t.colorTexture.activate(),t.labelOutlineThicknessTexture.activate(),t.pwfTexture.activate(),t.tris.getCABO().getElementCount()&&(e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release()),t.openGLTexture.deactivate(),t.colorTexture.deactivate(),t.labelOutlineThicknessTexture.deactivate(),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.renderPiece=(n,r)=>{e.invokeEvent({type:"StartEvent"}),t.renderable.update(),t.currentInput=t.renderable.getCurrentImage(),e.invokeEvent({type:"EndEvent"}),t.currentInput?(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)):sf("No input!")},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty().getMTime()||t.VBOBuildTime.getMTime()<t.currentInput.getMTime()||!t.openGLTexture?.getHandle()||!t.colorTexture?.getHandle()||!t.labelOutlineThicknessTexture?.getHandle()||!t.pwfTexture?.getHandle(),e.buildBufferObjects=(n,r)=>{const o=t.currentInput;if(!o)return;const a=o.getPointData()&&o.getPointData().getScalars();if(!a)return;const i=a.getDataType(),s=a.getNumberOfComponents(),l=r.getProperty(),c=l.getInterpolationType(),u=l.getIndependentComponents(),d=u?s:1,p=u?2*d:1,f=[];for(let e=0;e<d;++e)f.push(l.getRGBTransferFunction(e));const g=Zp(f,u,d),m=l.getRGBTransferFunction(),h=t._openGLRenderWindow.getGraphicsResourceForObject(m);if(h?.oglObject?.getHandle()&&h?.hash===g)t.colorTexture=h.oglObject;else{t.colorTexture=Ju.newInstance({resizable:!0}),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow);let n=t.renderable.getColorTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const r=new Uint8ClampedArray(n*p*3);if(c===Jp.NEAREST?(t.colorTexture.setMinificationFilter(Bu.NEAREST),t.colorTexture.setMagnificationFilter(Bu.NEAREST)):(t.colorTexture.setMinificationFilter(Bu.LINEAR),t.colorTexture.setMagnificationFilter(Bu.LINEAR)),m){const e=new Float32Array(3*n);for(let t=0;t<d;t++){const o=l.getRGBTransferFunction(t),a=o.getRange();if(o.getTable(a[0],a[1],n,e,1),u)for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o],r[t*n*6+o+3*n]=255*e[o];else for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o]}t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw({width:n,height:p,numComps:3,dataType:is.UNSIGNED_CHAR,data:r})}else{for(let e=0;e<3*n;++e)r[e]=255*e/(3*(n-1)),r[e+1]=255*e/(3*(n-1)),r[e+2]=255*e/(3*(n-1));t.colorTexture.create2DFromRaw({width:n,height:1,numComps:3,dataType:is.UNSIGNED_CHAR,data:r})}m&&(t._openGLRenderWindow.setGraphicsResourceForObject(m,t.colorTexture,g),m!==t._colorTransferFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(m,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._colorTransferFunc,e)),t._colorTransferFunc=m)}const v=[];for(let e=0;e<d;++e)v.push(l.getPiecewiseFunction(e));const T=Zp(v,u,d),y=l.getPiecewiseFunction(),b=t._openGLRenderWindow.getGraphicsResourceForObject(y);if(b?.oglObject?.getHandle()&&b?.hash===T)t.pwfTexture=b.oglObject;else{let n=t.renderable.getOpacityTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const r=n*p,o=new Uint8ClampedArray(r);if(t.pwfTexture=Ju.newInstance({resizable:!0}),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow),c===Jp.NEAREST?(t.pwfTexture.setMinificationFilter(Bu.NEAREST),t.pwfTexture.setMagnificationFilter(Bu.NEAREST)):(t.pwfTexture.setMinificationFilter(Bu.LINEAR),t.pwfTexture.setMagnificationFilter(Bu.LINEAR)),y){const e=new Float32Array(r),o=new Float32Array(n);for(let t=0;t<d;++t){const r=l.getPiecewiseFunction(t);if(null===r)e.fill(1);else{const a=r.getRange();if(r.getTable(a[0],a[1],n,o,1),u)for(let r=0;r<n;r++)e[t*n*2+r]=o[r],e[t*n*2+r+n]=o[r];else for(let r=0;r<n;r++)e[t*n*2+r]=o[r]}}t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw({width:n,height:p,numComps:1,dataType:is.FLOAT,data:e})}else o.fill(255),t.pwfTexture.create2DFromRaw({width:n,height:1,numComps:1,dataType:is.UNSIGNED_CHAR,data:o});y&&(t._openGLRenderWindow.setGraphicsResourceForObject(y,t.pwfTexture,T),y!==t._pwFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(y,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._pwFunc,e)),t._pwFunc=y)}e.updatelabelOutlineThicknessTexture(r);const{ijkMode:x}=t.renderable.getClosestIJKAxis();let C=t.renderable.getSlice();x!==t.renderable.getSlicingMode()&&(C=t.renderable.getSliceAtPosition(C));const S=t.renderable.isA("vtkImageArrayMapper")?t.renderable.getSubSlice():Math.round(C),A=o.getExtent();let I;x===lf.I&&(I=S-A[0]),x===lf.J&&(I=S-A[2]),x!==lf.K&&x!==lf.NONE||(I=S-A[4]);const w=`${C}A${o.getMTime()}A${a.getMTime()}B${e.getMTime()}C${t.renderable.getSlicingMode()}D${r.getProperty().getInterpolationType()}`;if(t.VBOBuildString!==w){const e=o.getDimensions();t.openGLTexture||(t.openGLTexture=Ju.newInstance({resizable:!0})),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLTexture.setOglNorm16Ext(t.context.getExtension("EXT_texture_norm16")),c===Jp.NEAREST?(new Set([1,3,4]).has(s)&&i===is.UNSIGNED_CHAR&&!u?(t.openGLTexture.setGenerateMipmap(!0),t.openGLTexture.setMinificationFilter(Bu.NEAREST)):t.openGLTexture.setMinificationFilter(Bu.NEAREST),t.openGLTexture.setMagnificationFilter(Bu.NEAREST)):(4!==s||i!==is.UNSIGNED_CHAR||u?t.openGLTexture.setMinificationFilter(Bu.LINEAR):(t.openGLTexture.setGenerateMipmap(!0),t.openGLTexture.setMinificationFilter(Bu.LINEAR_MIPMAP_LINEAR)),t.openGLTexture.setMagnificationFilter(Bu.LINEAR)),t.openGLTexture.setWrapS(Lu.CLAMP_TO_EDGE),t.openGLTexture.setWrapT(Lu.CLAMP_TO_EDGE);const n=e[0]*e[1]*s,r=new Float32Array(12),l=new Float32Array(8);for(let e=0;e<4;e++)l[2*e]=e%2?1:0,l[2*e+1]=e>1?1:0;const d=[lf.X,lf.Y,lf.Z].includes(t.renderable.getSlicingMode())?C:S,p=o.getSpatialExtent(),f=a.getData();let g=null;if(x===lf.I){g=new f.constructor(e[2]*e[1]*s);let t=0;for(let n=0;n<e[2];n++)for(let r=0;r<e[1];r++){let o=(I+r*e[0]+n*e[0]*e[1])*s;t=(n*e[1]+r)*s;const a=o+s;for(;o<a;)g[t++]=f[o++]}e[0]=e[1],e[1]=e[2],r[0]=d,r[1]=p[2],r[2]=p[4],r[3]=d,r[4]=p[3],r[5]=p[4],r[6]=d,r[7]=p[2],r[8]=p[5],r[9]=d,r[10]=p[3],r[11]=p[5]}else if(x===lf.J){g=new f.constructor(e[2]*e[0]*s);let t=0;for(let n=0;n<e[2];n++)for(let r=0;r<e[0];r++){let o=(r+I*e[0]+n*e[0]*e[1])*s;t=(n*e[0]+r)*s;const a=o+s;for(;o<a;)g[t++]=f[o++]}e[1]=e[2],r[0]=p[0],r[1]=d,r[2]=p[4],r[3]=p[1],r[4]=d,r[5]=p[4],r[6]=p[0],r[7]=d,r[8]=p[5],r[9]=p[1],r[10]=d,r[11]=p[5]}else x===lf.K||x===lf.NONE?(g=f.subarray(I*n,(I+1)*n),r[0]=p[0],r[1]=p[2],r[2]=d,r[3]=p[1],r[4]=p[2],r[5]=d,r[6]=p[0],r[7]=p[3],r[8]=d,r[9]=p[1],r[10]=p[3],r[11]=d):sf("Reformat slicing not yet supported.");const m=a.getRanges();t.openGLTexture.resetFormatAndType(),t.openGLTexture.create2DFilterableFromRaw({width:e[0],height:e[1],numComps:s,dataType:a.getDataType(),data:g,preferSizeOverAccuracy:!!t.renderable.getPreferSizeOverAccuracy?.(),ranges:m}),t.openGLTexture.activate(),t.openGLTexture.sendParameters(),t.openGLTexture.deactivate();const h=Ts.newInstance({numberOfComponents:3,values:r});h.setName("points");const v=Ts.newInstance({numberOfComponents:2,values:l});v.setName("tcoords");const T=new Uint16Array(8);T[0]=3,T[1]=0,T[2]=1,T[3]=3,T[4]=3,T[5]=0,T[6]=3,T[7]=2;const y=Ts.newInstance({numberOfComponents:1,values:T});t.tris.getCABO().createVBO(y,"polys",qi.SURFACE,{points:h,tcoords:v,cellOffset:0}),t.VBOBuildTime.modified(),t.VBOBuildString=w}},e.updatelabelOutlineThicknessTexture=n=>{const r=n.getProperty().getLabelOutlineThicknessByReference(),o=t._openGLRenderWindow.getGraphicsResourceForObject(r),a=`${r.join("-")}`;if(o?.oglObject?.getHandle()&&o?.hash===a)t.labelOutlineThicknessTexture=o.oglObject;else{let n=t.renderable.getLabelOutlineTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const o=1,i=new Uint8Array(n*o);for(let e=0;e<n;++e){const t=void 0!==r[e]?r[e]:r[0];i[e]=t}t.labelOutlineThicknessTexture=Ju.newInstance({resizable:!1}),t.labelOutlineThicknessTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.labelOutlineThicknessTexture.resetFormatAndType(),t.labelOutlineThicknessTexture.setMinificationFilter(Bu.NEAREST),t.labelOutlineThicknessTexture.setMagnificationFilter(Bu.NEAREST),t.labelOutlineThicknessTexture.create2DFromRaw({width:n,height:o,numComps:1,dataType:is.UNSIGNED_CHAR,data:i}),r&&(t._openGLRenderWindow.setGraphicsResourceForObject(r,t.labelOutlineThicknessTexture,a),r!==t._labelOutlineThicknessArray&&(t._openGLRenderWindow.registerGraphicsResourceUser(r,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._labelOutlineThicknessArray,e)),t._labelOutlineThicknessArray=r)}},e.getRenderTargetSize=()=>{if(t._useSmallViewport)return[t._smallViewportWidth,t._smallViewportHeight];const{usize:e,vsize:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getRenderTargetOffset=()=>{const{lowerLeftU:e,lowerLeftV:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.delete=Vt((()=>{t._openGLRenderWindow&&n(t._openGLRenderWindow)}),e.delete)}(e,t)}),"vtkOpenGLImageMapper");en("vtkAbstractImageMapper",df);const pf=0,ff=1,gf=2,{vtkErrorMacro:mf}=Ht,hf={currentRenderPass:null,volumeTexture:null,colorTexture:null,pwfTexture:null,tris:null,lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastTextureComponents:0,lastIndependentComponents:0,imagemat:null,imagematinv:null};const vf=Ht.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,hf,n),Xt.extend(e,t,n),nd(e,t,n),Ht.algo(e,t,2,0),t.tris=Du.newInstance(),t.volumeTexture=null,t.colorTexture=null,t.pwfTexture=null,t.imagemat=g(new Float64Array(16)),t.imagematinv=g(new Float64Array(16)),t.VBOBuildTime={},Ht.obj(t.VBOBuildTime,{mtime:0}),function(e,t){function n(n){[t._scalars,t._colorTransferFunc,t._pwFunc].forEach((t=>n.unregisterGraphicsResourceUser(t,e)))}t.classHierarchy.push("vtkOpenGLImageCPRMapper"),e.buildPass=r=>{if(r){t.currentRenderPass=null,t.openGLImageSlice=e.getFirstAncestorOfType("vtkOpenGLImageSlice"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer");const r=t._openGLRenderWindow;t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),r&&!r.isDeleted()&&r!==t._openGLRenderWindow&&n(r),t.context=t._openGLRenderWindow.getContext(),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow)}},e.opaquePass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.opaqueZBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()===dl.PolygonOffset?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t.openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.renderPiece=(n,r)=>{e.invokeEvent({type:"StartEvent"}),t.renderable.update(),e.invokeEvent({type:"EndEvent"}),t.renderable.preRenderCheck()&&(t.currentImageDataInput=t.renderable.getInputData(0),t.currentCenterlineInput=t.renderable.getOrientedCenterline(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r))},e.renderPieceStart=(t,n)=>{e.updateBufferObjects(t,n)},e.renderPieceDraw=(n,r)=>{const o=t.context;t.volumeTexture.activate(),t.colorTexture.activate(),t.pwfTexture.activate(),t.tris.getCABO().getElementCount()&&(e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release()),t.volumeTexture.deactivate(),t.colorTexture.deactivate(),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.updateBufferObjects=(n,r)=>{e.getNeedToRebuildBufferObjects(n,r)&&e.buildBufferObjects(n,r),r.getProperty().getInterpolationType()===Jp.NEAREST?(t.volumeTexture.setMinificationFilter(Bu.NEAREST),t.volumeTexture.setMagnificationFilter(Bu.NEAREST),t.colorTexture.setMinificationFilter(Bu.NEAREST),t.colorTexture.setMagnificationFilter(Bu.NEAREST),t.pwfTexture.setMinificationFilter(Bu.NEAREST),t.pwfTexture.setMagnificationFilter(Bu.NEAREST)):(t.volumeTexture.setMinificationFilter(Bu.LINEAR),t.volumeTexture.setMagnificationFilter(Bu.LINEAR),t.colorTexture.setMinificationFilter(Bu.LINEAR),t.colorTexture.setMagnificationFilter(Bu.LINEAR),t.pwfTexture.setMinificationFilter(Bu.LINEAR),t.pwfTexture.setMagnificationFilter(Bu.LINEAR))},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return o<e.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentImageDataInput.getMTime()||o<t.currentCenterlineInput.getMTime()||!t.volumeTexture?.getHandle()},e.buildBufferObjects=(n,r)=>{const o=t.currentImageDataInput,a=t.currentCenterlineInput,i=r.getProperty(),s=o?.getPointData()?.getScalars();if(!s)return;const l=t._openGLRenderWindow.getGraphicsResourceForObject(s),c=Qp(0,s),u=!l?.oglObject?.getHandle()||l?.hash!==c,d=i.getUpdatedExtents(),p=!!d.length;if(u){t.volumeTexture=Ju.newInstance(),t.volumeTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=o.getDimensions();t.volumeTexture.setOglNorm16Ext(t.context.getExtension("EXT_texture_norm16")),t.volumeTexture.resetFormatAndType(),t.volumeTexture.create3DFilterableFromDataArray({width:n[0],height:n[1],depth:n[2],dataArray:s,preferSizeOverAccuracy:t.renderable.getPreferSizeOverAccuracy()}),t._openGLRenderWindow.setGraphicsResourceForObject(s,t.volumeTexture,c),s!==t._scalars&&(t._openGLRenderWindow.registerGraphicsResourceUser(s,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._scalars,e)),t._scalars=s}else t.volumeTexture=l.oglObject;if(p){i.setUpdatedExtents([]);const e=o.getDimensions();t.volumeTexture.create3DFilterableFromDataArray({width:e[0],height:e[1],depth:e[2],dataArray:s,updatedExtents:d})}const f=s.getNumberOfComponents(),g=r.getProperty(),m=g.getIndependentComponents(),h=m?f:1,v=m?2*h:1,T=[];for(let e=0;e<h;++e)T.push(g.getRGBTransferFunction(e));const y=Zp(T,m,h),b=g.getRGBTransferFunction(),x=t._openGLRenderWindow.getGraphicsResourceForObject(b);if(x?.oglObject?.getHandle()&&x?.hash===y)t.colorTexture=x.oglObject;else{let n=t.renderable.getColorTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const r=new Uint8ClampedArray(n*v*3);if(t.colorTexture=Ju.newInstance(),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow),b){const e=new Float32Array(3*n);for(let t=0;t<h;t++){const o=g.getRGBTransferFunction(t),a=o.getRange();if(o.getTable(a[0],a[1],n,e,1),m)for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o],r[t*n*6+o+3*n]=255*e[o];else for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o]}t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw({width:n,height:v,numComps:3,dataType:is.UNSIGNED_CHAR,data:r})}else{for(let e=0;e<3*n;++e)r[e]=255*e/(3*(n-1)),r[e+1]=255*e/(3*(n-1)),r[e+2]=255*e/(3*(n-1));t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw({width:n,height:1,numComps:3,dataType:is.UNSIGNED_CHAR,data:r})}b&&(t._openGLRenderWindow.setGraphicsResourceForObject(b,t.colorTexture,y),b!==t._colorTransferFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(b,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._colorTransferFunc,e)),t._colorTransferFunc=b)}const C=[];for(let e=0;e<h;++e)C.push(g.getPiecewiseFunction(e));const S=Zp(C,m,h),A=g.getPiecewiseFunction(),I=t._openGLRenderWindow.getGraphicsResourceForObject(A);if(I?.oglObject?.getHandle()&&I?.hash===S)t.pwfTexture=I.oglObject;else{let n=t.renderable.getOpacityTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const r=n*v,o=new Uint8ClampedArray(r);if(t.pwfTexture=Ju.newInstance(),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow),A){const e=new Float32Array(r),o=new Float32Array(n);for(let t=0;t<h;++t){const r=g.getPiecewiseFunction(t);if(null===r)e.fill(1);else{const a=r.getRange();if(r.getTable(a[0],a[1],n,o,1),m)for(let r=0;r<n;r++)e[t*n*2+r]=o[r],e[t*n*2+r+n]=o[r];else for(let r=0;r<n;r++)e[t*n*2+r]=o[r]}}t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw({width:n,height:v,numComps:1,dataType:is.FLOAT,data:e})}else o.fill(255),t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw({width:n,height:1,numComps:1,dataType:is.UNSIGNED_CHAR,data:o});A&&(t._openGLRenderWindow.setGraphicsResourceForObject(A,t.pwfTexture,S),A!==t._pwFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(A,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._pwFunc,e)),t._pwFunc=A)}if(t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<a.getMTime()){const e=a.getNumberOfPoints(),n=e<=1?0:e-1,r=a.getDistancesToFirstPoint(),o=t.renderable.getHeight(),i=4*n,s=new Float32Array(3*i),l=t.renderable.getWidth();for(let e=0,t=0;e<n;++e)s.set([0,o-r[e],0],t),t+=3,s.set([l,o-r[e],0],t),t+=3,s.set([l,o-r[e+1],0],t),t+=3,s.set([0,o-r[e+1],0],t),t+=3;const c=Ts.newInstance({numberOfComponents:3,values:s});c.setName("points");const u=new Uint16Array(5*n);for(let e=0,t=0,r=0;e<n;++e)u.set([4,r+3,r+2,r+1,r],t),t+=5,r+=4;const d=Ts.newInstance({numberOfComponents:1,values:u}),p=a.getPoints(),f=new Float32Array(3*i),g=new Array(3),m=new Array(3);for(let e=0,t=0;e<n;++e)p.getPoint(e,g),p.getPoint(e+1,m),f.set(g,t),t+=3,f.set(g,t),t+=3,f.set(m,t),t+=3,f.set(m,t),t+=3;const h=Ts.newInstance({numberOfComponents:3,values:f,name:"centerlinePosition"}),v=new Float32Array(i);for(let e=0,t=0;e<n;++e)v.set([0,1,3,2],t),t+=4;const T=[h,Ts.newInstance({numberOfComponents:1,values:v,name:"quadIndex"})];if(!t.renderable.getUseUniformOrientation()){const e=t.renderable.getOrientedCenterline().getOrientations()??[],r=new Float32Array(4*i),o=new Float32Array(4*i);for(let t=0;t<n;++t){const n=e[t],a=e[t+1];for(let e=0;e<4;++e){const i=4*(e+4*t);r.set(n,i),o.set(a,i)}}const a=Ts.newInstance({numberOfComponents:4,values:r,name:"centerlineTopOrientation"}),s=Ts.newInstance({numberOfComponents:4,values:o,name:"centerlineBotOrientation"});T.push(a,s)}t.tris.getCABO().createVBO(d,"polys",qi.SURFACE,{points:c,customAttributes:T}),t.VBOBuildTime.modified()}},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.volumeTexture.getComponents(),a=r.getProperty().getIndependentComponents(),i=!!t.renderable.getCenterPoint(),s=t.renderable.getUseUniformOrientation(),l=t.renderable.isProjectionEnabled()&&t.renderable.getProjectionMode();return(0===e.getProgram()||t.lastUseCenterPoint!==i||t.lastUseUniformOrientation!==s||t.lastProjectionMode!==l||t.lastHaveSeenDepthRequest!==t.haveSeenDepthRequest||t.lastTextureComponents!==o||t.lastIndependentComponents!==a)&&(t.lastUseCenterPoint=i,t.lastUseUniformOrientation=s,t.lastProjectionMode=l,t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,!0)},e.buildShaders=(t,n,r)=>{e.getShaderTemplate(t,n,r),e.replaceShaderValues(t,n,r)},e.replaceShaderValues=(n,r,o)=>{let a=n.Vertex,i=n.Fragment;const s=["vec3 applyQuaternionToVec(vec4 q, vec3 v) {","  float uvx = q.y * v.z - q.z * v.y;","  float uvy = q.z * v.x - q.x * v.z;","  float uvz = q.x * v.y - q.y * v.x;","  float uuvx = q.y * uvz - q.z * uvy;","  float uuvy = q.z * uvx - q.x * uvz;","  float uuvz = q.x * uvy - q.y * uvx;","  float w2 = q.w * 2.0;","  uvx *= w2;","  uvy *= w2;","  uvz *= w2;","  uuvx *= 2.0;","  uuvy *= 2.0;","  uuvz *= 2.0;","  return vec3(v.x + uvx + uuvx, v.y + uvy + uuvy, v.z + uvz + uuvz);","}"];a=wu.substitute(a,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;"]).result,a=wu.substitute(a,"//VTK::PositionVC::Impl",["  gl_Position = MCPCMatrix * vertexMC;"]).result;const l=["attribute vec3 centerlinePosition;","attribute float quadIndex;","uniform float width;","out vec2 quadOffsetVSOutput;","out vec3 centerlinePosVSOutput;"],c=t.renderable.isProjectionEnabled(),u=t.renderable.getUseUniformOrientation();u?(l.push("out vec3 samplingDirVSOutput;","uniform vec4 centerlineOrientation;","uniform vec3 tangentDirection;",...s),c&&l.push("out vec3 projectionDirVSOutput;","uniform vec3 bitangentDirection;")):l.push("out vec4 centerlineTopOrientationVSOutput;","out vec4 centerlineBotOrientationVSOutput;","attribute vec4 centerlineTopOrientation;","attribute vec4 centerlineBotOrientation;"),a=wu.substitute(a,"//VTK::Color::Dec",l).result;const d=["quadOffsetVSOutput = vec2(width * (mod(quadIndex, 2.0) == 0.0 ? -0.5 : 0.5), quadIndex > 1.0 ? 0.0 : 1.0);","centerlinePosVSOutput = centerlinePosition;"];u?(d.push("samplingDirVSOutput = applyQuaternionToVec(centerlineOrientation, tangentDirection);"),c&&d.push("projectionDirVSOutput = applyQuaternionToVec(centerlineOrientation, bitangentDirection);")):d.push("centerlineTopOrientationVSOutput = centerlineTopOrientation;","centerlineBotOrientationVSOutput = centerlineBotOrientation;"),a=wu.substitute(a,"//VTK::Color::Impl",d).result;const p=t.volumeTexture.getComponents(),f=o.getProperty().getIndependentComponents();let g=["uniform mat4 MCTCMatrix; // Model coordinates to texture coordinates","in vec2 quadOffsetVSOutput;","in vec3 centerlinePosVSOutput;","uniform highp sampler3D volumeTexture;","uniform sampler2D colorTexture1;","uniform sampler2D pwfTexture1;","uniform float opacity;","uniform vec4 backgroundColor;","uniform float cshift0;","uniform float cscale0;","uniform float pwfshift0;","uniform float pwfscale0;"];c&&g.push("uniform vec3 volumeSizeMC;","uniform int projectionSlabNumberOfSamples;","uniform float projectionConstantOffset;","uniform float projectionStepLength;"),u?(g.push("in vec3 samplingDirVSOutput;"),c&&g.push("in vec3 projectionDirVSOutput;")):(g.push("uniform vec3 tangentDirection;","in vec4 centerlineTopOrientationVSOutput;","in vec4 centerlineBotOrientationVSOutput;",...s),c&&g.push("uniform vec3 bitangentDirection;"));const m=t.renderable.getCenterPoint();if(m&&g.push("uniform vec3 globalCenterPoint;"),f){for(let e=1;e<p;e++)g=g.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(p){case 1:g=g.concat(["uniform float mix0;","#define height0 0.5"]);break;case 2:g=g.concat(["uniform float mix0;","uniform float mix1;","#define height0 0.25","#define height1 0.75"]);break;case 3:g=g.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","#define height0 0.17","#define height1 0.5","#define height2 0.83"]);break;case 4:g=g.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","uniform float mix3;","#define height0 0.125","#define height1 0.375","#define height2 0.625","#define height3 0.875"]);break;default:mf("Unsupported number of independent coordinates.")}}i=wu.substitute(i,"//VTK::TCoord::Dec",g).result;let h=[];if(u?(h.push("vec3 samplingDirection = samplingDirVSOutput;"),c&&h.push("vec3 projectionDirection = projectionDirVSOutput;")):(h.push("vec4 q0 = centerlineBotOrientationVSOutput;","vec4 q1 = centerlineTopOrientationVSOutput;","float qCosAngle = dot(q0, q1);","vec4 interpolatedOrientation;","if (qCosAngle > 0.999 || qCosAngle < -0.999) {","  // Use LERP instead of SLERP when the two quaternions are close or opposite","  interpolatedOrientation = normalize(mix(q0, q1, quadOffsetVSOutput.y));","} else {","  float omega = acos(qCosAngle);","  interpolatedOrientation = normalize(sin((1.0 - quadOffsetVSOutput.y) * omega) * q0 + sin(quadOffsetVSOutput.y * omega) * q1);","}","vec3 samplingDirection = applyQuaternionToVec(interpolatedOrientation, tangentDirection);"),c&&h.push("vec3 projectionDirection = applyQuaternionToVec(interpolatedOrientation, bitangentDirection);")),m?h.push("float baseOffset = dot(samplingDirection, globalCenterPoint - centerlinePosVSOutput);","float horizontalOffset = quadOffsetVSOutput.x + baseOffset;"):h.push("float horizontalOffset = quadOffsetVSOutput.x;"),h.push("vec3 volumePosMC = centerlinePosVSOutput + horizontalOffset * samplingDirection;","vec3 volumePosTC = (MCTCMatrix * vec4(volumePosMC, 1.0)).xyz;","if (any(lessThan(volumePosTC, vec3(0.0))) || any(greaterThan(volumePosTC, vec3(1.0))))","{","  // set the background color and exit","  gl_FragData[0] = backgroundColor;","  return;","}"),c){const e=t.renderable.getProjectionMode();switch(e===ff?h.push("const vec4 initialProjectionTextureValue = vec4(1.0);"):h.push("const vec4 initialProjectionTextureValue = vec4(0.0);"),h.push("vec3 projectionScaledDirection = projectionDirection / volumeSizeMC;","vec3 projectionStep = projectionStepLength * projectionScaledDirection;","vec3 projectionStartPosition = volumePosTC + projectionConstantOffset * projectionScaledDirection;","vec4 tvalue = initialProjectionTextureValue;","for (int projectionSampleIdx = 0; projectionSampleIdx < projectionSlabNumberOfSamples; ++projectionSampleIdx) {","  vec3 projectionSamplePosition = projectionStartPosition + float(projectionSampleIdx) * projectionStep;","  vec4 sampledTextureValue = texture(volumeTexture, projectionSamplePosition);"),e){case pf:h.push("  tvalue = max(tvalue, sampledTextureValue);");break;case ff:h.push("  tvalue = min(tvalue, sampledTextureValue);");break;default:h.push("  tvalue = tvalue + sampledTextureValue;")}h.push("}"),e===gf&&h.push("tvalue = tvalue / float(projectionSlabNumberOfSamples);")}else h.push("vec4 tvalue = texture(volumeTexture, volumePosTC);");if(f){const e=["r","g","b","a"];for(let t=0;t<p;++t)h=h.concat([`vec3 tcolor${t} = mix${t} * texture2D(colorTexture1, vec2(tvalue.${e[t]} * cscale${t} + cshift${t}, height${t})).rgb;`,`float compWeight${t} = mix${t} * texture2D(pwfTexture1, vec2(tvalue.${e[t]} * pwfscale${t} + pwfshift${t}, height${t})).r;`]);switch(p){case 1:h=h.concat(["gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);"]);break;case 2:h=h.concat(["float weightSum = compWeight0 + compWeight1;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);break;case 3:h=h.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);break;case 4:h=h.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);break;default:mf("Unsupported number of independent coordinates.")}}else switch(p){case 1:h=h.concat(["// Dependent components","float intensity = tvalue.r;","vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;","float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;","gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);"]);break;case 2:h=h.concat(["float intensity = tvalue.r*cscale0 + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);"]);break;case 3:h=h.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"]);break;default:h=h.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"])}i=wu.substitute(i,"//VTK::TCoord::Impl",h).result,t.haveSeenDepthRequest&&(i=wu.substitute(i,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,i=wu.substitute(i,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),n.Vertex=a,n.Fragment=i,e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(Ht.vtkErrorMacro("OpenGL has a limit of 6 clipping planes"),e=6),o=wu.substitute(o,"//VTK::Clip::Dec",["uniform int numClipPlanes;","uniform vec4 clipPlanes[6];","varying float clipDistancesVSOutput[6];"]).result,o=wu.substitute(o,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);","    }"]).result,a=wu.substitute(a,"//VTK::Clip::Dec",["uniform int numClipPlanes;","varying float clipDistancesVSOutput[6];"]).result,a=wu.substitute(a,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    if (clipDistancesVSOutput[planeNum] < 0.0) discard;","    }"]).result}e.Vertex=o,e.Fragment=a},e.getShaderTemplate=(e,t,n)=>{e.Vertex=ed,e.Fragment=td,e.Geometry=""},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram(),i=n.getCABO();i.getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(a.isAttributeUsed("vertexMC")&&(n.getVAO().addAttributeArray(a,i,"vertexMC",i.getVertexOffset(),i.getStride(),t.context.FLOAT,3,t.context.FALSE)||mf("Error setting vertexMC in shader VAO.")),n.getCABO().getCustomData().forEach((e=>{e&&a.isAttributeUsed(e.name)&&!n.getVAO().addAttributeArray(a,i,e.name,e.offset,i.getStride(),t.context.FLOAT,e.components,t.context.FALSE)&&mf(`Error setting ${e.name} in shader VAO.`)})),n.getAttributeUpdateTime().modified());const s=t.volumeTexture.getTextureUnit();if(a.setUniformi("volumeTexture",s),a.setUniformf("width",t.renderable.getWidth()),n.getProgram().setUniform4fv("backgroundColor",t.renderable.getBackgroundColor()),a.isUniformUsed("tangentDirection")){const e=t.renderable.getTangentDirection();n.getProgram().setUniform3fArray("tangentDirection",e)}if(a.isUniformUsed("bitangentDirection")){const e=t.renderable.getBitangentDirection();n.getProgram().setUniform3fArray("bitangentDirection",e)}if(a.isUniformUsed("centerlineOrientation")){const e=t.renderable.getUniformOrientation();n.getProgram().setUniform4fv("centerlineOrientation",e)}if(a.isUniformUsed("globalCenterPoint")){const e=t.renderable.getCenterPoint();a.setUniform3fArray("globalCenterPoint",e)}if(t.renderable.isProjectionEnabled()){const e=t.currentImageDataInput,n=e.getSpacing(),r=e.getDimensions(),o=t.renderable.getProjectionSlabThickness(),i=t.renderable.getProjectionSlabNumberOfSamples(),s=En([],n,r);a.setUniform3fArray("volumeSizeMC",s),a.setUniformi("projectionSlabNumberOfSamples",i);const l=-.5*o;a.setUniformf("projectionConstantOffset",l);const c=o/(i-1);a.setUniformf("projectionStepLength",c)}const l=t.currentImageDataInput,c=l.getWorldToIndex(),u=O(new Float32Array(16),Cn([],l.getDimensions())),p=oe(u,u,c);if(a.setUniformMatrix("MCTCMatrix",p),t.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",t.renderDepth?1:0),t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(Ht.vtkErrorMacro("OpenGL has a limit of 6 clipping planes"),e=6);const n=i.getCoordShiftAndScaleEnabled()?i.getInverseShiftAndScaleMatrix():null,r=n?d(t.imagematinv,o.getMatrix()):o.getMatrix();n&&(m(r,r),y(r,r,n),m(r,r)),m(t.imagemat,t.currentImageDataInput.getIndexToWorld()),y(t.imagematinv,r,t.imagemat);const s=[];for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(t.imagematinv,n,e);for(let t=0;t<4;t++)s.push(e[t])}a.setUniformi("numClipPlanes",e),a.setUniform4fv("clipPlanes",s)}if(a.isUniformUsed("coffset")){const t=e.getCoincidentParameters(r,o);a.setUniformf("coffset",t.offset),a.isUniformUsed("cfactor")&&a.setUniformf("cfactor",t.factor)}},e.setCameraShaderParameters=(e,n,r)=>{const o=t.openGLImageSlice.getKeyMatrices().mcwc,a=t.openGLCamera.getKeyMatrices(n).wcpc;if(y(t.imagemat,a,o),e.getCABO().getCoordShiftAndScaleEnabled()){const n=e.getCABO().getInverseShiftAndScaleMatrix();y(t.imagemat,t.imagemat,n)}e.getProgram().setUniformMatrix("MCPCMatrix",t.imagemat)},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=r.getProperty(),i=a.getOpacity();o.setUniformf("opacity",i);const s=t.volumeTexture.getComponents(),l=a.getIndependentComponents();if(l)for(let e=0;e<s;++e)o.setUniformf(`mix${e}`,a.getComponentWeight(e));const c=t.volumeTexture.getVolumeInfo();for(let e=0;e<s;e++){let t=a.getColorWindow(),n=a.getColorLevel();const r=l?e:0,i=a.getRGBTransferFunction(r);if(i&&a.getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],n=.5*(e[1]+e[0])}const s=c.scale[e]/t,u=(c.offset[e]-n)/t+.5;o.setUniformf(`cshift${e}`,u),o.setUniformf(`cscale${e}`,s)}const u=t.colorTexture.getTextureUnit();o.setUniformi("colorTexture1",u);for(let e=0;e<s;e++){let t=1,n=0;const r=l?e:0,i=a.getPiecewiseFunction(r);if(i){const r=i.getRange(),o=r[1]-r[0],a=.5*(r[0]+r[1]);t=c.scale[e]/o,n=(c.offset[e]-a)/o+.5}o.setUniformf(`pwfshift${e}`,n),o.setUniformf(`pwfscale${e}`,t)}const d=t.pwfTexture.getTextureUnit();o.setUniformi("pwfTexture1",d)},e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.delete=Ht.chain((()=>{t._openGLRenderWindow&&n(t._openGLRenderWindow)}),e.delete)}(e,t)}),"vtkOpenGLImageCPRMapper");en("vtkImageCPRMapper",vf);const Tf={context:null,keyMatrixTime:null,keyMatrices:null};const yf=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Tf,n),Xt.extend(e,t,n),t.keyMatrixTime={},vt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={mcwc:g(new Float64Array(16))},St(e,t,["context"]),function(e,t){t.classHierarchy.push("vtkOpenGLImageSlice"),e.buildPass=n=>{if(t.renderable&&t.renderable.getVisibility()&&n){if(!t.renderable)return;t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes()}},e.traverseZBufferPass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.traverseOpaqueZBufferPass=t=>e.traverseOpaquePass(t),e.traverseOpaquePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.traverseTranslucentPass=n=>{!t.renderable||!t.renderable.getNestedVisibility()||t.renderable.getIsOpaque()||t._openGLRenderer.getSelector()&&!t.renderable.getNestedPickable()||(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;t.renderable.getIsOpaque()?n.incrementOpaqueActorCount():n.incrementTranslucentActorCount()}},e.zBufferPass=(t,n)=>e.opaquePass(t,n),e.opaqueZBufferPass=(t,n)=>e.opaquePass(t,n),e.opaquePass=(e,n)=>{e&&t.context.depthMask(!0)},e.translucentPass=(e,n)=>{t.context.depthMask(!e)},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(d(t.keyMatrices.mcwc,t.renderable.getMatrix()),m(t.keyMatrices.mcwc,t.keyMatrices.mcwc),t.keyMatrixTime.modified()),t.keyMatrices)}(e,t)}),"vtkOpenGLImageSlice");en("vtkImageSlice",yf);const bf={};const xf=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bf,n),Xt.extend(e,t,n),t.keyMatrixTime={},vt(t.keyMatrixTime,{mtime:0}),t.normalMatrix=new Float64Array(9),t.MCWCMatrix=new Float64Array(16),St(e,t,["context"]),function(e,t){t.classHierarchy.push("vtkOpenGLVolume"),e.buildPass=n=>{t.renderable&&t.renderable.getVisibility()&&n&&(t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes())},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementVolumeCount()}},e.traverseVolumePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children[0].traverse(n),e.apply(n,!1))},e.volumePass=e=>{t.renderable&&t.renderable.getVisibility()&&t.context.depthMask(!e)},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(t.renderable.computeMatrix(),d(t.MCWCMatrix,t.renderable.getMatrix()),m(t.MCWCMatrix,t.MCWCMatrix),t.renderable.getIsIdentity()?pe(t.normalMatrix):(se(t.normalMatrix,t.MCWCMatrix),ge(t.normalMatrix,t.normalMatrix),fe(t.normalMatrix,t.normalMatrix)),t.keyMatrixTime.modified()),{mcwc:t.MCWCMatrix,normalMatrix:t.normalMatrix})}(e,t)}),"vtkOpenGLVolume");en("vtkVolume",xf);const Cf={NEAREST:0,LINEAR:1,FAST_LINEAR:2},Sf={FRACTIONAL:0,PROPORTIONAL:1},Af={DEFAULT:0,ADDITIVE:1,COLORIZE:2,CUSTOM:3};var If={InterpolationType:Cf,OpacityMode:Sf,ColorMixPreset:Af,FilterMode:{OFF:0,NORMALIZED:1,RAW:2}};const wf={COMPOSITE_BLEND:0,MAXIMUM_INTENSITY_BLEND:1,MINIMUM_INTENSITY_BLEND:2,AVERAGE_INTENSITY_BLEND:3,ADDITIVE_INTENSITY_BLEND:4,RADON_TRANSFORM_BLEND:5,LABELMAP_EDGE_PROJECTION_BLEND:6};var Of={BlendMode:wf};const{vtkWarningMacro:Pf,vtkErrorMacro:Rf}=jt,Mf={idxToView:g(new Float64Array(16)),vecISToVCMatrix:pe(new Float64Array(9)),modelToView:g(new Float64Array(16)),projectionToView:g(new Float64Array(16)),projectionToWorld:g(new Float64Array(16))};const Ef={context:null,VBOBuildTime:null,scalarTextures:[],_scalarTexturesCore:[],opacityTexture:null,_opacityTextureCore:null,colorTexture:null,_colorTextureCore:null,labelOutlineThicknessTexture:null,_labelOutlineThicknessTextureCore:null,jitterTexture:null,tris:null,framebuffer:null,copyShader:null,copyVAO:null,lastXYF:1,targetXYF:1,zBufferTexture:null,lastZBufferTexture:null,fullViewportTime:1,idxToView:null,vecISToVCMatrix:null,modelToView:null,projectionToView:null,avgWindowArea:0,avgFrameTime:0};const Vf=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ef,n),Xt.extend(e,t,n),rd(e,t,n),t.VBOBuildTime={},vt(t.VBOBuildTime,{mtime:0}),t.tris=Du.newInstance(),t.jitterTexture=Ju.newInstance(),t.jitterTexture.setWrapS(Lu.REPEAT),t.jitterTexture.setWrapT(Lu.REPEAT),t.framebuffer=Zd.newInstance(),St(e,t,["context"]),function(e,t){function n(e){return e.getUseLabelOutline()||t.renderable.getBlendMode()===wf.LABELMAP_EDGE_PROJECTION_BLEND}t.classHierarchy.push("vtkOpenGLVolumeMapper");const r=new Map;function o(t,n,o){n!==o&&(function(t,n){if(!n)return;const o=(r.get(n)??0)-1;o<=0?(t.unregisterGraphicsResourceUser(n,e),r.delete(n)):r.set(n,o)}(t,n),function(t,n){if(!n)return;const o=r.get(n)??0,a=o+1;r.set(n,a),o<=0&&t.registerGraphicsResourceUser(n,e)}(t,o))}function a(t){[...r.keys()].forEach((n=>t.unregisterGraphicsResourceUser(n,e)))}e.buildPass=()=>{t.zBufferTexture=null},e.zBufferPass=(e,n)=>{if(e){const e=n.getZBufferTexture();e!==t.zBufferTexture&&(t.zBufferTexture=e)}},e.opaqueZBufferPass=(t,n)=>e.zBufferPass(t,n),e.volumePass=(n,r)=>{if(n){const n=t._openGLRenderWindow;t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),n&&!n.isDeleted()&&n!==t._openGLRenderWindow&&a(n),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow),t.jitterTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLVolume=e.getFirstAncestorOfType("vtkOpenGLVolume");const r=t.openGLVolume.getRenderable();t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer");const o=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(o.getActiveCamera()),e.renderPiece(o,r)}},e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexDC;\n\nvarying vec3 vertexVCVSOutput;\nuniform mat4 PCVCMatrix;\n\nuniform float dcxmin;\nuniform float dcxmax;\nuniform float dcymin;\nuniform float dcymax;\n\nvoid main()\n{\n  // dcsmall is the device coords reduced to the\n  // x y area covered by the volume\n  vec4 dcsmall = vec4(\n    dcxmin + 0.5 * (vertexDC.x + 1.0) * (dcxmax - dcxmin),\n    dcymin + 0.5 * (vertexDC.y + 1.0) * (dcymax - dcymin),\n    vertexDC.z,\n    vertexDC.w);\n  vec4 vcpos = PCVCMatrix * dcsmall;\n  vertexVCVSOutput = vcpos.xyz/vcpos.w;\n  gl_Position = dcsmall;\n}\n",e.Fragment="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkVolumeFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the volume mappers fragment shader\n\nconst float infinity = 3.402823466e38;\n\n// the output of this shader\n//VTK::Output::Dec\n\nin vec3 vertexVCVSOutput;\n\n// From Sources\\Rendering\\Core\\VolumeProperty\\Constants.js\n#define COMPOSITE_BLEND 0\n#define MAXIMUM_INTENSITY_BLEND 1\n#define MINIMUM_INTENSITY_BLEND 2\n#define AVERAGE_INTENSITY_BLEND 3\n#define ADDITIVE_INTENSITY_BLEND 4\n#define RADON_TRANSFORM_BLEND 5\n#define LABELMAP_EDGE_PROJECTION_BLEND 6\n\n#define vtkNumberOfLights //VTK::NumberOfLights\n#define vtkMaxLaoKernelSize //VTK::MaxLaoKernelSize\n#define vtkNumberOfComponents //VTK::NumberOfComponents\n#define vtkBlendMode //VTK::BlendMode\n#define vtkMaximumNumberOfSamples //VTK::MaximumNumberOfSamples\n\n//VTK::EnabledColorFunctions\n\n//VTK::EnabledLightings\n\n//VTK::EnabledMultiTexturePerVolume\n\n//VTK::EnabledGradientOpacity\n\n//VTK::EnabledIndependentComponents\n\n//VTK::vtkProportionalComponents\n\n//VTK::vtkForceNearestComponents\n\nuniform int twoSidedLighting;\n\n#if vtkMaxLaoKernelSize > 0\n  vec2 kernelSample[vtkMaxLaoKernelSize];\n#endif\n\n// Textures\n#ifdef EnabledMultiTexturePerVolume\n  #define vtkNumberOfVolumeTextures vtkNumberOfComponents\n#else\n  #define vtkNumberOfVolumeTextures 1\n#endif\nuniform highp sampler3D volumeTexture[vtkNumberOfVolumeTextures];\nuniform sampler2D colorTexture;\nuniform sampler2D opacityTexture;\nuniform sampler2D jtexture;\nuniform sampler2D labelOutlineThicknessTexture;\n\nstruct Volume {\n  // ---- Volume geometry settings ----\n\n  vec3 originVC;          // in VC\n  vec3 spacing;           // in VC per IC\n  vec3 inverseSpacing;    // 1/spacing\n  ivec3 dimensions;       // in IC\n  vec3 inverseDimensions; // 1/vec3(dimensions)\n  mat3 vecISToVCMatrix;   // convert from IS to VC without translation\n  mat3 vecVCToISMatrix;   // convert from VC to IS without translation\n  mat4 PCWCMatrix;\n  mat4 worldToIndex;\n  float diagonalLength; // in VC, this is: length(size)\n\n  // ---- Texture settings ----\n\n  // Texture shift and scale\n  vec4 colorTextureScale;\n  vec4 colorTextureShift;\n  vec4 opacityTextureScale;\n  vec4 opacityTextureShift;\n\n  // The heights defined below are the locations for the up to four components\n  // of the transfer functions. The transfer functions have a height of (2 *\n  // numberOfComponents) pixels so the values are computed to hit the middle of\n  // the two rows for that component\n  vec4 transferFunctionsSampleHeight;\n\n  // ---- Mode specific settings ----\n\n  // Independent component default preset settings per component\n  vec4 independentComponentMix;\n\n  // Additive / average blending mode settings\n  vec4 ipScalarRangeMin;\n  vec4 ipScalarRangeMax;\n\n  // ---- Rendering settings ----\n\n  // Lighting\n  float ambient;\n  float diffuse;\n  float specular;\n  float specularPower;\n  int computeNormalFromOpacity;\n\n  // Gradient opacity\n  vec4 gradientOpacityScale;\n  vec4 gradientOpacityShift;\n  vec4 gradientOpacityMin;\n  vec4 gradientOpacityMax;\n\n  // Volume shadow\n  float volumetricScatteringBlending;\n  float globalIlluminationReach;\n  float anisotropy;\n  float anisotropySquared;\n\n  // LAO\n  int kernelSize;\n  int kernelRadius;\n\n  // Label outline\n  float outlineOpacity;\n};\nuniform Volume volume;\n\nstruct Light {\n  vec3 color;\n  vec3 positionVC;\n  vec3 directionVC; // normalized\n  vec3 halfAngleVC;\n  vec3 attenuation;\n  float exponent;\n  float coneAngle;\n  int isPositional;\n};\n#if vtkNumberOfLights > 0\n  uniform Light lights[vtkNumberOfLights];\n#endif\n\nuniform float vpWidth;\nuniform float vpHeight;\nuniform float vpOffsetX;\nuniform float vpOffsetY;\n\n// Bitmasks for label outline\nconst int MAX_SEGMENT_INDEX = 256; // Define as per expected maximum\n#define MAX_SEGMENTS 256\n#define UINT_SIZE 32\n// We add UINT_SIZE - 1, as we want the ceil of the division instead of the\n// floor\n#define BITMASK_SIZE ((MAX_SEGMENTS + UINT_SIZE - 1) / UINT_SIZE)\nuint labelOutlineBitmasks[BITMASK_SIZE];\n\n// Set the corresponding bit in the bitmask\nvoid setLabelOutlineBit(int segmentIndex) {\n  int arrayIndex = segmentIndex / UINT_SIZE;\n  int bitIndex = segmentIndex % UINT_SIZE;\n  labelOutlineBitmasks[arrayIndex] |= 1u << bitIndex;\n}\n\n// Check if a bit is set in the bitmask\nbool isLabelOutlineBitSet(int segmentIndex) {\n  int arrayIndex = segmentIndex / UINT_SIZE;\n  int bitIndex = segmentIndex % UINT_SIZE;\n  return ((labelOutlineBitmasks[arrayIndex] & (1u << bitIndex)) != 0u);\n}\n\n// if you want to see the raw tiled\n// data in webgl1 uncomment the following line\n// #define debugtile\n\n// camera values\nuniform float camThick;\nuniform float camNear;\nuniform float camFar;\nuniform int cameraParallel;\n\n//VTK::ClipPlane::Dec\n\n// A random number between 0 and 1 that only depends on the fragment\n// It uses the jtexture, so this random seed repeats by blocks of 32 fragments\n// in screen space\nfloat fragmentSeed;\n\n// sample texture is global\nuniform float sampleDistance;\nuniform float volumeShadowSampleDistance;\n\n// declaration for intermixed geometry\n//VTK::ZBuffer::Dec\n\n//=======================================================================\n// global and custom variables (a temporary section before photorealistics\n// rendering module is complete)\nvec3 rayDirVC;\n\n#define INV4PI 0.0796\n#define EPSILON 0.001\n#define PI 3.1415\n#define PI2 9.8696\n\nvec4 rawSampleTexture(vec3 pos) {\n  #ifdef EnabledMultiTexturePerVolume\n    vec4 rawSample;\n    rawSample[0] = texture(volumeTexture[0], pos)[0];\n  #if vtkNumberOfComponents > 1\n    rawSample[1] = texture(volumeTexture[1], pos)[0];\n  #endif\n  #if vtkNumberOfComponents > 2\n    rawSample[2] = texture(volumeTexture[2], pos)[0];\n  #endif\n  #if vtkNumberOfComponents > 3\n    rawSample[3] = texture(volumeTexture[3], pos)[0];\n  #endif\n    return rawSample;\n  #else\n    return texture(volumeTexture[0], pos);\n  #endif\n}\n\nvec4 rawFetchTexture(ivec3 pos) {\n  #ifdef EnabledMultiTexturePerVolume\n    vec4 rawSample;\n    #if vtkNumberOfComponents > 0\n      rawSample[0] = texelFetch(volumeTexture[0], pos, 0)[0];\n    #endif\n    #if vtkNumberOfComponents > 1\n      rawSample[1] = texelFetch(volumeTexture[1], pos, 0)[0];\n    #endif\n    #if vtkNumberOfComponents > 2\n      rawSample[2] = texelFetch(volumeTexture[2], pos, 0)[0];\n    #endif\n    #if vtkNumberOfComponents > 3\n      rawSample[3] = texelFetch(volumeTexture[3], pos, 0)[0];\n    #endif\n    return rawSample;\n  #else\n    return texelFetch(volumeTexture[0], pos, 0);\n  #endif\n}\n\nvec4 getTextureValue(vec3 pos) {\n  vec4 tmp = rawSampleTexture(pos);\n\n  // Force nearest\n  #if defined(vtkComponent0ForceNearest) || \\\n      defined(vtkComponent1ForceNearest) || \\\n      defined(vtkComponent2ForceNearest) || \\\n      defined(vtkComponent3ForceNearest)\n    vec3 nearestPos = (floor(pos * vec3(volume.dimensions)) + 0.5) *\n                      volume.inverseDimensions;\n    vec4 nearestValue = rawSampleTexture(nearestPos);\n    #ifdef vtkComponent0ForceNearest\n      tmp[0] = nearestValue[0];\n    #endif\n    #ifdef vtkComponent1ForceNearest\n      tmp[1] = nearestValue[1];\n    #endif\n    #ifdef vtkComponent2ForceNearest\n      tmp[2] = nearestValue[2];\n    #endif\n    #ifdef vtkComponent3ForceNearest\n      tmp[3] = nearestValue[3];\n    #endif\n  #endif\n\n  // Set alpha when using dependent components\n  #ifndef EnabledIndependentComponents\n    #if vtkNumberOfComponents == 1\n      tmp.a = tmp.r;\n    #endif\n    #if vtkNumberOfComponents == 2\n      tmp.a = tmp.g;\n    #endif\n    #if vtkNumberOfComponents == 3\n      tmp.a = length(tmp.rgb);\n    #endif\n  #endif\n\n  return tmp;\n}\n\n// `height` is usually `volume.transferFunctionsSampleHeight[component]`\n// when using independent component and `0.5` otherwise. Don't move the if\n// statement in these function, as the callers usually already knows if it is\n// using independent component or not\nfloat getOpacityFromTexture(float scalar, int component, float height) {\n  float scaledScalar = scalar * volume.opacityTextureScale[component] +\n                       volume.opacityTextureShift[component];\n  return texture2D(opacityTexture, vec2(scaledScalar, height)).r;\n}\nvec3 getColorFromTexture(float scalar, int component, float height) {\n  float scaledScalar = scalar * volume.colorTextureScale[component] +\n                       volume.colorTextureShift[component];\n  return texture2D(colorTexture, vec2(scaledScalar, height)).rgb;\n}\n\n//=======================================================================\n// transformation between VC and IS space\n\n// convert vector position from idx to vc\nvec3 posIStoVC(vec3 posIS) {\n  return volume.vecISToVCMatrix * posIS + volume.originVC;\n}\n\n// convert vector position from vc to idx\nvec3 posVCtoIS(vec3 posVC) {\n  return volume.vecVCToISMatrix * (posVC - volume.originVC);\n}\n\n// Rotate vector to view coordinate\nvec3 vecISToVC(vec3 dirIS) {\n  return volume.vecISToVCMatrix * dirIS;\n}\n\n// Rotate vector to idx coordinate\nvec3 vecVCToIS(vec3 dirVC) {\n  return volume.vecVCToISMatrix * dirVC;\n}\n\n//=======================================================================\n// Given a normal compute the gradient opacity factors\nfloat computeGradientOpacityFactor(float normalMag, int component) {\n  float goscale = volume.gradientOpacityScale[component];\n  float goshift = volume.gradientOpacityShift[component];\n  float gomin = volume.gradientOpacityMin[component];\n  float gomax = volume.gradientOpacityMax[component];\n  return clamp(normalMag * goscale + goshift, gomin, gomax);\n}\n\n#ifdef vtkClippingPlanesOn\n  bool isPointClipped(vec3 posVC) {\n    for (int i = 0; i < clip_numPlanes; ++i) {\n      if (dot(vec3(vClipPlaneOrigins[i] - posVC), vClipPlaneNormals[i]) > 0.0) {\n        return true;\n      }\n    }\n    return false;\n  }\n#endif\n\n//=======================================================================\n// compute the normal and gradient magnitude for a position, uses forward\n// difference\n\n// The output normal is in VC\nvec4 computeDensityNormal(vec3 opacityUCoords[2], float opacityTextureHeight,\n                          float gradientOpacity, int component) {\n  // Pass the scalars through the opacity functions\n  vec4 opacityG;\n  opacityG.x += getOpacityFromTexture(opacityUCoords[0].x, component,\n                                      opacityTextureHeight);\n  opacityG.y += getOpacityFromTexture(opacityUCoords[0].y, component,\n                                      opacityTextureHeight);\n  opacityG.z += getOpacityFromTexture(opacityUCoords[0].z, component,\n                                      opacityTextureHeight);\n  opacityG.x -= getOpacityFromTexture(opacityUCoords[1].x, component,\n                                      opacityTextureHeight);\n  opacityG.y -= getOpacityFromTexture(opacityUCoords[1].y, component,\n                                      opacityTextureHeight);\n  opacityG.z -= getOpacityFromTexture(opacityUCoords[1].z, component,\n                                      opacityTextureHeight);\n\n  // Divide by spacing and convert to VC\n  opacityG.xyz *= gradientOpacity * volume.inverseSpacing;\n  opacityG.w = length(opacityG.xyz);\n  if (opacityG.w == 0.0) {\n    return vec4(0.0);\n  }\n\n  // Normalize\n  opacityG.xyz = normalize(vecISToVC(opacityG.xyz));\n\n  return opacityG;\n}\n\n// The output normal is in VC\nvec4 computeNormalForDensity(vec3 posIS, out vec3 scalarInterp[2],\n                             const int opacityComponent) {\n  vec3 offsetedPosIS;\n  for (int axis = 0; axis < 3; ++axis) {\n    // Positive direction\n    offsetedPosIS = posIS;\n    offsetedPosIS[axis] += volume.inverseDimensions[axis];\n    scalarInterp[0][axis] =\n        getTextureValue(offsetedPosIS)[opacityComponent];\n    #ifdef vtkClippingPlanesOn\n      if (isPointClipped(posIStoVC(offsetedPosIS))) {\n        scalarInterp[0][axis] = 0.0;\n      }\n    #endif\n\n    // Negative direction\n    offsetedPosIS = posIS;\n    offsetedPosIS[axis] -= volume.inverseDimensions[axis];\n    scalarInterp[1][axis] =\n        getTextureValue(offsetedPosIS)[opacityComponent];\n    #ifdef vtkClippingPlanesOn\n      if (isPointClipped(posIStoVC(offsetedPosIS))) {\n        scalarInterp[1][axis] = 0.0;\n      }\n    #endif\n  }\n\n  vec4 result;\n  result.xyz = (scalarInterp[0] - scalarInterp[1]) * volume.inverseSpacing;\n  result.w = length(result.xyz);\n  if (result.w == 0.0) {\n    return vec4(0.0);\n  }\n  result.xyz = normalize(vecISToVC(result.xyz));\n  return result;\n}\n\nvec4 fragCoordToPCPos(vec4 fragCoord) {\n  return vec4((fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,\n              (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,\n              (fragCoord.z - 0.5) * 2.0, 1.0);\n}\n\nvec4 pcPosToWorldCoord(vec4 pcPos) {\n  return volume.PCWCMatrix * pcPos;\n}\n\nvec3 fragCoordToIndexSpace(vec4 fragCoord) {\n  vec4 pcPos = fragCoordToPCPos(fragCoord);\n  vec4 worldCoord = pcPosToWorldCoord(pcPos);\n  vec4 vertex = (worldCoord / worldCoord.w);\n\n  vec3 index = (volume.worldToIndex * vertex).xyz;\n\n  // half voxel fix for labelmapOutline\n  return (index + vec3(0.5)) * volume.inverseDimensions;\n}\n\nvec3 fragCoordToWorld(vec4 fragCoord) {\n  vec4 pcPos = fragCoordToPCPos(fragCoord);\n  vec4 worldCoord = pcPosToWorldCoord(pcPos);\n  return worldCoord.xyz;\n}\n\n//=======================================================================\n// Compute the normals and gradient magnitudes for a position for independent\n// components The output normals are in VC\nmat4 computeMat4Normal(vec3 posIS, vec4 tValue) {\n  vec3 xvec = vec3(volume.inverseDimensions.x, 0.0, 0.0);\n  vec3 yvec = vec3(0.0, volume.inverseDimensions.y, 0.0);\n  vec3 zvec = vec3(0.0, 0.0, volume.inverseDimensions.z);\n\n  vec4 distX = getTextureValue(posIS + xvec) - getTextureValue(posIS - xvec);\n  vec4 distY = getTextureValue(posIS + yvec) - getTextureValue(posIS - yvec);\n  vec4 distZ = getTextureValue(posIS + zvec) - getTextureValue(posIS - zvec);\n\n  // divide by spacing\n  distX *= 0.5 * volume.inverseSpacing.x;\n  distY *= 0.5 * volume.inverseSpacing.y;\n  distZ *= 0.5 * volume.inverseSpacing.z;\n\n  mat4 result;\n\n  // optionally compute the 1st component\n  #if vtkNumberOfComponents > 0 && !defined(vtkComponent0Proportional)\n    {\n      const int component = 0;\n      vec3 normal = vec3(distX[component], distY[component], distZ[component]);\n      float normalLength = length(normal);\n      if (normalLength > 0.0) {\n        normal = normalize(vecISToVC(normal));\n      }\n      result[component] = vec4(normal, normalLength);\n    }\n  #endif\n\n  // optionally compute the 2nd component\n  #if vtkNumberOfComponents > 1 && !defined(vtkComponent1Proportional)\n    {\n      const int component = 1;\n      vec3 normal = vec3(distX[component], distY[component], distZ[component]);\n      float normalLength = length(normal);\n      if (normalLength > 0.0) {\n        normal = normalize(vecISToVC(normal));\n      }\n      result[component] = vec4(normal, normalLength);\n    }\n  #endif\n\n  // optionally compute the 3rd component\n  #if vtkNumberOfComponents > 2 && !defined(vtkComponent2Proportional)\n    {\n      const int component = 2;\n      vec3 normal = vec3(distX[component], distY[component], distZ[component]);\n      float normalLength = length(normal);\n      if (normalLength > 0.0) {\n        normal = normalize(vecISToVC(normal));\n      }\n      result[component] = vec4(normal, normalLength);\n    }\n  #endif\n\n  // optionally compute the 4th component\n  #if vtkNumberOfComponents > 3 && !defined(vtkComponent3Proportional)\n    {\n      const int component = 3;\n      vec3 normal = vec3(distX[component], distY[component], distZ[component]);\n      float normalLength = length(normal);\n      if (normalLength > 0.0) {\n        normal = normalize(vecISToVC(normal));\n      }\n      result[component] = vec4(normal, normalLength);\n    }\n  #endif\n\n  return result;\n}\n\n//=======================================================================\n// global shadow - secondary ray\n\n// henyey greenstein phase function\nfloat phaseFunction(float cos_angle) {\n  // divide by 2.0 instead of 4pi to increase intensity\n  float anisotropy = volume.anisotropy;\n  if (abs(anisotropy) <= EPSILON) {\n    // isotropic scatter returns 0.5 instead of 1/4pi to increase intensity\n    return 0.5;\n  }\n  float anisotropy2 = volume.anisotropySquared;\n  return ((1.0 - anisotropy2) /\n          pow(1.0 + anisotropy2 - 2.0 * anisotropy * cos_angle, 1.5)) /\n         2.0;\n}\n\n// Compute the two intersection distances of the ray with the volume in VC\n// The entry point is `rayOriginVC + distanceMin * rayDirVC` and the exit point\n// is `rayOriginVC + distanceMax * rayDirVC` If distanceMin < distanceMax, the\n// volume is not intersected The ray origin is inside the box when distanceMin <\n// 0.0 < distanceMax\nvec2 rayIntersectVolumeDistances(vec3 rayOriginVC, vec3 rayDirVC) {\n  // Compute origin and direction in IS\n  vec3 rayOriginIS = posVCtoIS(rayOriginVC);\n  vec3 rayDirIS = vecVCToIS(rayDirVC);\n  // Don't check for infinity as the min/max combination afterward will always\n  // find an intersection before infinity\n  vec3 invDir = 1.0 / rayDirIS;\n\n  // We have: bound = origin + t * dir\n  // So: t = (1/dir) * (bound - origin)\n  vec3 distancesTo0 = invDir * (vec3(0.0) - rayOriginIS);\n  vec3 distancesTo1 = invDir * (vec3(1.0) - rayOriginIS);\n  // Min and max distances to plane intersection per plane\n  vec3 dMinPerAxis = min(distancesTo0, distancesTo1);\n  vec3 dMaxPerAxis = max(distancesTo0, distancesTo1);\n  // Overall first and last intersection\n  float distanceMin = max(dMinPerAxis.x, max(dMinPerAxis.y, dMinPerAxis.z));\n  float distanceMax = min(dMaxPerAxis.x, min(dMaxPerAxis.y, dMaxPerAxis.z));\n  return vec2(distanceMin, distanceMax);\n}\n\n//=======================================================================\n// local ambient occlusion\n#if vtkMaxLaoKernelSize > 0\n\n  // Return a random point on the unit sphere\n  vec3 sampleDirectionUniform(int rayIndex) {\n    // Each ray of each fragment should be different, two sources of randomness\n    // are used. Only depends on ray index\n    vec2 rayRandomness = kernelSample[rayIndex];\n    // Only depends on fragment\n    float fragmentRandomness = fragmentSeed;\n    // Merge both source of randomness in a single uniform random variable using\n    // the formula (x+y < 1 ? x+y : x+y-1). The simpler formula (x+y)/2 doesn't\n    // result in a uniform distribution\n    vec2 mergedRandom = rayRandomness + vec2(fragmentRandomness);\n    mergedRandom -= vec2(greaterThanEqual(mergedRandom, vec2(1.0)));\n\n    // Insipred by:\n    // https://karthikkaranth.me/blog/generating-random-points-in-a-sphere/#better-choice-of-spherical-coordinates\n    float u = mergedRandom[0];\n    float v = mergedRandom[1];\n    float theta = u * 2.0 * PI;\n    float phi = acos(2.0 * v - 1.0);\n    float sinTheta = sin(theta);\n    float cosTheta = cos(theta);\n    float sinPhi = sin(phi);\n    float cosPhi = cos(phi);\n    return vec3(sinPhi * cosTheta, sinPhi * sinTheta, cosPhi);\n  }\n\n  float computeLAO(vec3 posVC, vec4 normalVC, float originalOpacity) {\n    // apply LAO only at selected locations, otherwise return full brightness\n    if (normalVC.w <= 0.0 || originalOpacity <= 0.05) {\n      return 1.0;\n    }\n\n    #ifdef EnabledGradientOpacity\n      float gradientOpacityFactor = computeGradientOpacityFactor(normalVC.w, 0);\n    #endif\n\n    float visibilitySum = 0.0;\n    float weightSum = 0.0;\n    for (int i = 0; i < volume.kernelSize; i++) {\n      // Only sample on an hemisphere around the normalVC.xyz axis, so\n      // normalDotRay should be negative\n      vec3 rayDirectionVC = sampleDirectionUniform(i);\n      float normalDotRay = dot(normalVC.xyz, rayDirectionVC);\n      if (normalDotRay > 0.0) {\n        // Flip rayDirectionVC when it is in the wrong hemisphere\n        rayDirectionVC = -rayDirectionVC;\n        normalDotRay = -normalDotRay;\n      }\n\n      vec3 currPosIS = posVCtoIS(posVC);\n      float visibility = 1.0;\n      vec3 randomDirStepIS = vecVCToIS(rayDirectionVC * sampleDistance);\n      for (int j = 0; j < volume.kernelRadius; j++) {\n        currPosIS += randomDirStepIS;\n        // If out of the volume, we are done\n        if (any(lessThan(currPosIS, vec3(0.0))) ||\n            any(greaterThan(currPosIS, vec3(1.0)))) {\n          break;\n        }\n        float opacity = getOpacityFromTexture(getTextureValue(currPosIS).r, 0, 0.5);\n        #ifdef EnabledGradientOpacity\n          opacity *= gradientOpacityFactor;\n        #endif\n        visibility *= 1.0 - opacity;\n        // If visibility is less than EPSILON, consider it to be 0\n        if (visibility < EPSILON) {\n          visibility = 0.0;\n          break;\n        }\n      }\n      float rayWeight = -normalDotRay;\n      visibilitySum += visibility * rayWeight;\n      weightSum += rayWeight;\n    }\n\n    // If no sample, LAO factor is one\n    if (weightSum == 0.0) {\n      return 1.0;\n    }\n\n    // LAO factor is the average visibility:\n    // - visibility low => ambient low\n    // - visibility high => ambient high\n    float lao = visibilitySum / weightSum;\n\n    // Reduce variance by clamping\n    return clamp(lao, 0.3, 1.0);\n  }\n#endif\n\n//=======================================================================\n// Volume shadows\n#if vtkNumberOfLights > 0\n\n  // Non-memoised version\n  float computeVolumeShadowWithoutCache(vec3 posVC, vec3 lightDirNormVC) {\n    // modify sample distance with a random number between 1.5 and 3.0\n    float rayStepLength =\n        volumeShadowSampleDistance * mix(1.5, 3.0, fragmentSeed);\n\n    // in case the first sample near surface has a very tiled light ray, we need\n    // to offset start position\n    vec3 initialPosVC = posVC + rayStepLength * lightDirNormVC;\n\n    #ifdef vtkClippingPlanesOn\n      float clippingPlanesMaxDistance = infinity;\n      for (int i = 0; i < clip_numPlanes; ++i) {\n        // Find distance of intersection with the plane\n        // Points are clipped when:\n        // dot(planeOrigin - (rayOrigin + distance * rayDirection), planeNormal) > 0\n        // This is equivalent to:\n        // dot(planeOrigin - rayOrigin, planeNormal) - distance * dot(rayDirection,\n        // planeNormal) > 0.0\n        // We precompute the dot products, so we clip ray points when:\n        // dotOrigin - distance * dotDirection > 0.0\n        float dotOrigin =\n            dot(vClipPlaneOrigins[i] - initialPosVC, vClipPlaneNormals[i]);\n        if (dotOrigin > 0.0) {\n          // The initialPosVC is clipped by this plane\n          return 1.0;\n        }\n        float dotDirection = dot(lightDirNormVC, vClipPlaneNormals[i]);\n        if (dotDirection < 0.0) {\n          // We only hit the plane if dotDirection is negative, as (distance is\n          // positive)\n          float intersectionDistance =\n              dotOrigin / dotDirection; // negative divided by negative => positive\n          clippingPlanesMaxDistance =\n              min(clippingPlanesMaxDistance, intersectionDistance);\n        }\n      }\n    #endif\n\n    vec2 intersectionDistances =\n        rayIntersectVolumeDistances(initialPosVC, lightDirNormVC);\n\n    if (intersectionDistances[1] <= intersectionDistances[0] ||\n        intersectionDistances[1] <= 0.0) {\n      // Volume not hit or behind the ray\n      return 1.0;\n    }\n\n    // When globalIlluminationReach is 0, no sample at all\n    // When globalIlluminationReach is 1, the ray will go through the whole\n    // volume\n    float maxTravelDistance = mix(0.0, volume.diagonalLength,\n                                  volume.globalIlluminationReach);\n    float startDistance = max(intersectionDistances[0], 0.0);\n    float endDistance = min(intersectionDistances[1], startDistance + maxTravelDistance);\n    #ifdef vtkClippingPlanesOn\n      endDistance = min(endDistance, clippingPlanesMaxDistance);\n    #endif\n    if (endDistance - startDistance < 0.0) {\n      return 1.0;\n    }\n\n    // These two variables are used to compute posIS, without having to call\n    // VCtoIS at each step\n    vec3 initialPosIS = posVCtoIS(initialPosVC);\n    // The light dir is scaled and rotated, but not translated, as it is a\n    // vector (w = 0)\n    vec3 scaledLightDirIS = vecVCToIS(lightDirNormVC);\n\n    float shadow = 1.0;\n    for (float currentDistance = startDistance; currentDistance <= endDistance;\n          currentDistance += rayStepLength) {\n      vec3 posIS = initialPosIS + currentDistance * scaledLightDirIS;\n      vec4 scalar = getTextureValue(posIS);\n      float opacity = getOpacityFromTexture(scalar.r, 0, 0.5);\n      #if defined(EnabledGradientOpacity) && !defined(EnabledIndependentComponents)\n        vec3 scalarInterp[2];\n        vec4 normal = computeNormalForDensity(posIS, scalarInterp, 3);\n        float opacityFactor = computeGradientOpacityFactor(normal.w, 0);\n        opacity *= opacityFactor;\n      #endif\n      shadow *= 1.0 - opacity;\n\n      // Early termination if shadow coeff is near 0.0\n      if (shadow < EPSILON) {\n        return 0.0;\n      }\n    }\n    return shadow;\n  }\n\n  // Some cache for volume shadows\n  struct {\n    vec3 posVC;\n    float shadow;\n  } cachedShadows[vtkNumberOfLights];\n\n  // Memoised version\n  float computeVolumeShadow(vec3 posVC, vec3 lightDirNormVC, int lightIdx) {\n    if (posVC == cachedShadows[lightIdx].posVC) {\n      return cachedShadows[lightIdx].shadow;\n    }\n    float shadow = computeVolumeShadowWithoutCache(posVC, lightDirNormVC);\n    cachedShadows[lightIdx].posVC = posVC;\n    cachedShadows[lightIdx].shadow = shadow;\n    return shadow;\n  }\n\n#endif\n\n//=======================================================================\n// surface light contribution\n#if vtkNumberOfLights > 0\n  vec3 applyLighting(vec3 tColor, vec4 normalVC) {\n    vec3 diffuse = vec3(0.0, 0.0, 0.0);\n    vec3 specular = vec3(0.0, 0.0, 0.0);\n    for (int lightIdx = 0; lightIdx < vtkNumberOfLights; lightIdx++) {\n      float df = dot(normalVC.xyz, lights[lightIdx].directionVC);\n      if (df > 0.0) {\n        diffuse += df * lights[lightIdx].color;\n        float sf = dot(normalVC.xyz, -lights[lightIdx].halfAngleVC);\n        if (sf > 0.0) {\n          specular += pow(sf, volume.specularPower) * lights[lightIdx].color;\n        }\n      }\n    }\n    return tColor * (diffuse * volume.diffuse + volume.ambient) +\n          specular * volume.specular;\n  }\n\n  vec3 applySurfaceShadowLighting(vec3 tColor, float alpha, vec3 posVC,\n                                  vec4 normalVC) {\n    // everything in VC\n    vec3 diffuse = vec3(0.0);\n    vec3 specular = vec3(0.0);\n    for (int ligthIdx = 0; ligthIdx < vtkNumberOfLights; ligthIdx++) {\n      vec3 vertLightDirection;\n      float attenuation;\n      if (lights[ligthIdx].isPositional == 1) {\n        vertLightDirection = posVC - lights[ligthIdx].positionVC;\n        float lightDistance = length(vertLightDirection);\n        // Normalize with precomputed length\n        vertLightDirection = vertLightDirection / lightDistance;\n        // Base attenuation\n        vec3 attenuationPolynom = lights[ligthIdx].attenuation;\n        attenuation =\n            1.0 / (attenuationPolynom[0] +\n                  lightDistance * (attenuationPolynom[1] +\n                                    lightDistance * attenuationPolynom[2]));\n        // Cone attenuation\n        float coneDot = dot(vertLightDirection, lights[ligthIdx].directionVC);\n        // Per OpenGL standard cone angle is 90 or less for a spot light\n        if (lights[ligthIdx].coneAngle <= 90.0) {\n          if (coneDot >= cos(radians(lights[ligthIdx].coneAngle))) {\n            // Inside the cone\n            attenuation *= pow(coneDot, lights[ligthIdx].exponent);\n          } else {\n            // Outside the cone\n            attenuation = 0.0;\n          }\n        }\n      } else {\n        vertLightDirection = lights[ligthIdx].directionVC;\n        attenuation = 1.0;\n      }\n\n      float ndotL = dot(normalVC.xyz, vertLightDirection);\n      if (ndotL < 0.0 && twoSidedLighting == 1) {\n        ndotL = -ndotL;\n      }\n      if (ndotL > 0.0) {\n        // Diffuse\n        diffuse += ndotL * attenuation * lights[ligthIdx].color;\n        // Specular\n        float vdotR =\n            dot(-rayDirVC, normalize(vertLightDirection - 2.0 * ndotL * normalVC.xyz));\n        if (vdotR > 0.0) {\n          specular += pow(vdotR, volume.specularPower) * attenuation *\n                      lights[ligthIdx].color;\n        }\n      }\n    }\n    #if vtkMaxLaoKernelSize > 0\n      float laoFactor = computeLAO(posVC, normalVC, alpha);\n    #else\n      const float laoFactor = 1.0;\n    #endif\n    return tColor * (diffuse * volume.diffuse +\n                    volume.ambient * laoFactor) +\n          specular * volume.specular;\n  }\n\n  vec3 applyVolumeShadowLighting(vec3 tColor, vec3 posVC) {\n    // Here we have no effect of cones and no attenuation\n    vec3 diffuse = vec3(0.0);\n    for (int lightIdx = 0; lightIdx < vtkNumberOfLights; lightIdx++) {\n      vec3 lightDirVC = lights[lightIdx].isPositional == 1\n                            ? normalize(lights[lightIdx].positionVC - posVC)\n                            : -lights[lightIdx].directionVC;\n      float shadowCoeff = computeVolumeShadow(posVC, lightDirVC, lightIdx);\n      float phaseAttenuation = phaseFunction(dot(rayDirVC, lightDirVC));\n      diffuse += phaseAttenuation * shadowCoeff * lights[lightIdx].color;\n    }\n    return tColor * (diffuse * volume.diffuse + volume.ambient);\n  }\n#endif\n\n// LAO of surface shadows and volume shadows only work with dependent components\nvec3 applyAllLightning(vec3 tColor, float alpha, vec3 posVC,\n                       vec4 surfaceNormalVC) {\n  #if vtkNumberOfLights > 0\n    // 0 <= volCoeff < EPSILON => only surface shadows\n    // EPSILON <= volCoeff < 1 - EPSILON => mix of surface and volume shadows\n    // 1 - EPSILON <= volCoeff => only volume shadows\n    float volCoeff = volume.volumetricScatteringBlending *\n                    (1.0 - alpha / 2.0) *\n                    (1.0 - atan(surfaceNormalVC.w) * INV4PI);\n\n    // Compute surface lighting if needed\n    vec3 surfaceShadedColor = tColor;\n    #ifdef EnableSurfaceLighting\n      if (volCoeff < 1.0 - EPSILON) {\n        surfaceShadedColor =\n            applySurfaceShadowLighting(tColor, alpha, posVC, surfaceNormalVC);\n      }\n    #endif\n\n    // Compute volume lighting if needed\n    vec3 volumeShadedColor = tColor;\n    #ifdef EnableVolumeLighting\n      if (volCoeff >= EPSILON) {\n        volumeShadedColor = applyVolumeShadowLighting(tColor, posVC);\n      }\n    #endif\n\n    // Return the right mix\n    if (volCoeff < EPSILON) {\n      // Surface shadows\n      return surfaceShadedColor;\n    }\n    if (volCoeff >= 1.0 - EPSILON) {\n      // Volume shadows\n      return volumeShadedColor;\n    }\n    // Mix of surface and volume shadows\n    return mix(surfaceShadedColor, volumeShadedColor, volCoeff);\n  #endif\n  return tColor;\n}\n\nvec4 getColorForLabelOutline() {\n  vec3 centerPosIS =\n      fragCoordToIndexSpace(gl_FragCoord); // pos in texture space\n  vec4 centerValue = getTextureValue(centerPosIS);\n  bool pixelOnBorder = false;\n  vec4 tColor = vec4(getColorFromTexture(centerValue.r, 0, 0.5),\n                     getOpacityFromTexture(centerValue.r, 0, 0.5));\n\n  int segmentIndex = int(centerValue.r * 255.0);\n\n  // Use texture sampling for outlineThickness\n  float textureCoordinate = float(segmentIndex - 1) / 1024.0;\n  float textureValue =\n      texture2D(labelOutlineThicknessTexture, vec2(textureCoordinate, 0.5)).r;\n  int actualThickness = int(textureValue * 255.0);\n\n  // If it is the background (segment index 0), we should quickly bail out.\n  // Previously, this was determined by tColor.a, which was incorrect as it\n  // prevented the outline from appearing when the fill is 0.\n  if (segmentIndex == 0) {\n    return vec4(0, 0, 0, 0);\n  }\n\n  // Only perform outline check on fragments rendering voxels that aren't\n  // invisible. Saves a bunch of needless checks on the background.\n  // TODO define epsilon when building shader?\n  for (int i = -actualThickness; i <= actualThickness; i++) {\n    for (int j = -actualThickness; j <= actualThickness; j++) {\n      if (i == 0 || j == 0) {\n        continue;\n      }\n\n      vec4 neighborPixelCoord =\n          vec4(gl_FragCoord.x + float(i), gl_FragCoord.y + float(j),\n               gl_FragCoord.z, gl_FragCoord.w);\n\n      vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\n      vec4 value = getTextureValue(neighborPosIS);\n\n      // If any of my neighbours are not the same value as I\n      // am, this means I am on the border of the segment.\n      // We can break the loops\n      if (any(notEqual(value, centerValue))) {\n        pixelOnBorder = true;\n        break;\n      }\n    }\n\n    if (pixelOnBorder == true) {\n      break;\n    }\n  }\n\n  // If I am on the border, I am displayed at full opacity\n  if (pixelOnBorder == true) {\n    tColor.a = volume.outlineOpacity;\n  }\n\n  return tColor;\n}\n\nvec4 getColorForAdditivePreset(vec4 tValue, vec3 posVC, vec3 posIS) {\n  // compute normals\n  mat4 normalMat = computeMat4Normal(posIS, tValue);\n  vec4 normalLights[2];\n  normalLights[0] = normalMat[0];\n  normalLights[1] = normalMat[1];\n  #if vtkNumberOfLights > 0\n    if (volume.computeNormalFromOpacity == 1) {\n      for (int component = 0; component < 2; ++component) {\n        vec3 scalarInterp[2];\n        float height = volume.transferFunctionsSampleHeight[component];\n        computeNormalForDensity(posIS, scalarInterp, component);\n        normalLights[component] =\n            computeDensityNormal(scalarInterp, height, 1.0, component);\n      }\n    }\n  #endif\n\n  // compute opacities\n  float opacities[2];\n  opacities[0] = getOpacityFromTexture(\n      tValue[0], 0, volume.transferFunctionsSampleHeight[0]);\n  opacities[1] = getOpacityFromTexture(\n      tValue[1], 1, volume.transferFunctionsSampleHeight[1]);\n  #ifdef EnabledGradientOpacity\n    for (int component = 0; component < 2; ++component) {\n      opacities[component] *=\n          computeGradientOpacityFactor(normalMat[component].a, component);\n    }\n  #endif\n  float opacitySum = opacities[0] + opacities[1];\n  if (opacitySum <= 0.0) {\n    return vec4(0.0);\n  }\n\n  // mix the colors and opacities\n  vec3 colors[2];\n  for (int component = 0; component < 2; ++component) {\n    float sampleHeight = volume.transferFunctionsSampleHeight[component];\n    vec3 color = getColorFromTexture(tValue[component], component, sampleHeight);\n    color = applyAllLightning(color, opacities[component], posVC,\n                              normalLights[component]);\n    colors[component] = color;\n  }\n  vec3 mixedColor =\n      (opacities[0] * colors[0] + opacities[1] * colors[1]) / opacitySum;\n  return vec4(mixedColor, min(1.0, opacitySum));\n}\n\nvec4 getColorForColorizePreset(vec4 tValue, vec3 posVC, vec3 posIS) {\n  // compute normals\n  mat4 normalMat = computeMat4Normal(posIS, tValue);\n  vec4 normalLight = normalMat[0];\n  #if vtkNumberOfLights > 0\n    if (volume.computeNormalFromOpacity == 1) {\n      vec3 scalarInterp[2];\n      float height = volume.transferFunctionsSampleHeight[0];\n      computeNormalForDensity(posIS, scalarInterp, 0);\n      normalLight = computeDensityNormal(scalarInterp, height, 1.0, 0);\n    }\n  #endif\n\n  // compute opacities\n  float opacity = getOpacityFromTexture(\n      tValue[0], 0, volume.transferFunctionsSampleHeight[0]);\n  #ifdef EnabledGradientOpacity\n    opacity *= computeGradientOpacityFactor(normalMat[0].a, 0);\n  #endif\n\n  // colorizing component\n  vec3 colorizingColor = getColorFromTexture(\n      tValue[0], 1, volume.transferFunctionsSampleHeight[1]);\n  float colorizingOpacity = getOpacityFromTexture(\n      tValue[1], 1, volume.transferFunctionsSampleHeight[1]);\n\n  // mix the colors and opacities\n  vec3 color =\n      getColorFromTexture(tValue[0], 0,\n                          volume.transferFunctionsSampleHeight[0]) *\n      mix(vec3(1.0), colorizingColor, colorizingOpacity);\n  color = applyAllLightning(color, opacity, posVC, normalLight);\n  return vec4(color, opacity);\n}\n\nvec4 getColorForDefaultIndependentPreset(vec4 tValue, vec3 posIS) {\n\n  // compute the normal vectors as needed\n  #if defined(EnabledGradientOpacity) || vtkNumberOfLights > 0\n    mat4 normalMat = computeMat4Normal(posIS, tValue);\n  #endif\n\n  // process color and opacity for each component\n  // initial value of alpha is determined by wether the first component is\n  // proportional or not\n  #if defined(vtkComponent0Proportional)\n    // when it is proportional, it starts at 1 (neutral for multiplications)\n    float alpha = 1.0;\n  #else\n    // when it is not proportional, it starts at 0 (neutral for additions)\n    float alpha = 0.0;\n  #endif\n\n  vec3 mixedColor = vec3(0.0);\n  #if vtkNumberOfComponents > 0\n    {\n      const int component = 0;\n      vec3 color = getColorFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      float opacity = getOpacityFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      #if !defined(vtkComponent0Proportional)\n        float alphaContribution = volume.independentComponentMix[component] * opacity;\n        #ifdef EnabledGradientOpacity\n          alphaContribution *= computeGradientOpacityFactor(normalMat[component].a, component);\n        #endif\n        alpha += alphaContribution;\n        #if vtkNumberOfLights > 0\n          color = applyLighting(color, normalMat[component]);\n        #endif\n      #else\n        color *= opacity;\n        alpha *= mix(opacity, 1.0,\n                    (1.0 - volume.independentComponentMix[component]));\n      #endif\n      mixedColor += volume.independentComponentMix[component] * color;\n    }\n  #endif\n  #if vtkNumberOfComponents > 1\n    {\n      const int component = 1;\n      vec3 color = getColorFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      float opacity = getOpacityFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      #if !defined(vtkComponent1Proportional)\n        float alphaContribution = volume.independentComponentMix[component] * opacity;\n        #ifdef EnabledGradientOpacity\n          alphaContribution *= computeGradientOpacityFactor(normalMat[component].a, component);\n        #endif\n        alpha += alphaContribution;\n        #if vtkNumberOfLights > 0\n          color = applyLighting(color, normalMat[component]);\n        #endif\n      #else\n        color *= opacity;\n        alpha *= mix(opacity, 1.0,\n                    (1.0 - volume.independentComponentMix[component]));\n      #endif\n      mixedColor += volume.independentComponentMix[component] * color;\n    }\n  #endif\n  #if vtkNumberOfComponents > 2\n    {\n      const int component = 2;\n      vec3 color = getColorFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      float opacity = getOpacityFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      #if !defined(vtkComponent2Proportional)\n        float alphaContribution = volume.independentComponentMix[component] * opacity;\n        #ifdef EnabledGradientOpacity\n          alphaContribution *= computeGradientOpacityFactor(normalMat[component].a, component);\n        #endif\n        alpha += alphaContribution;\n        #if vtkNumberOfLights > 0\n          color = applyLighting(color, normalMat[component]);\n        #endif\n      #else\n        color *= opacity;\n        alpha *= mix(opacity, 1.0,\n                    (1.0 - volume.independentComponentMix[component]));\n      #endif\n      mixedColor += volume.independentComponentMix[component] * color;\n    }\n  #endif\n  #if vtkNumberOfComponents > 3\n    {\n      const int component = 3;\n      vec3 color = getColorFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      float opacity = getOpacityFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      #if !defined(vtkComponent3Proportional)\n        float alphaContribution = volume.independentComponentMix[component] * opacity;\n        #ifdef EnabledGradientOpacity\n          alphaContribution *= computeGradientOpacityFactor(normalMat[component].a, component);\n        #endif\n        alpha += alphaContribution;\n        #if vtkNumberOfLights > 0\n          color = applyLighting(color, normalMat[component]);\n        #endif\n      #else\n        color *= opacity;\n        alpha *= mix(opacity, 1.0,\n                    (1.0 - volume.independentComponentMix[component]));\n      #endif\n      mixedColor += volume.independentComponentMix[component] * color;\n    }\n  #endif\n\n  return vec4(mixedColor, alpha);\n}\n\nvec4 getColorForDependentComponents(vec4 tValue, vec3 posVC, vec3 posIS) {\n  #if defined(EnabledGradientOpacity) || vtkNumberOfLights > 0\n    // use component 3 of the opacity texture as getTextureValue() sets alpha to\n    // the opacity value\n    vec3 scalarInterp[2];\n    vec4 normal0 = computeNormalForDensity(posIS, scalarInterp, 3);\n    float gradientOpacity = computeGradientOpacityFactor(normal0.a, 0);\n  #endif\n\n  // get color and opacity\n  #if vtkNumberOfComponents == 1\n    vec3 tColor = getColorFromTexture(tValue.r, 0, 0.5);\n    float alpha = getOpacityFromTexture(tValue.r, 0, 0.5);\n  #endif\n  #if vtkNumberOfComponents == 2\n    vec3 tColor = vec3(tValue.r * volume.colorTextureScale[0] +\n                  volume.colorTextureShift[0]);\n    float alpha = getOpacityFromTexture(tValue.a, 1, 0.5);\n  #endif\n  #if vtkNumberOfComponents == 3\n      vec3 tColor = tValue.rgb * volume.colorTextureScale.rgb +\n              volume.colorTextureShift.rgb;\n      float alpha = getOpacityFromTexture(tValue.a, 0, 0.5);\n  #endif\n  #if vtkNumberOfComponents == 4\n      vec3 tColor = tValue.rgb * volume.colorTextureScale.rgb +\n              volume.colorTextureShift.rgb;\n      float alpha = getOpacityFromTexture(tValue.a, 3, 0.5);\n  #endif\n\n  // Apply gradient opacity\n  #if defined(EnabledGradientOpacity)\n    alpha *= gradientOpacity;\n  #endif\n\n  #if vtkNumberOfComponents == 1\n    if (alpha < EPSILON) {\n      return vec4(0.0);\n    }\n  #endif\n\n  // lighting\n  #if vtkNumberOfLights > 0\n    vec4 normalLight;\n    if (volume.computeNormalFromOpacity == 1) {\n      if (normal0[3] != 0.0) {\n        normalLight =\n            computeDensityNormal(scalarInterp, 0.5, gradientOpacity, 0);\n        if (normalLight[3] == 0.0) {\n          normalLight = normal0;\n        }\n      }\n    } else {\n      normalLight = normal0;\n    }\n    tColor = applyAllLightning(tColor, alpha, posVC, normalLight);\n  #endif\n\n  return vec4(tColor, alpha);\n}\n\nvec4 getColorForValue(vec4 tValue, vec3 posVC, vec3 posIS) {\n  #ifdef EnableColorForValueFunctionId0\n    return getColorForDependentComponents(tValue, posVC, posIS);\n  #endif\n\n  #ifdef EnableColorForValueFunctionId1\n    return getColorForAdditivePreset(tValue, posVC, posIS);\n  #endif\n\n  #ifdef EnableColorForValueFunctionId2\n    return getColorForColorizePreset(tValue, posVC, posIS);\n  #endif\n\n  #ifdef EnableColorForValueFunctionId3\n    /*\n      * Mix the color information from all the independent components to get a\n      * single rgba output. See other shader functions like\n      * `getColorForAdditivePreset` to learn how to create a custom color mix.\n      * The custom color mix should return a value, but if it doesn't, it will\n      * fallback on the default shading\n      */\n    //VTK::CustomColorMix\n  #endif\n\n  #if defined(EnableColorForValueFunctionId4) || defined(EnableColorForValueFunctionId3)\n    return getColorForDefaultIndependentPreset(tValue, posIS);\n  #endif\n\n  #ifdef EnableColorForValueFunctionId5\n    return getColorForLabelOutline();\n  #endif\n}\n\nbool valueWithinScalarRange(vec4 val) {\n  #if vtkNumberOfComponents > 1 && !defined(EnabledIndependentComponents)\n    return false;\n  #endif\n  vec4 rangeMin = volume.ipScalarRangeMin;\n  vec4 rangeMax = volume.ipScalarRangeMax;\n  for (int component = 0; component < vtkNumberOfComponents; ++component) {\n    if (val[component] < rangeMin[component] ||\n        rangeMax[component] < val[component]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n#if vtkBlendMode == LABELMAP_EDGE_PROJECTION_BLEND\n  bool checkOnEdgeForNeighbor(int xFragmentOffset, int yFragmentOffset,\n                              int segmentIndex, vec3 stepIS) {\n    vec3 volumeDimensions = vec3(volume.dimensions);\n    vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(xFragmentOffset),\n                                  gl_FragCoord.y + float(yFragmentOffset),\n                                  gl_FragCoord.z, gl_FragCoord.w);\n    vec3 originalNeighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\n\n    vec3 neighborPosIS = originalNeighborPosIS;\n    for (int k = 0; k < vtkMaximumNumberOfSamples / 2; ++k) {\n      ivec3 texCoord = ivec3(neighborPosIS * volumeDimensions);\n      vec4 texValue = rawFetchTexture(texCoord);\n      if (int(texValue.g) == segmentIndex) {\n        // not on edge\n        return false;\n      }\n      neighborPosIS += stepIS;\n    }\n\n    neighborPosIS = originalNeighborPosIS;\n    for (int k = 0; k < vtkMaximumNumberOfSamples / 2; ++k) {\n      ivec3 texCoord = ivec3(neighborPosIS * volumeDimensions);\n      vec4 texValue = rawFetchTexture(texCoord);\n      if (int(texValue.g) == segmentIndex) {\n        // not on edge\n        return false;\n      }\n      neighborPosIS -= stepIS;\n    }\n\n    // onedge\n    float sampleHeight = volume.transferFunctionsSampleHeight[1];\n    vec3 tColorSegment =\n        getColorFromTexture(float(segmentIndex), 1, sampleHeight);\n    float pwfValueSegment =\n        getOpacityFromTexture(float(segmentIndex), 1, sampleHeight);\n    gl_FragData[0] = vec4(tColorSegment, pwfValueSegment);\n    return true;\n  }\n#endif\n\nvec4 getColorAtPos(vec3 posVC) {\n  vec3 posIS = posVCtoIS(posVC);\n  vec4 texValue = getTextureValue(posIS);\n  return getColorForValue(texValue, posVC, posIS);\n}\n\n//=======================================================================\n// Apply the specified blend mode operation along the ray's path.\n//\nvoid applyBlend(vec3 rayOriginVC, vec3 rayDirVC, float minDistance,\n                float maxDistance) {\n  // start slightly inside and apply some jitter\n  vec3 stepVC = rayDirVC * sampleDistance;\n  float raySteps = (maxDistance - minDistance) / sampleDistance;\n\n  // Avoid 0.0 jitter\n  float jitter = 0.01 + 0.99 * fragmentSeed;\n\n  #if vtkBlendMode == COMPOSITE_BLEND\n    // now map through opacity and color\n    vec3 firstPosVC = rayOriginVC + minDistance * rayDirVC;\n    vec4 firstColor = getColorAtPos(firstPosVC);\n\n    // handle very thin volumes\n    if (raySteps <= 1.0) {\n      firstColor.a = 1.0 - pow(1.0 - firstColor.a, raySteps);\n      gl_FragData[0] = firstColor;\n      return;\n    }\n\n    // first color only counts for `jitter` factor of the step\n    firstColor.a = 1.0 - pow(1.0 - firstColor.a, jitter);\n    vec4 color = vec4(firstColor.rgb * firstColor.a, firstColor.a);\n    vec3 posVC = firstPosVC + jitter * stepVC;\n    float stepsTraveled = jitter;\n\n    for (int i = 0; i < vtkMaximumNumberOfSamples; ++i) {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) {\n        break;\n      }\n      vec4 tColor = getColorAtPos(posVC);\n\n      color = color + vec4(tColor.rgb * tColor.a, tColor.a) * (1.0 - color.a);\n      stepsTraveled++;\n      posVC += stepVC;\n      if (color.a > 0.99) {\n        color.a = 1.0;\n        break;\n      }\n    }\n\n    if (color.a < 0.99 && (raySteps - stepsTraveled) > 0.0) {\n      vec3 endPosVC = rayOriginVC + maxDistance * rayDirVC;\n      vec4 tColor = getColorAtPos(endPosVC);\n      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps - stepsTraveled);\n\n      float mix = (1.0 - color.a);\n      color = color + vec4(tColor.rgb * tColor.a, tColor.a) * mix;\n    }\n\n    gl_FragData[0] = vec4(color.rgb / color.a, color.a);\n  #endif\n\n  #if vtkBlendMode == MAXIMUM_INTENSITY_BLEND ||                                 \\\n      vtkBlendMode == MINIMUM_INTENSITY_BLEND\n    // Find maximum/minimum intensity along the ray.\n\n    // Define the operation we will use (min or max)\n    #if vtkBlendMode == MAXIMUM_INTENSITY_BLEND\n      #define OP max\n    #else\n      #define OP min\n    #endif\n\n    vec3 posVC = rayOriginVC + minDistance * rayDirVC;\n    float stepsTraveled = 0.0;\n\n    // Find a value to initialize the selected variables\n    vec4 selectedValue;\n    vec3 selectedPosVC;\n    vec3 selectedPosIS;\n    {\n      vec3 posIS = posVCtoIS(posVC);\n      selectedValue = getTextureValue(posIS);\n      selectedPosVC = posVC;\n      selectedPosIS = posIS;\n    }\n\n    // If the clipping range is shorter than the sample distance\n    // we can skip the sampling loop along the ray.\n    if (raySteps <= 1.0) {\n      gl_FragData[0] = getColorForValue(selectedValue, selectedPosVC, selectedPosIS);\n      return;\n    }\n\n    posVC += jitter * stepVC;\n    stepsTraveled += jitter;\n\n    // Sample along the ray until vtkMaximumNumberOfSamples,\n    // ending slightly inside the total distance\n    for (int i = 0; i < vtkMaximumNumberOfSamples; ++i) {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) {\n        break;\n      }\n\n      // Get selected values\n      vec3 posIS = posVCtoIS(posVC);\n      vec4 previousSelectedValue = selectedValue;\n      vec4 currentValue = getTextureValue(posIS);\n      selectedValue = OP(selectedValue, currentValue);\n      if (previousSelectedValue != selectedValue) {\n        selectedPosVC = posVC;\n        selectedPosIS = posIS;\n      }\n\n      // Otherwise, continue along the ray\n      stepsTraveled++;\n      posVC += stepVC;\n    }\n\n    // Perform the last step along the ray using the\n    // residual distance\n    posVC = rayOriginVC + maxDistance * rayDirVC;\n    {\n      vec3 posIS = posVCtoIS(posVC);\n      vec4 previousSelectedValue = selectedValue;\n      vec4 currentValue = getTextureValue(posIS);\n      selectedValue = OP(selectedValue, currentValue);\n      if (previousSelectedValue != selectedValue) {\n        selectedPosVC = posVC;\n        selectedPosIS = posIS;\n      }\n    }\n\n    gl_FragData[0] = getColorForValue(selectedValue, selectedPosVC, selectedPosIS);\n  #endif\n\n  #if vtkBlendMode == ADDITIVE_INTENSITY_BLEND ||                                \\\n      vtkBlendMode == AVERAGE_INTENSITY_BLEND\n    vec4 sum = vec4(0.);\n    #if vtkBlendMode == AVERAGE_INTENSITY_BLEND\n      float totalWeight = 0.0;\n    #endif\n    vec3 posVC = rayOriginVC + minDistance * rayDirVC;\n    float stepsTraveled = 0.0;\n\n    vec3 posIS = posVCtoIS(posVC);\n    vec4 value = getTextureValue(posIS);\n\n    if (raySteps <= 1.0) {\n      gl_FragData[0] = getColorForValue(value * raySteps, posVC, posIS);\n      return;\n    }\n\n    if (valueWithinScalarRange(value)) {\n      sum += value * jitter;\n      #if vtkBlendMode == AVERAGE_INTENSITY_BLEND\n        totalWeight += jitter;\n      #endif\n    }\n    posVC += jitter * stepVC;\n    stepsTraveled += jitter;\n\n    // Sample along the ray until vtkMaximumNumberOfSamples,\n    // ending slightly inside the total distance\n    for (int i = 0; i < vtkMaximumNumberOfSamples; ++i) {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) {\n        break;\n      }\n\n      posIS = posVCtoIS(posVC);\n      value = getTextureValue(posIS);\n      // One can control the scalar range by setting the AverageIPScalarRange to\n      // disregard scalar values, not in the range of interest, from the average\n      // computation. Notes:\n      // - We are comparing all values in the texture to see if any of them\n      //   are outside of the scalar range. In the future we might want to allow\n      //   scalar ranges for each component.\n      if (valueWithinScalarRange(value)) {\n        sum += value;\n        #if vtkBlendMode == AVERAGE_INTENSITY_BLEND\n          totalWeight++;\n        #endif\n      }\n\n      stepsTraveled++;\n      posVC += stepVC;\n    }\n\n    // Perform the last step along the ray using the\n    // residual distance\n    posVC = rayOriginVC + maxDistance * rayDirVC;\n    posIS = posVCtoIS(posVC);\n    value = getTextureValue(posIS);\n    if (valueWithinScalarRange(value)) {\n      sum += value;\n      #if vtkBlendMode == AVERAGE_INTENSITY_BLEND\n        totalWeight += raySteps - stepsTraveled;\n      #endif\n    }\n\n    #if vtkBlendMode == AVERAGE_INTENSITY_BLEND\n      sum /= vec4(totalWeight, totalWeight, totalWeight, 1.0);\n    #endif\n\n    gl_FragData[0] = getColorForValue(sum, posVC, posIS);\n  #endif\n\n  #if vtkBlendMode == RADON_TRANSFORM_BLEND\n    float normalizedRayIntensity = 1.0;\n    vec3 posVC = rayOriginVC + minDistance * rayDirVC;\n    float stepsTraveled = 0.0;\n\n    // handle very thin volumes\n    if (raySteps <= 1.0) {\n      vec3 posIS = posVCtoIS(posVC);\n      vec4 tValue = getTextureValue(posIS);\n      normalizedRayIntensity -= raySteps * sampleDistance *\n                                getOpacityFromTexture(tValue.r, 0, 0.5);\n      gl_FragData[0] =\n          vec4(getColorFromTexture(normalizedRayIntensity, 0, 0.5), 1.0);\n      return;\n    }\n\n    posVC += jitter * stepVC;\n    stepsTraveled += jitter;\n\n    for (int i = 0; i < vtkMaximumNumberOfSamples; ++i) {\n      if (stepsTraveled + 1.0 >= raySteps) {\n        break;\n      }\n\n      vec3 posIS = posVCtoIS(posVC);\n      vec4 value = getTextureValue(posIS);\n      // Convert scalar value to normalizedRayIntensity coefficient and\n      // accumulate normalizedRayIntensity\n      normalizedRayIntensity -=\n          sampleDistance * getOpacityFromTexture(value.r, 0, 0.5);\n\n      posVC += stepVC;\n      stepsTraveled++;\n    }\n\n    // map normalizedRayIntensity to color\n    gl_FragData[0] =\n        vec4(getColorFromTexture(normalizedRayIntensity, 0, 0.5), 1.0);\n  #endif\n\n  #if vtkBlendMode == LABELMAP_EDGE_PROJECTION_BLEND\n    // Only works with a single volume\n    vec3 posVC = rayOriginVC + minDistance * rayDirVC;\n    float stepsTraveled = 0.0;\n    vec3 posIS = posVCtoIS(posVC);\n    vec4 tValue = getTextureValue(posIS);\n    if (raySteps <= 1.0) {\n      gl_FragData[0] = getColorForValue(tValue, posVC, posIS);\n      return;\n    }\n\n    vec3 stepIS = vecVCToIS(stepVC);\n    vec4 value = tValue;\n    posIS += jitter * stepIS;\n    stepsTraveled += jitter;\n    vec3 maxPosIS = posIS; // Store the position of the max value\n    int segmentIndex = int(value.g);\n    bool originalPosHasSeenNonZero = false;\n\n    if (segmentIndex != 0) {\n      // Tried using the segment index in an boolean array but reading\n      // from the array by dynamic indexing was horrondously slow\n      // so use bit masking instead and assign 1 to the bit corresponding to the\n      // segment index and later check if the bit is set via bit operations\n      setLabelOutlineBit(segmentIndex);\n    }\n\n    // Sample along the ray until vtkMaximumNumberOfSamples,\n    // ending slightly inside the total distance\n    for (int i = 0; i < vtkMaximumNumberOfSamples; ++i) {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) {\n        break;\n      }\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n      segmentIndex = int(tValue.g);\n\n      if (segmentIndex != 0) {\n        originalPosHasSeenNonZero = true;\n        setLabelOutlineBit(segmentIndex);\n      }\n\n      if (tValue.r > value.r) {\n        value = tValue;   // Update the max value\n        maxPosIS = posIS; // Update the position where max occurred\n      }\n\n      // Otherwise, continue along the ray\n      stepsTraveled++;\n      posIS += stepIS;\n    }\n\n    // Perform the last step along the ray using the\n    // residual distance\n    posIS = posVCtoIS(rayOriginVC + maxDistance * rayDirVC);\n    tValue = getTextureValue(posIS);\n\n    if (tValue.r > value.r) {\n      value = tValue;   // Update the max value\n      maxPosIS = posIS; // Update the position where max occurred\n    }\n\n    // If we have not seen any non-zero segments, we can return early\n    // and grab color from the actual center value first component (image)\n    if (!originalPosHasSeenNonZero) {\n      vec3 maxPosVC = posIStoVC(maxPosIS);\n      gl_FragData[0] = getColorForValue(value, maxPosVC, maxPosIS);\n      return;\n    }\n\n    vec3 neighborRayStepsIS = stepIS;\n    float neighborRaySteps = raySteps;\n    bool shouldLookInAllNeighbors = false;\n\n    vec3 volumeSpacings = volume.spacing;\n    float minVoxelSpacing =\n        min(volumeSpacings[0], min(volumeSpacings[1], volumeSpacings[2]));\n    vec4 base =\n        vec4(gl_FragCoord.x, gl_FragCoord.y, gl_FragCoord.z, gl_FragCoord.w);\n\n    vec4 baseXPlus = vec4(gl_FragCoord.x + 1.0, gl_FragCoord.y, gl_FragCoord.z,\n                          gl_FragCoord.w);\n    vec4 baseYPlus = vec4(gl_FragCoord.x, gl_FragCoord.y + 1.0, gl_FragCoord.z,\n                          gl_FragCoord.w);\n\n    vec3 baseWorld = fragCoordToWorld(base);\n    vec3 baseXPlusWorld = fragCoordToWorld(baseXPlus);\n    vec3 baseYPlusWorld = fragCoordToWorld(baseYPlus);\n\n    float XPlusDiff = length(baseXPlusWorld - baseWorld);\n    float YPlusDiff = length(baseYPlusWorld - baseWorld);\n\n    float minFragSpacingWorld = min(XPlusDiff, YPlusDiff);\n\n    for (int s = 1; s < MAX_SEGMENT_INDEX; s++) {\n      // bail out quickly if the segment index has not\n      // been seen by the center segment\n      if (!isLabelOutlineBitSet(s)) {\n        continue;\n      }\n\n      // Use texture sampling for outlineThickness so that we can have\n      // per segment thickness\n      float textureCoordinate = float(s - 1) / 1024.0;\n      float textureValue =\n          texture2D(labelOutlineThicknessTexture, vec2(textureCoordinate, 0.5)).r;\n\n      int actualThickness = int(textureValue * 255.0);\n\n      // check the extreme points in the neighborhood since there is a better\n      // chance of finding the edge there, so that we can bail out\n      // faster if we find the edge\n      bool onEdge = checkOnEdgeForNeighbor(-actualThickness, -actualThickness, s,\n                                          stepIS) ||\n                    checkOnEdgeForNeighbor(actualThickness, actualThickness, s,\n                                          stepIS) ||\n                    checkOnEdgeForNeighbor(actualThickness, -actualThickness, s,\n                                          stepIS) ||\n                    checkOnEdgeForNeighbor(-actualThickness, +actualThickness, s,\n                                          stepIS);\n\n      if (onEdge) {\n        return;\n      }\n\n      // since the next step is computationally expensive, we need to perform\n      // some optimizations to avoid it if possible. One of the optimizations\n      // is to check the whether the minimum of the voxel spacing is greater than\n      // the 2 * the thickness of the outline segment. If that is the case\n      // then we can safely skip the next step since we can be sure that the\n      // the previous 4 checks on the extreme points would caught the entirety\n      // of the all the fragments inside. i.e., this happens when we zoom out,\n      if (minVoxelSpacing >\n          (2.0 * float(actualThickness) - 1.0) * minFragSpacingWorld) {\n        continue;\n      }\n\n      // Loop through the rest, skipping the processed extremes and the center\n      for (int i = -actualThickness; i <= actualThickness; i++) {\n        for (int j = -actualThickness; j <= actualThickness; j++) {\n          if (i == 0 && j == 0)\n            continue; // Skip the center\n          if (abs(i) == actualThickness && abs(j) == actualThickness)\n            continue; // Skip corners\n          if (checkOnEdgeForNeighbor(i, j, s, stepIS)) {\n            return;\n          }\n        }\n      }\n    }\n\n    float sampleHeight = volume.transferFunctionsSampleHeight[0];\n    vec3 tColor0 = getColorFromTexture(value.r, 0, sampleHeight);\n    float pwfValue0 = getOpacityFromTexture(value.r, 0, sampleHeight);\n    gl_FragData[0] = vec4(tColor0, pwfValue0);\n  #endif\n}\n\n//=======================================================================\n// given a\n// - ray direction (rayDir)\n// - starting point (vertexVCVSOutput)\n// - bounding planes of the volume\n// - optionally depth buffer values\n// - far clipping plane\n// compute the start/end distances of the ray we need to cast\nvec2 computeRayDistances(vec3 rayOriginVC, vec3 rayDirVC) {\n  vec2 dists = rayIntersectVolumeDistances(rayOriginVC, rayDirVC);\n\n  //VTK::ClipPlane::Impl\n\n  // do not go behind front clipping plane\n  dists.x = max(0.0, dists.x);\n\n  // do not go PAST far clipping plane\n  float farDist = -camThick / rayDirVC.z;\n  dists.y = min(farDist, dists.y);\n\n  // Do not go past the zbuffer value if set\n  // This is used for intermixing opaque geometry\n  //VTK::ZBuffer::Impl\n\n  return dists;\n}\n\nfloat getFragmentSeed() {\n  // This first noise has a diagonal pattern\n  float firstNoise =\n      fract(sin(dot(gl_FragCoord.xy, vec2(12.9898, 78.233))) * 43758.5453);\n  // This second noise is made out of blocks of CPU generated noise\n  float secondNoise = texture2D(jtexture, gl_FragCoord.xy / 32.0).r;\n  // Combine the two sources of noise in a way that the distribution is uniform\n  // in [0,1[\n  float noiseSum = firstNoise + secondNoise;\n  return noiseSum < 1.0 ? noiseSum : noiseSum - 1.0;\n}\n\nvoid main() {\n  fragmentSeed = getFragmentSeed();\n\n  if (cameraParallel == 1) {\n    // Camera is parallel, so the rayDir is just the direction of the camera.\n    rayDirVC = vec3(0.0, 0.0, -1.0);\n  } else {\n    // camera is at 0,0,0 so rayDir for perspective is just the vc coord\n    rayDirVC = normalize(vertexVCVSOutput);\n  }\n\n  vec3 rayOriginVC = vertexVCVSOutput;\n  vec2 rayStartEndDistancesVC = computeRayDistances(rayOriginVC, rayDirVC);\n  if (rayStartEndDistancesVC[1] <= rayStartEndDistancesVC[0] ||\n      rayStartEndDistancesVC[1] <= 0.0) {\n    // Volume not hit or behind the ray\n    discard;\n  }\n\n  // Perform the blending operation along the ray\n  applyBlend(rayOriginVC, rayDirVC, rayStartEndDistancesVC[0], rayStartEndDistancesVC[1]);\n}\n",e.Geometry=""},e.replaceShaderValues=(e,n,r)=>{let o=e.Fragment;o=wu.substitute(o,"//VTK::EnabledColorFunctions",`#define EnableColorForValueFunctionId${t.previousState.colorForValueFunctionId}`).result;const a=[];t.previousState.surfaceLightingEnabled&&a.push("Surface"),t.previousState.volumeLightingEnabled&&a.push("Volume"),o=wu.substitute(o,"//VTK::EnabledLightings",a.map((e=>`#define Enable${e}Lighting`))).result,t.previousState.multiTexturePerVolumeEnabled&&(o=wu.substitute(o,"//VTK::EnabledMultiTexturePerVolume","#define EnabledMultiTexturePerVolume").result),t.previousState.useIndependentComponents&&(o=wu.substitute(o,"//VTK::EnabledIndependentComponents","#define EnabledIndependentComponents").result),t.previousState.gradientOpacityEnabled&&(o=wu.substitute(o,"//VTK::EnabledGradientOpacity","#define EnabledGradientOpacity").result),o=wu.substitute(o,"//VTK::vtkProportionalComponents",t.previousState.proportionalComponents.map((e=>`#define vtkComponent${e}Proportional`)).join("\n")).result,o=wu.substitute(o,"//VTK::vtkForceNearestComponents",t.previousState.forceNearestComponents.map((e=>`#define vtkComponent${e}ForceNearest`)).join("\n")).result,t.previousState.hasZBufferTexture&&(o=wu.substitute(o,"//VTK::ZBuffer::Dec",["uniform sampler2D zBufferTexture;","uniform float vpZWidth;","uniform float vpZHeight;"]).result,o=wu.substitute(o,"//VTK::ZBuffer::Impl",["vec4 depthVec = texture2D(zBufferTexture, vec2(gl_FragCoord.x / vpZWidth, gl_FragCoord.y/vpZHeight));","float zdepth = (depthVec.r*256.0 + depthVec.g)/257.0;","zdepth = zdepth * 2.0 - 1.0;","if (cameraParallel == 0) {","zdepth = -2.0 * camFar * camNear / (zdepth*(camFar-camNear)-(camFar+camNear)) - camNear;}","else {","zdepth = (zdepth + 1.0) * 0.5 * (camFar - camNear);}\n","zdepth = -zdepth/rayDirVC.z;","dists.y = min(zdepth,dists.y);"]).result),o=wu.substitute(o,"//VTK::BlendMode",`${t.previousState.blendMode}`).result,o=wu.substitute(o,"//VTK::NumberOfLights",`${t.previousState.numberOfLights}`).result,o=wu.substitute(o,"//VTK::MaxLaoKernelSize",`${t.previousState.maxLaoKernelSize}`).result,o=wu.substitute(o,"//VTK::NumberOfComponents",`${t.previousState.numberOfComponents}`).result,o=wu.substitute(o,"//VTK::MaximumNumberOfSamples",`${t.previousState.maximumNumberOfSamples}`).result,e.Fragment=o;const i=t.previousState.numberOfClippingPlanes;i>0&&(o=wu.substitute(o,"//VTK::ClipPlane::Dec",["uniform vec3 vClipPlaneNormals[6];","uniform float vClipPlaneDistances[6];","uniform vec3 vClipPlaneOrigins[6];","uniform int clip_numPlanes;","//VTK::ClipPlane::Dec","#define vtkClippingPlanesOn"],!1).result,o=wu.substitute(o,"//VTK::ClipPlane::Impl",[`for(int i = 0; i < ${i}; i++) {`,"  float rayDirRatio = dot(rayDirVC, vClipPlaneNormals[i]);","  float equationResult = dot(vertexVCVSOutput, vClipPlaneNormals[i]) + vClipPlaneDistances[i];","  if (rayDirRatio == 0.0)","  {","    if (equationResult < 0.0) dists.x = dists.y;","    continue;","  }","  float result = -1.0 * equationResult / rayDirRatio;","  if (rayDirRatio < 0.0) dists.y = min(dists.y, result);","  else dists.x = max(dists.x, result);","}","//VTK::ClipPlane::Impl"],!1).result),e.Fragment=o},e.getNeedToRebuildShaders=(r,o,a)=>{const i=!!t.zBufferTexture,s=t.currentValidInputs.length,l=t.numberOfLights,c=t.numberOfComponents,u=t.useIndependentComponents,d=a.getProperties(),p=t.currentValidInputs[0],f=d[p.inputIndex],g=s>1,m=p.imageData.getBounds(),h=Fi.getDiagonalLength(m),v=Math.ceil(h/e.getCurrentSampleDistance(o));v>t.renderable.getMaximumSamplesPerRay()&&Pf(`The number of steps required ${v} is larger than the specified maximum number of steps ${t.renderable.getMaximumSamplesPerRay()}.\nPlease either change the volumeMapper sampleDistance or its maximum number of samples.`);const T=u?c:1;let y=!1;for(let e=0;e<T;++e)if(f.getUseGradientOpacity(e)){y=!0;break}let b=0;const x=f.getLAOKernelSize();x>b&&f.getLocalAmbientOcclusion()&&f.getAmbient()>0&&(b=x);const C=t.renderable.getClippingPlanes().length,S=t.renderable.getViewSpecificProperties().OpenGL?.ShaderReplacements,A=t.currentRenderPass?.getShaderReplacement(),I=t.renderable.getBlendMode(),w=(()=>{if(I!==wf.LABELMAP_EDGE_PROJECTION_BLEND&&n(f))return 5;if(u)switch(f.getColorMixPreset()){case Af.ADDITIVE:return 1;case Af.COLORIZE:return 2;case Af.CUSTOM:return 3;default:return 4}return 0})(),O=f.getVolumetricScatteringBlending()<1,P=f.getVolumetricScatteringBlending()>0;let R=!1;for(let e=0;e<c;++e)if(f.getForceNearestInterpolation(e)){R=!0;break}const M=[],E=[];for(let e=0;e<c;e++)f.getOpacityMode(e)===Sf.PROPORTIONAL&&M.push(e),f.getForceNearestInterpolation(e)&&E.push(e);const V={numberOfComponents:c,useIndependentComponents:u,proportionalComponents:M,forceNearestComponents:E,blendMode:I,numberOfLights:l,numberOfValidInputs:s,maximumNumberOfSamples:v,hasZBufferTexture:i,maxLaoKernelSize:b,numberOfClippingPlanes:C,mapperShaderReplacements:S,renderPassShaderReplacements:A,colorForValueFunctionId:w,surfaceLightingEnabled:O,volumeLightingEnabled:P,forceNearestInterpolationEnabled:R,multiTexturePerVolumeEnabled:g,gradientOpacityEnabled:y};return!(0!==r.getProgram()?.getHandle()&&t.previousState&&ke()(t.previousState,V)||(t.previousState=V,0))},e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o),e.getClippingPlaneShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram();n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(a.isAttributeUsed("vertexDC")&&(n.getVAO().addAttributeArray(a,n.getCABO(),"vertexDC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||Rf("Error setting vertexDC in shader VAO.")),n.getAttributeUpdateTime().modified());const i=e.getCurrentSampleDistance(r);a.setUniformf("sampleDistance",i);const s=i*t.renderable.getVolumeShadowSamplingDistFactor();a.setUniformf("volumeShadowSampleDistance",s),t.scalarTextures.forEach(((e,t)=>{a.setUniformi(`volumeTexture[${t}]`,e.getTextureUnit())}));const l=o.getProperties()[t.currentValidInputs[0].inputIndex].getIpScalarRange(),c=new Float32Array(4),u=new Float32Array(4),d=(e,t,n)=>{t?.dataComputedScale?.length&&(c[e]=l[0]*t.dataComputedScale[n]+t.dataComputedOffset[n],u[e]=l[1]*t.dataComputedScale[n]+t.dataComputedOffset[n],c[e]=(c[e]-t.offset[n])/t.scale[n],u[e]=(u[e]-t.offset[n])/t.scale[n])};if(t.previousState.multiTexturePerVolumeEnabled)t.scalarTextures.forEach(((e,t)=>{const n=e.getVolumeInfo();d(t,n,0)}));else{const e=t.scalarTextures[0].getVolumeInfo();for(let t=0;t<4;++t)d(t,e,t)}const p="volume";if(a.setUniform4f(`${p}.ipScalarRangeMin`,c[0],c[1],c[2],c[3]),a.setUniform4f(`${p}.ipScalarRangeMax`,u[0],u[1],u[2],u[3]),null!==t.zBufferTexture){a.setUniformi("zBufferTexture",t.zBufferTexture.getTextureUnit());const e=t._useSmallViewport?[t._smallViewportWidth,t._smallViewportHeight]:t._openGLRenderWindow.getFramebufferSize();a.setUniformf("vpZWidth",e[0]),a.setUniformf("vpZHeight",e[1])}},e.setCameraShaderParameters=(r,o,a)=>{const{idxToView:i,vecISToVCMatrix:s,modelToView:l,projectionToView:c,projectionToWorld:u}=Mf,d=t.openGLCamera.getKeyMatrices(o),p=t.openGLVolume.getKeyMatrices();y(l,d.wcvc,p.mcwc);const f=r.getProgram(),g=t.openGLCamera.getRenderable(),m=g.getParallelProjection(),v=g.getClippingRange();f.setUniformf("camThick",v[1]-v[0]),f.setUniformf("camNear",v[0]),f.setUniformf("camFar",v[1]),f.setUniformi("cameraParallel",m);const T=t.currentValidInputs[0],b=T.imageData.getBounds(),x=Fi.getCorners(b,[]).map((e=>(wn(e,e,l),m||xn(e,e,-v[0]/(e[2]*mn(e))),wn(e,e,d.vcpc),e))),C=Fi.addPoints([...Fi.INIT_BOUNDS],x);f.setUniformf("dcxmin",C[0]),f.setUniformf("dcxmax",C[1]),f.setUniformf("dcymin",C[2]),f.setUniformf("dcymax",C[3]);const S=e.getRenderTargetSize();f.setUniformf("vpWidth",S[0]),f.setUniformf("vpHeight",S[1]);const A=e.getRenderTargetOffset();f.setUniformf("vpOffsetX",A[0]/S[0]),f.setUniformf("vpOffsetY",A[1]/S[1]),h(c,d.vcpc),f.setUniformMatrix("PCVCMatrix",c),f.setUniformi("twoSidedLighting",o.getTwoSidedLighting());const I=new Array(2*t.previousState.maxLaoKernelSize);for(let e=0;e<t.previousState.maxLaoKernelSize;e++)I[2*e]=Math.random(),I[2*e+1]=Math.random();if(f.setUniform2fv("kernelSample",I),t.numberOfLights>0){let e=0;o.getLights().forEach((t=>{if(t.getSwitch()>0){const n=`lights[${e}]`,r=xn([],t.getColor(),t.getIntensity());f.setUniform3fv(`${n}.color`,r);const o=t.getTransformedPosition();wn(o,o,l),f.setUniform3fv(`${n}.positionVC`,o);const a=[...t.getDirection()];On(a,a,d.normalMatrix),Sn(a,a),f.setUniform3fv(`${n}.directionVC`,a);const i=[-.5*a[0],-.5*a[1],-.5*(a[2]-1)];f.setUniform3fv(`${n}.halfAngleVC`,i);const s=t.getAttenuationValues();f.setUniform3fv(`${n}.attenuation`,s);const c=t.getExponent();f.setUniformf(`${n}.exponent`,c);const u=t.getConeAngle();f.setUniformf(`${n}.coneAngle`,u);const p=t.getPositional();f.setUniformi(`${n}.isPositional`,p),e++}}))}const w="volume",O=a.getProperties()[T.inputIndex],P=T.imageData,R=P.getSpatialExtent(),M=P.getSpacing(),E=P.getDimensions(),V=P.getIndexToWorld(),D=P.getWorldToIndex(),L=P.getDirectionByReference();y(i,l,V),f.setUniform3fv(`${w}.spacing`,M);const B=Cn([],M);f.setUniform3fv(`${w}.inverseSpacing`,B),f.setUniform3iv(`${w}.dimensions`,E),f.setUniform3fv(`${w}.inverseDimensions`,Cn([],E)),f.setUniformMatrix(`${w}.worldToIndex`,D),s.fill(0);const N=bn(new Float64Array(3),E,M);s[0]=N[0],s[4]=N[1],s[8]=N[2],ve(s,L,s),ve(s,p.normalMatrix,s),ve(s,d.normalMatrix,s),f.setUniformMatrix3x3(`${w}.vecISToVCMatrix`,s),f.setUniformMatrix3x3(`${w}.vecVCToISMatrix`,ge(new Float32Array(9),s));const F=hn(R[0],R[2],R[4]),_=wn(new Float64Array(3),F,i);f.setUniform3fv(`${w}.originVC`,_);const k=mn(N);if(f.setUniformf(`${w}.diagonalLength`,k),n(O)){const e=g.getDistance();g.setClippingRange(e,e+.1),h(u,t.openGLCamera.getKeyMatrices(o).wcpc),g.setClippingRange(v[0],v[1]),t.openGLCamera.getKeyMatrices(o),f.setUniformMatrix(`${w}.PCWCMatrix`,u)}if(O.getVolumetricScatteringBlending()>0&&(f.setUniformf(`${w}.globalIlluminationReach`,O.getGlobalIlluminationReach()),f.setUniformf(`${w}.volumetricScatteringBlending`,O.getVolumetricScatteringBlending()),f.setUniformf(`${w}.anisotropy`,O.getAnisotropy()),f.setUniformf(`${w}.anisotropySquared`,O.getAnisotropy()**2)),O.getLocalAmbientOcclusion()&&O.getAmbient()>0){const e=O.getLAOKernelSize();f.setUniformi(`${w}.kernelSize`,e);const t=O.getLAOKernelRadius();f.setUniformi(`${w}.kernelRadius`,t)}else f.setUniformi(`${w}.kernelSize`,0)},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram();o.setUniformi("jtexture",t.jitterTexture.getTextureUnit());const a=r.getProperties();o.setUniformi("labelOutlineThicknessTexture",t.labelOutlineThicknessTexture.getTextureUnit()),o.setUniformi("opacityTexture",t.opacityTexture.getTextureUnit()),o.setUniformi("colorTexture",t.colorTexture.getTextureUnit());const i="volume",s=a[t.currentValidInputs[0].inputIndex],l=t.previousState.numberOfComponents,c=t.previousState.useIndependentComponents;if(c){const e=new Float32Array(4);for(let t=0;t<l;t++)e[t]=s.getComponentWeight(t);o.setUniform4fv(`${i}.independentComponentMix`,e);const t=new Float32Array(4),n=1/l;for(let e=0;e<l;++e)t[e]=(e+.5)*n;o.setUniform4fv(`${i}.transferFunctionsSampleHeight`,t)}const u=t.colorForValueFunctionId;o.setUniformi(`${i}.colorForValueFunctionId`,u);const d=s.getComputeNormalFromOpacity();o.setUniformi(`${i}.computeNormalFromOpacity`,d);const p=new Float32Array(4),f=new Float32Array(4),g=new Float32Array(4),m=new Float32Array(4);for(let e=0;e<l;e++){const n=t.previousState.multiTexturePerVolumeEnabled,r=n?e:0,o=n?0:e,a=t.scalarTextures[r].getVolumeInfo(),i=c?e:0,l=a.scale[o],u=s.getRGBTransferFunction(i).getRange();p[e]=l/(u[1]-u[0]),f[e]=(a.offset[o]-u[0])/(u[1]-u[0]);const d=s.getScalarOpacity(i).getRange();g[e]=l/(d[1]-d[0]),m[e]=(a.offset[o]-d[0])/(d[1]-d[0])}if(o.setUniform4fv(`${i}.colorTextureScale`,p),o.setUniform4fv(`${i}.colorTextureShift`,f),o.setUniform4fv(`${i}.opacityTextureScale`,g),o.setUniform4fv(`${i}.opacityTextureShift`,m),t.previousState.gradientOpacityEnabled){const e=new Array(4),n=new Array(4),r=new Array(4),a=new Array(4);if(c)for(let o=0;o<l;++o){const i=t.previousState.multiTexturePerVolumeEnabled,l=i?o:0,c=i?0:o,u=t.scalarTextures[l].getVolumeInfo().scale[c];if(s.getUseGradientOpacity(o)){const t=[s.getGradientOpacityMinimumOpacity(o),s.getGradientOpacityMaximumOpacity(o)],i=[s.getGradientOpacityMinimumValue(o),s.getGradientOpacityMaximumValue(o)];r[o]=t[0],a[o]=t[1],e[o]=u*(t[1]-t[0])/(i[1]-i[0]),n[o]=-i[0]*(t[1]-t[0])/(i[1]-i[0])+t[0]}else r[o]=1,a[o]=1,e[o]=0,n[o]=1}else{const o=l-1,i=t.previousState.multiTexturePerVolumeEnabled,c=i?o:0,u=i?0:o,d=t.scalarTextures[c].getVolumeInfo().scale[u],p=[s.getGradientOpacityMinimumOpacity(0),s.getGradientOpacityMaximumOpacity(0)],f=[s.getGradientOpacityMinimumValue(0),s.getGradientOpacityMaximumValue(0)];r[0]=p[0],a[0]=p[1],e[0]=d*(p[1]-p[0])/(f[1]-f[0]),n[0]=-f[0]*(p[1]-p[0])/(f[1]-f[0])+p[0]}o.setUniform4f(`${i}.gradientOpacityScale`,e),o.setUniform4f(`${i}.gradientOpacityShift`,n),o.setUniform4f(`${i}.gradientOpacityMin`,r),o.setUniform4f(`${i}.gradientOpacityMax`,a)}const h=s.getLabelOutlineOpacity();if(o.setUniformf(`${i}.outlineOpacity`,h),t.numberOfLights>0){o.setUniformf(`${i}.ambient`,s.getAmbient()),o.setUniformf(`${i}.diffuse`,s.getDiffuse()),o.setUniformf(`${i}.specular`,s.getSpecular());const e=s.getSpecularPower();o.setUniformf(`${i}.specularPower`,0===e?1:e)}},e.getClippingPlaneShaderParameters=(e,n,r)=>{if(t.renderable.getClippingPlanes().length>0){const r=t.openGLCamera.getKeyMatrices(n),o=[],a=[],i=[],s=t.renderable.getClippingPlanes(),l=s.length;for(let e=0;e<l;++e){const t=s[e].getNormal(),n=s[e].getOrigin();On(t,t,r.normalMatrix),wn(n,n,r.wcvc);const l=-1*An(n,t);o.push(t[0]),o.push(t[1]),o.push(t[2]),a.push(l),i.push(n[0]),i.push(n[1]),i.push(n[2])}const c=e.getProgram();c.setUniform3fv("vClipPlaneNormals",o),c.setUniformfv("vClipPlaneDistances",a),c.setUniform3fv("vClipPlaneOrigins",i),c.setUniformi("clip_numPlanes",l)}},e.delete=Vt((()=>{t._animationRateSubscription&&(t._animationRateSubscription.unsubscribe(),t._animationRateSubscription=null)}),(()=>{t._openGLRenderWindow&&a(t._openGLRenderWindow)}),e.delete),e.getRenderTargetSize=()=>{if(t._useSmallViewport)return[t._smallViewportWidth,t._smallViewportHeight];const{usize:e,vsize:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getRenderTargetOffset=()=>{const{lowerLeftU:e,lowerLeftV:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getCurrentSampleDistance=e=>{const n=e.getVTKWindow().getInteractor(),r=t.renderable.getSampleDistance();return n.isAnimating()?r*t.renderable.getInteractionSampleDistanceFactor():r},e.renderPieceStart=(n,r)=>{const o=n.getVTKWindow().getInteractor();if(t._lastScale||(t._lastScale=t.renderable.getInitialInteractionScale()),t._useSmallViewport=!1,o.isAnimating()&&t._lastScale>1.5&&(t._useSmallViewport=!0),t._animationRateSubscription||(t._animationRateSubscription=o.onAnimationFrameRateUpdate((()=>{if(t.renderable.getAutoAdjustSampleDistances()){const e=o.getRecentAnimationFrameRate(),n=o.getDesiredUpdateRate()/e;(n>1.15||n<.85)&&(t._lastScale*=n),t._lastScale>400&&(t._lastScale=400),t._lastScale<1.5&&(t._lastScale=1.5)}else t._lastScale=t.renderable.getImageSampleDistance()*t.renderable.getImageSampleDistance()}))),t._useSmallViewport){const e=t._openGLRenderWindow.getFramebufferSize(),n=1/Math.sqrt(t._lastScale);if(t._smallViewportWidth=Math.ceil(n*e[0]),t._smallViewportHeight=Math.ceil(n*e[1]),t._smallViewportHeight>e[1]&&(t._smallViewportHeight=e[1]),t._smallViewportWidth>e[0]&&(t._smallViewportWidth=e[0]),t.framebuffer.saveCurrentBindingsAndBuffers(),null===t.framebuffer.getGLFramebuffer())t.framebuffer.create(e[0],e[1]),t.framebuffer.populateFramebuffer();else{const n=t.framebuffer.getSize();n&&n[0]===e[0]&&n[1]===e[1]||(t.framebuffer.create(e[0],e[1]),t.framebuffer.populateFramebuffer())}t.framebuffer.bind();const r=t.context;r.clearColor(0,0,0,0),r.colorMask(!0,!0,!0,!0),r.clear(r.COLOR_BUFFER_BIT),r.viewport(0,0,t._smallViewportWidth,t._smallViewportHeight),t.fvp=[t._smallViewportWidth/e[0],t._smallViewportHeight/e[1]]}t.context.disable(t.context.DEPTH_TEST),e.updateBufferObjects(n,r);const a=r.getProperties();t.currentValidInputs.forEach((e=>{let{inputIndex:n}=e;const r=a[n].getInterpolationType(),o=t.scalarTextures[n];r===Cf.NEAREST?(o.setMinificationFilter(Bu.NEAREST),o.setMagnificationFilter(Bu.NEAREST)):(o.setMinificationFilter(Bu.LINEAR),o.setMagnificationFilter(Bu.LINEAR))})),null!==t.zBufferTexture&&t.zBufferTexture.activate()},e.renderPieceDraw=(n,r)=>{const o=t.context,a=[...t.scalarTextures,t.colorTexture,t.opacityTexture,t.labelOutlineThicknessTexture,t.jitterTexture];a.forEach((e=>e.activate())),e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),a.forEach((e=>e.deactivate()))},e.renderPieceFinish=(e,n)=>{if(null!==t.zBufferTexture&&t.zBufferTexture.deactivate(),t._useSmallViewport){if(t.framebuffer.restorePreviousBindingsAndBuffers(),null===t.copyShader){t.copyShader=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(["//VTK::System::Dec","attribute vec4 vertexDC;","uniform vec2 tfactor;","varying vec2 tcoord;","void main() { tcoord = vec2(vertexDC.x*0.5 + 0.5, vertexDC.y*0.5 + 0.5) * tfactor; gl_Position = vertexDC; }"].join("\n"),["//VTK::System::Dec","//VTK::Output::Dec","uniform sampler2D texture1;","varying vec2 tcoord;","void main() { gl_FragData[0] = texture2D(texture1,tcoord); }"].join("\n"),"");const e=t.copyShader;t.copyVAO=Ru.newInstance(),t.copyVAO.setOpenGLRenderWindow(t._openGLRenderWindow),t.tris.getCABO().bind(),t.copyVAO.addAttributeArray(e,t.tris.getCABO(),"vertexDC",t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||Rf("Error setting vertexDC in copy shader VAO.")}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(t.copyShader);const e=t._openGLRenderWindow.getFramebufferSize();t.context.viewport(0,0,e[0],e[1]);const n=t.framebuffer.getColorTexture();n.activate(),t.copyShader.setUniformi("texture",n.getTextureUnit()),t.copyShader.setUniform2f("tfactor",t.fvp[0],t.fvp[1]);const r=t.context;r.blendFuncSeparate(r.ONE,r.ONE_MINUS_SRC_ALPHA,r.ONE,r.ONE_MINUS_SRC_ALPHA),t.context.drawArrays(t.context.TRIANGLES,0,t.tris.getCABO().getElementCount()),n.deactivate(),r.blendFuncSeparate(r.SRC_ALPHA,r.ONE_MINUS_SRC_ALPHA,r.ONE,r.ONE_MINUS_SRC_ALPHA)}},e.renderPiece=(n,r)=>{e.invokeEvent({type:"StartEvent"}),t.renderable.update();const o=t.renderable.getNumberOfInputPorts();t.currentValidInputs=[];for(let e=0;e<o;++e){const n=t.renderable.getInputData(e);n&&!n.isDeleted()&&t.currentValidInputs.push({imageData:n,inputIndex:e})}const a=r.getProperties(),i=t.currentValidInputs[0],s=i.imageData.getPointData().getScalars(),l=a[i.inputIndex];let c=0;if(l.getShade()&&t.renderable.getBlendMode()===wf.COMPOSITE_BLEND&&n.getLights().forEach((e=>{e.getSwitch()>0&&c++})),c!==t.numberOfLights&&(t.numberOfLights=c,e.modified()),e.invokeEvent({type:"EndEvent"}),0===t.currentValidInputs.length)return;const u=t.currentValidInputs.length,d=u>1;t.numberOfComponents=d?u:s.getNumberOfComponents(),t.useIndependentComponents=function(e,t){const n=e.getIndependentComponents(),r=e.getColorMixPreset();return n&&t>=2||!!r}(l,t.numberOfComponents),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty(t.currentValidInputs[0].inputIndex)?.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.currentValidInputs.some((e=>{let{imageData:n}=e;return t.VBOBuildTime.getMTime()<n.getMTime()}))||t.scalarTextures.length!==t.currentValidInputs.length||!t.scalarTextures.every((e=>!!e?.getHandle()))||!t.colorTexture?.getHandle()||!t.opacityTexture?.getHandle()||!t.labelOutlineThicknessTexture?.getHandle()||!t.jitterTexture?.getHandle(),e.buildBufferObjects=(n,r)=>{if(!t.jitterTexture.getHandle()){const e=new Float32Array(1024);for(let t=0;t<1024;++t)e[t]=Math.random();t.jitterTexture.setMinificationFilter(Bu.NEAREST),t.jitterTexture.setMagnificationFilter(Bu.NEAREST),t.jitterTexture.create2DFromRaw({width:32,height:32,numComps:1,dataType:is.FLOAT,data:e})}const a=r.getProperties(),i=t.currentValidInputs[0],s=a[i.inputIndex],l=t.numberOfComponents,c=t.useIndependentComponents,u=c?l:1,d=[];for(let e=0;e<u;++e)d.push(s.getScalarOpacity(e));const p=Zp(d,c,u),f=s.getScalarOpacity(),g=t._openGLRenderWindow.getGraphicsResourceForObject(f);if(g?.oglObject?.getHandle()&&g.hash===p)t.opacityTexture=g.oglObject;else{const r=Ju.newInstance();r.setOpenGLRenderWindow(t._openGLRenderWindow);let o=t.renderable.getOpacityTextureWidth();o<=0&&(o=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const a=2*o*u,i=new Float32Array(a),l=new Float32Array(o);for(let t=0;t<u;++t){const r=s.getScalarOpacity(t),a=e.getCurrentSampleDistance(n)/s.getScalarOpacityUnitDistance(t),c=r.getRange();r.getTable(c[0],c[1],o,l,1);for(let e=0;e<o;++e)i[t*o*2+e]=1-(1-l[e])**a,i[t*o*2+e+o]=i[t*o*2+e]}if(r.resetFormatAndType(),r.setMinificationFilter(Bu.LINEAR),r.setMagnificationFilter(Bu.LINEAR),t._openGLRenderWindow.getWebgl2()||t.context.getExtension("OES_texture_float")&&t.context.getExtension("OES_texture_float_linear"))r.create2DFromRaw({width:o,height:2*u,numComps:1,dataType:is.FLOAT,data:i});else{const e=new Uint8ClampedArray(a);for(let t=0;t<a;++t)e[t]=255*i[t];r.create2DFromRaw({width:o,height:2*u,numComps:1,dataType:is.UNSIGNED_CHAR,data:e})}f&&t._openGLRenderWindow.setGraphicsResourceForObject(f,r,p),t.opacityTexture=r}o(t._openGLRenderWindow,t._opacityTextureCore,f),t._opacityTextureCore=f;const m=[];for(let e=0;e<u;++e)m.push(s.getRGBTransferFunction(e));const h=Zp(m,c,u),v=s.getRGBTransferFunction(),T=t._openGLRenderWindow.getGraphicsResourceForObject(v);if(T?.oglObject?.getHandle()&&T?.hash===h)t.colorTexture=T.oglObject;else{const e=Ju.newInstance();e.setOpenGLRenderWindow(t._openGLRenderWindow);let n=t.renderable.getColorTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const r=new Uint8ClampedArray(2*n*u*3),o=new Float32Array(3*n);for(let e=0;e<u;++e){const t=s.getRGBTransferFunction(e),a=t.getRange();t.getTable(a[0],a[1],n,o,1);for(let t=0;t<3*n;++t)r[e*n*6+t]=255*o[t],r[e*n*6+t+3*n]=255*o[t]}e.resetFormatAndType(),e.setMinificationFilter(Bu.LINEAR),e.setMagnificationFilter(Bu.LINEAR),e.create2DFromRaw({width:n,height:2*u,numComps:3,dataType:is.UNSIGNED_CHAR,data:r}),t._openGLRenderWindow.setGraphicsResourceForObject(v,e,h),t.colorTexture=e}o(t._openGLRenderWindow,t._colorTextureCore,v),t._colorTextureCore=v,t.currentValidInputs.forEach(((e,n)=>{let{imageData:r,inputIndex:i}=e;const s=a[i],l=r.getPointData().getScalars(),c=t._openGLRenderWindow.getGraphicsResourceForObject(l),u=Qp(0,l),d=!c?.oglObject?.getHandle()||c?.hash!==u,p=s.getUpdatedExtents(),f=!!p.length;if(d&&!f){const e=Ju.newInstance();e.setOpenGLRenderWindow(t._openGLRenderWindow);const o=r.getDimensions();e.setOglNorm16Ext(t.context.getExtension("EXT_texture_norm16")),e.resetFormatAndType(),e.create3DFilterableFromDataArray({width:o[0],height:o[1],depth:o[2],dataArray:l,preferSizeOverAccuracy:s.getPreferSizeOverAccuracy()}),t._openGLRenderWindow.setGraphicsResourceForObject(l,e,u),t.scalarTextures[n]=e}else t.scalarTextures[n]=c.oglObject;if(f){s.setUpdatedExtents([]);const e=r.getDimensions();t.scalarTextures[n].create3DFilterableFromDataArray({width:e[0],height:e[1],depth:e[2],dataArray:l,updatedExtents:p})}o(t._openGLRenderWindow,t._scalarTexturesCore[n],l),t._scalarTexturesCore[n]=l}));const y=s.getLabelOutlineThickness(),b=t._openGLRenderWindow.getGraphicsResourceForObject(y),x=y.join("-");if(b?.oglObject?.getHandle()&&b?.hash===x)t.labelOutlineThicknessTexture=b.oglObject;else{const e=Ju.newInstance();e.setOpenGLRenderWindow(t._openGLRenderWindow);let n=t.renderable.getLabelOutlineTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const r=1,o=new Uint8Array(n*r);for(let e=0;e<n;++e){const t=void 0!==y[e]?y[e]:y[0];o[e]=t}e.resetFormatAndType(),e.setMinificationFilter(Bu.NEAREST),e.setMagnificationFilter(Bu.NEAREST),e.create2DFromRaw({width:n,height:r,numComps:1,dataType:is.UNSIGNED_CHAR,data:o}),y&&t._openGLRenderWindow.setGraphicsResourceForObject(y,e,x),t.labelOutlineThicknessTexture=e}if(o(t._openGLRenderWindow,t._labelOutlineThicknessTextureCore,y),t._labelOutlineThicknessTextureCore=y,!t.tris.getCABO().getElementCount()){const e=new Float32Array(12);for(let t=0;t<4;t++)e[3*t]=t%2*2-1,e[3*t+1]=t>1?1:-1,e[3*t+2]=-1;const n=new Uint16Array(8);n[0]=3,n[1]=0,n[2]=1,n[3]=3,n[4]=3,n[5]=0,n[6]=3,n[7]=2;const r=Ts.newInstance({numberOfComponents:3,values:e});r.setName("points");const o=Ts.newInstance({numberOfComponents:1,values:n});t.tris.getCABO().createVBO(o,"polys",qi.SURFACE,{points:r,cellOffset:0})}t.VBOBuildTime.modified()}}(e,t)}),"vtkOpenGLVolumeMapper");en("vtkVolumeMapper",Vf);const{vtkDebugMacro:Df}=jt,Lf={};const Bf=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Lf,n),Xt.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkOpenGLPixelSpaceCallbackMapper"),e.opaquePass=(n,r)=>{t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow");const o=t._openGLRenderer.getAspectRatio(),a=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,i=t._openGLRenderer.getTiledSizeAndOrigin();let s=null;if(t.renderable.getUseZValues()){const e=r.getZBufferTexture(),n=Math.floor(e.getWidth()),o=Math.floor(e.getHeight()),a=t._openGLRenderWindow.getContext();e.bind();const i=r.getFramebuffer();i?i.saveCurrentBindingsAndBuffers():Df("No framebuffer to save/restore");const l=a.createFramebuffer();a.bindFramebuffer(a.FRAMEBUFFER,l),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,e.getHandle(),0),a.checkFramebufferStatus(a.FRAMEBUFFER)===a.FRAMEBUFFER_COMPLETE&&(s=new Uint8Array(n*o*4),a.viewport(0,0,n,o),a.readPixels(0,0,n,o,a.RGBA,a.UNSIGNED_BYTE,s)),i&&i.restorePreviousBindingsAndBuffers(),a.deleteFramebuffer(l)}t.renderable.invokeCallback(t.renderable.getInputData(),a,o,i,s)},e.queryPass=(e,n)=>{e&&t.renderable.getUseZValues()&&n.requestDepth()}}(e,t)}),"vtkOpenGLPixelSpaceCallbackMapper");en("vtkPixelSpaceCallbackMapper",Bf);var Nf="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtktextureObjectVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexDC;\nattribute vec2 tcoordDC;\nvarying vec2 tcoordVC;\n\nvoid main()\n{\n  tcoordVC = tcoordDC;\n  gl_Position = vertexDC;\n}\n";const{Representation:Ff}=ts;function _f(e,t,n,r){let[o,a]=t;const i=e.getContext(),s=Ju.newInstance({autoParameters:!1,wrapS:r,wrapT:r,minificationFilter:n,magnificationFilter:n,generateMipmap:!1,openGLDataType:i.FLOAT,baseLevel:0,maxLevel:0});return s.setOpenGLRenderWindow(e),s.setInternalFormat(i.RGBA32F),s.create2DFromRaw({width:o,height:a,numComps:4,dataType:"Float32Array",data:null}),s.activate(),s.sendParameters(),s.deactivate(),s}function kf(e,t){return _f(e,t,Ju.Filter.NEAREST,Ju.Wrap.CLAMP_TO_EDGE)}const Gf={vectorTexture:null,maskVectorTexture:null,noiseTexture:null,doEEPass:!1,doVTPass:!1,readIndex:0,quad:null,lastProgramHash:null,framebuffer:null,size:null,pingTextures:[],pongTextures:[],textures:[]};function Uf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Gf,n),Ht.obj(e,t),Ht.get(e,t,["readIndex"]),Ht.setGet(e,t,["doEEPass","doVTPass","_openGLRenderWindow","vectorTexture","maskVectorTexture","noiseTexture","framebuffer","size"]),Ht.moveToProtected(e,t,["openGLRenderWindow"]),function(e,t){t.classHierarchy.push("vtkLICPingPongBufferManager"),t._openGLRenderWindow?(t.quad=function(e){const t=Du.newInstance();t.setOpenGLRenderWindow(e);const n=new Float32Array(12);for(let e=0;e<4;e++)n[3*e]=e%2*2-1,n[3*e+1]=e>1?1:-1,n[3*e+2]=0;const r=new Float32Array([0,0,1,0,0,1,1,1]),o=new Uint16Array(8);o[0]=3,o[1]=0,o[2]=1,o[3]=3,o[4]=3,o[5]=0,o[6]=3,o[7]=2;const a=Ts.newInstance({numberOfComponents:3,values:n});a.setName("points");const i=Ts.newInstance({numberOfComponents:1,values:o}),s=Ts.newInstance({numberOfComponents:2,values:r});return t.getCABO().createVBO(i,"polys",Ff.SURFACE,{points:a,cellOffset:0,tcoords:s}),t}(t._openGLRenderWindow),t.context=t._openGLRenderWindow.getContext(),t.licTexture0=kf(t._openGLRenderWindow,t.size),t.seedTexture0=kf(t._openGLRenderWindow,t.size),t.licTexture1=kf(t._openGLRenderWindow,t.size),t.seedTexture1=kf(t._openGLRenderWindow,t.size),t.eeTexture=t.doEEPass?_f(t._openGLRenderWindow,t.size,Ju.Filter.NEAREST,Ju.Wrap.CLAMP_TO_EDGE):null,t.imageVectorTexture=t.doVTPass?(n=t._openGLRenderWindow,r=t.size,_f(n,r,Ju.Filter.LINEAR,Ju.Wrap.CLAMP_TO_EDGE)):null,t.pingTextures[0]=t.licTexture0,t.pingTextures[1]=t.seedTexture0,t.pongTextures[0]=t.licTexture1,t.pongTextures[1]=t.seedTexture1,t.textures[0]=t.pingTextures,t.textures[1]=t.pongTextures,e.swap=()=>{t.readIndex=1-t.readIndex},e.renderQuad=(e,n)=>{const r=t.quad,o=t.context;let a=t.quadVAO;a||(a=Ru.newInstance(),a.setOpenGLRenderWindow(t._openGLRenderWindow),t.quadVAO=a),t.previousProgramHash!==n.getMd5Hash()&&(a.shaderProgramChanged(),r.getCABO().bind(),a.addAttributeArray(n,r.getCABO(),"vertexDC",r.getCABO().getVertexOffset(),r.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE),a.addAttributeArray(n,r.getCABO(),"tcoordDC",r.getCABO().getTCoordOffset(),r.getCABO().getStride(),t.context.FLOAT,2,t.context.FALSE),t.previousProgramHash=n.getMd5Hash()),o.drawArrays(o.TRIANGLES,0,r.getCABO().getElementCount()),a.release()},e.getLastLICBuffer=()=>0===t.readIndex?t.licTexture0:t.licTexture1,e.getLastSeedBuffer=()=>0===t.readIndex?t.seedTexture0:t.seedTexture1,e.getLICBuffer=()=>1-t.readIndex==0?t.licTexture0:t.licTexture1,e.getSeedBuffer=()=>1-t.readIndex==0?t.seedTexture0:t.seedTexture1,e.getLICTextureUnit=()=>{const e=t.textures[t.readIndex][0];return e.activate(),e.getTextureUnit()},e.getSeedTextureUnit=()=>{const e=t.textures[t.readIndex][1];return e.activate(),e.getTextureUnit()},e.getNoiseTextureUnit=function(){return 0===(arguments.length>0&&void 0!==arguments[0]?arguments[0]:0)?(t.noiseTexture.activate(),t.noiseTexture.getTextureUnit()):(t.eeTexture.activate(),t.eeTexture.getTextureUnit())},e.getVectorTextureUnit=()=>(t.vectorTexture.activate(),t.vectorTexture.getTextureUnit()),e.getImageVectorTextureUnit=()=>t.imageVectorTexture?(t.imageVectorTexture.activate(),t.imageVectorTexture.getTextureUnit()):e.getVectorTextureUnit(),e.getMaskVectorTextureUnit=()=>t.maskVectorTexture?(t.maskVectorTexture.activate(),t.maskVectorTexture.getTextureUnit()):e.getImageVectorTextureUnit(),e.clearBuffers=function(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const n=t.framebuffer,r=t.context;n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeColorBuffer(3),n.setColorBuffer(t.licTexture0,0),n.setColorBuffer(t.seedTexture0,1),n.setColorBuffer(t.licTexture1,2),n.setColorBuffer(t.seedTexture1,3);const o=[r.COLOR_ATTACHMENT0,r.COLOR_ATTACHMENT1,r.COLOR_ATTACHMENT2,r.COLOR_ATTACHMENT3];e&&(n.removeColorBuffer(4),n.setColorBuffer(t.eeTexture,4),o.push(r.COLOR_ATTACHMENT4)),r.drawBuffers(o),r.clearColor(0,1,0,0),r.disable(r.SCISSOR_TEST),r.disable(r.BLEND),r.clear(r.COLOR_BUFFER_BIT),n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeColorBuffer(3),e&&n.removeColorBuffer(4),r.drawBuffers([r.NONE])},e.clearBuffer=e=>{const n=t.framebuffer,r=t.context;n.removeColorBuffer(0),n.setColorBuffer(e,0),r.drawBuffers([r.COLOR_ATTACHMENT0]),r.clearColor(0,1,0,0),r.disable(r.SCISSOR_TEST),r.disable(r.BLEND),r.clear(r.COLOR_BUFFER_BIT),n.removeColorBuffer(e,0),r.drawBuffers([r.NONE])},e.activateVectorTextures=()=>{t.imageVectorTexture?t.imageVectorTexture.activate():t.vectorTexture.activate(),t.maskVectorTexture&&t.maskVectorTexture.activate()},e.deactivateVectorTextures=()=>{t.imageVectorTexture?t.imageVectorTexture.deactivate():t.vectorTexture.deactivate(),t.maskVectorTexture&&t.maskVectorTexture.deactivate()},e.activateNoiseTexture=function(){switch(arguments.length>0&&void 0!==arguments[0]?arguments[0]:0){case 0:t.noiseTexture.activate();break;case 1:t.eeTexture.activate();break;default:console.error("Wrong LIC pass number")}},e.deactivateNoiseTexture=function(){switch(arguments.length>0&&void 0!==arguments[0]?arguments[0]:0){case 0:t.noiseTexture.deactivate();break;case 1:t.eeTexture.deactivate();break;default:console.error("Wrong LIC pass number")}},e.attachLICBuffers=()=>{const e=t.textures[t.readIndex],n=t.textures[1-t.readIndex],r=t.framebuffer,o=t.context;e[0].activate(),e[1].activate(),r.removeColorBuffer(0),r.removeColorBuffer(1),r.setColorBuffer(n[0],0),r.setColorBuffer(n[1],1),o.drawBuffers([o.COLOR_ATTACHMENT0,o.COLOR_ATTACHMENT1])},e.detachLICBuffers=()=>{const e=t.textures[t.readIndex],n=t.context,r=t.framebuffer;e[0].deactivate(),e[1].deactivate(),r.removeColorBuffer(0),r.removeColorBuffer(1),n.drawBuffers([n.NONE])},e.attachImageVectorBuffer=()=>{const e=t.framebuffer,n=t.context;t.vectorTexture.activate(),e.removeColorBuffer(0),e.setColorBuffer(t.imageVectorTexture,0),n.drawBuffers([n.COLOR_ATTACHMENT0])},e.detachImageVectorBuffer=()=>{const e=t.context,n=t.framebuffer;t.vectorTexture.deactivate(),n.removeColorBuffer(0),e.drawBuffers([e.NONE])},e.attachEEBuffer=()=>{t.textures[t.readIndex][0].activate(),t.framebuffer.removeColorBuffer(0),t.framebuffer.setColorBuffer(t.eeTexture,0);const e=t.context;e.drawBuffers([e.COLOR_ATTACHMENT0])},e.detachEEBuffer=()=>{const e=t.context;t.framebuffer.removeColorBuffer(0),e.drawBuffers([e.NONE]),t.textures[t.readIndex][0].deactivate()},e.detachBuffers=()=>{const e=t.context,n=t.framebuffer;n.removeColorBuffer(0),n.removeColorBuffer(1),e.drawBuffers([e.NONE]);const r=t.textures[t.readIndex],o=t.textures[1-t.readIndex];r[0]&&r[0].deactivate(),r[1]&&r[1].deactivate(),o[0]&&o[0].deactivate(),o[1]&&o[1].deactivate(),t.eeTexture&&t.eeTexture.deactivate(),t.noiseTexture&&t.noiseTexture.deactivate()},e.getWriteIndex=()=>1-t.readIndex,e.detachBuffers()):console.error("Pass renderwindow to ping pong manager");var n,r}(e,t)}var zf={newInstance:Ht.newInstance(Uf,"vtkLICPingPongBufferManager"),extend:Uf};const Wf=0,Hf=1,jf=2,Kf=3,$f=1,qf={shadersNeedBuild:!0,stepSize:1,numberOfSteps:10,enhancedLIC:!0,enhanceContrast:!1,lowContrastEnhancementFactor:0,highContrastEnhancementFactor:0,antiAlias:0,componentIds:[0,1],normalizeVectors:!0,maskThreshold:0,transformVectors:!0,bufs:null,isComposite:!0};function Xf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,qf,n),Ht.obj(e,t),Ht.setGet(e,t,["context","_openGLRenderWindow","nuberOfSteps","stepSize","normalizeVectors","maskThreshold","enhancedLIC","enhanceContrast","lowLICContrastEnhancementFactor","highLICContrastEnhancementFactor","antiAlias","componentIds","isComposite"]),Ht.moveToProtected(e,t,["openGLRenderWindow"]),function(e,t){function n(e,t){e.setUniformi("texLIC",t.getLICTextureUnit()),e.setUniformi("texSeedPts",t.getSeedTextureUnit())}function r(e,t,n){e.attachLICBuffers(),e.renderQuad(t,n),e.detachLICBuffers(),e.swap()}t.classHierarchy.push("vtkLineIntegralConvolution2D"),e.buildAShader=e=>t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(Nf,e,""),e.dumpTextureValues=function(e,n){let[r,o]=n,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t.context,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t._openGLRenderWindow,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:4;const l=Zd.newInstance(),c=a;let u=null;return l.setOpenGLRenderWindow(i),l.saveCurrentBindingsAndBuffers(),l.create(r,o),l.populateFramebuffer(),l.setColorBuffer(e),u=new Float32Array(r*o*s),c.readPixels(0,0,r,o,4===s?c.RGBA:c.RGB,c.FLOAT,u),l.restorePreviousBindingsAndBuffers(),u},e.getTextureMinMax=function(n,r){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t.context,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t._openGLRenderWindow;const i=e.dumpTextureValues(n,r,o,a,4);let s=Number.MAX_VALUE,l=Number.MIN_VALUE;for(let e=0;e<i.length;e+=4)if(0===i[e+1]){const t=i[e];t<s&&(s=t),t>l&&(l=t)}return{min:s,max:l}},e.getComponentSelectionProgram=e=>{const t="xyzw";return`.${t[e[0]]}${t[e[1]]}`},e.buildShaders=()=>{t.LIC0ShaderProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_LIC0.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n/**\nThis shader initializes the convolution for the LIC computation.\n*/\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\nuniform sampler2D texMaskVectors;\nuniform sampler2D texNoise;\nuniform sampler2D texLIC;\n\nuniform int   uStepNo;         // in step 0 initialize lic and seeds, else just seeds\nuniform int   uPassNo;         // in pass 1 hpf of pass 0 is convolved.\nuniform float uMaskThreshold;  // if |V| < uMaskThreshold render transparent\nuniform vec2  uNoiseBoundsPt1; // tc of upper right pt of noise texture\n\nin vec2 tcoordVC;\n\n// convert from vector coordinate space to noise coordinate space.\n// the noise texture is tiled across the *whole* domain\nvec2 VectorTCToNoiseTC(vec2 vectc)\n{\n  return vectc/uNoiseBoundsPt1;\n}\n\n// get the texture coordidnate to lookup noise value. this\n// depends on the pass number.\nvec2 getNoiseTC(vec2 vectc)\n{\n  // in pass 1 : convert from vector tc to noise tc\n  // in pass 2 : use vector tc\n  if (uPassNo == 0)\n    {\n    return VectorTCToNoiseTC(vectc);\n    }\n  else\n    {\n    return vectc;\n    }\n}\n\n// look up noise value at the given location. The location\n// is supplied in vector texture coordinates, hence the\n// need to convert to noise texture coordinates.\nfloat getNoise(vec2 vectc)\n{\n  return texture2D(texNoise, getNoiseTC(vectc)).r;\n}\n\nvoid main(void)\n{\n  vec2 vectc = tcoordVC.st;\n\n  // lic => (convolution, mask, 0, step count)\n  if (uStepNo == 0)\n    {\n    float maskCriteria = length(texture2D(texMaskVectors, vectc).xyz);\n    float maskFlag;\n    if (maskCriteria <= uMaskThreshold)\n      {\n      maskFlag = 1.0;\n      }\n    else\n      {\n      maskFlag = 0.0;\n      }\n    float noise = getNoise(vectc);\n    LICOutput = vec4(noise, maskFlag, 0.0, 1.0);\n    }\n  else\n    {\n    LICOutput = texture2D(texLIC, vectc);\n    }\n\n  // initial seed\n  SeedOutput = vec4(vectc, 0.0, 1.0);\n}\n");const n=wu.substitute("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_VT.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// move vector field to normalized image space\n// pre-processing for vtkLineIntegralConvolution2D\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Fragment shader used by the gaussian blur filter render pass.\n\nuniform sampler2D texVectors; // input texture\nuniform vec2      uTexSize;   // size of texture\n\nin vec2 tcoordVC;\n\nvoid main(void)\n{\n  //VTK::LICComponentSelection::Impl\n  V = V/uTexSize;\n  gl_FragData[0] = vec4(V, 0.0, 1.0);\n}\n","//VTK::LICComponentSelection::Impl",`vec2 V = texture2D(texVectors, tcoordVC.st)${e.getComponentSelectionProgram(t.componentIds)};`).result;t.VTProgram=e.buildAShader(n);const r=wu.substitute("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_fs1.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\nuniform sampler2D  texVectors;\nuniform sampler2D  texNoise;\nuniform sampler2D  texLIC;\nuniform sampler2D  texSeedPts;\n\nuniform int   uPassNo;          // in pass 1 hpf of pass 0 is convolved.\nuniform float uStepSize;        // step size in parametric space\n\nuniform vec2  uNoiseBoundsPt1;  // tc of upper right pt of noise texture\n\nin vec2 tcoordVC;\n\n//VTK::LICVectorLookup::Impl\n\n// We need to do this manually since CLAMP_TO_BORDER and and borderColor\n// are very poorly supported in webgl\nvec2 clampToBorder(vec2 uv){\n  if(uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0)\n  {\n    return vec2(0.0, 0.0);\n  }\n  return getVector(uv);\n}\n\n// convert from vector coordinate space to noise coordinate space.\n// the noise texture is tiled across the whole domain\nvec2 VectorTCToNoiseTC(vec2 vectc)\n{\n  return vectc/uNoiseBoundsPt1;\n}\n\n// get the texture coordidnate to lookup noise value.\n// in pass 1 repeatedly tile the noise texture across\n// the computational domain.\nvec2 getNoiseTC(vec2 tc)\n{\n  if (uPassNo == 0)\n    {\n    return VectorTCToNoiseTC(tc);\n    }\n  else\n    {\n    return tc;\n    }\n}\n\n// look up noise value at the given location. The location\n// is supplied in vector texture coordinates, hence the need\n// to convert to either noise or lic texture coordinates in\n// pass 1 and 2 respectively.\nfloat getNoise(vec2 vectc)\n{\n  return texture2D(texNoise, getNoiseTC(vectc)).r;\n}\n\n// fourth-order Runge-Kutta streamline integration\n// no bounds checks are made, therefore it's essential\n// to have the entire texture initialized to 0\n// and set clamp to border and have border color 0\n// an integer is set if the step was taken, keeping\n// an accurate step count is necessary to prevent\n// boundary artifacts. Don't count the step if\n// all vector lookups are identically 0. This is\n// a proxy for \"stepped outside valid domain\"\nvec2 rk4(vec2 pt0, float dt, out bool count)\n{\n  count=true;\n  float dtHalf = dt * 0.5;\n  vec2 pt1;\n\n  vec2 v0 = clampToBorder(pt0);\n  pt1 = pt0 + v0 * dtHalf;\n\n  vec2 v1 = clampToBorder(pt1);\n  pt1 = pt0 + v1 * dtHalf;\n\n  vec2 v2 = clampToBorder(pt1);\n  pt1 = pt0 + v2 * dt;\n\n  vec2 v3 = clampToBorder(pt1);\n  vec2 vSum = v0 + v1 + v1 + v2 + v2 + v3;\n\n  if (vSum == vec2(0.0, 0.0))\n    {\n      count = false;\n    }\n\n  pt1 = pt0 + (vSum) * (dt * (1.0/6.0));\n\n return pt1;\n}\n\nvoid main(void)\n{\n  vec2 lictc = tcoordVC.st;\n  vec4 lic = texture2D(texLIC, lictc);\n  vec2 pt0 = texture2D(texSeedPts, lictc).st;\n\n  bool count;\n  vec2 pt1 = rk4(pt0, uStepSize, count);\n\n  if (count)\n    {\n    // accumulate lic step\n    // (lic, mask, 0, step count)\n    float noise = getNoise(pt1);\n    LICOutput = vec4(lic.r + noise, lic.g, 0.0, lic.a + 1.0);\n    SeedOutput = vec4(pt1, 0.0, 1.0);\n    }\n  else\n    {\n    // keep existing values\n    LICOutput = lic;\n    SeedOutput = vec4(pt0, 0.0, 1.0);\n    }\n}\n","//VTK::LICVectorLookup::Impl",function(){return arguments.length>0&&void 0!==arguments[0]&&!arguments[0]?"\n    vec2 getVector( vec2 vectc )\n\n      {\n\n      return texture2D( texVectors, vectc ).xy;\n\n      }\n\n    ":"\n    vec2 getVector( vec2 vectc )\n\n      {\n\n      vec2 V = texture2D( texVectors, vectc ).xy;\n\n      // normalize if |V| not 0\n\n      float lenV = length( V );\n\n      if ( lenV > 1.0e-8 )\n\n        {\n\n        return V/lenV;\n\n        }\n\n      else\n\n        {\n\n        return vec2( 0.0, 0.0 );\n\n        }\n\n      }\n\n    "}(t.normalizeVectors),!0).result;t.LICIShaderProgram=e.buildAShader(r),t.LICNShaderProgram=e.buildAShader(" //VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_LICN.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\n/**\nThis shader finalizes the convolution for the LIC computation\napplying the normalization. eg. if box kernel is used the this\nis the number of steps taken.\n*/\n\nuniform sampler2D texLIC;\n\nin vec2 tcoordVC;\n\nvoid main(void)\n{\n  vec4 conv = texture2D(texLIC, tcoordVC.st);\n  conv.r = conv.r/conv.a;\n  // lic => (convolution, mask, 0, 1)\n  LICOutput = vec4(conv.rg , 0.0, 1.0);\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\n}\n"),t.CEProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_CE.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// gray scale contrast enhance stage implemented via histogram stretching\n// if the min and max are tweaked it can generate out-of-range values\n// these will be clamped in 0 to 1\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\n\nuniform sampler2D texLIC;  // most recent lic pass\nuniform float uMin;        // min gray scale color value\nuniform float uMaxMinDiff; // max-min\n\nin vec2 tcoordVC;\n\nvoid main( void )\n{\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\n  if (lic.g!=0.0)\n    {\n    LICOutput = lic;\n    }\n  else\n    {\n    float CElic = clamp((lic.r - uMin)/uMaxMinDiff, 0.0, 1.0);\n    LICOutput = vec4(CElic, lic.gb, 1.0);\n    }\n    SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\n}\n"),t.EEProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_fs2.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// high-pass filter stage employed by vtkLineIntegralConvolution2D\n// between LIC pass 1 and LIC pass 2. filtered LIC pass 1, becomes\n// noise for pass2.\n\n// the output of this shader\nlayout(location = 0) out vec4 EEOutput;\n\nuniform sampler2D texLIC; // most recent lic pass\nuniform float     uDx;    // fragment size\nuniform float     uDy;    // fragment size\n\nin vec2 tcoordVC;\n\n// kernel for simple laplace edge enhancement.\n// p=Laplace(p)+p\nfloat K[9] = float[9](\n  -1.0, -1.0, -1.0,\n  -1.0,  9.0, -1.0,\n  -1.0, -1.0, -1.0\n  );\n\n// determine if the fragment was masked\nbool Masked(float val) { return val != 0.0; }\n\nvoid main(void)\n{\n  // tex coord neighbor offsets\n  vec2 fragDx[9] = vec2[9](\n    vec2(-uDx, uDy), vec2(0.0, uDy), vec2(uDx, uDy),\n    vec2(-uDx, 0.0), vec2(0.0, 0.0), vec2(uDx, 0.0),\n    vec2(-uDx,-uDy), vec2(0.0,-uDy), vec2(uDx,-uDy)\n    );\n\n  vec2 lictc = tcoordVC.st;\n\n  // compute the convolution but don't use convovled values if\n  // any masked fragments on the stencil. Fragments outside\n  // the valid domain are masked during initialization, and\n  // texture wrap parameters are clamp to border with border\n  // color that contains masked flag\n  float conv = 0.0;\n  bool dontUse = false;\n  for (int i=0; i<9; ++i)\n    {\n    vec2 tc = lictc + fragDx[i];\n    vec4 lic = texture2D(texLIC, tc);\n    dontUse = dontUse || Masked(lic.g);\n    conv = conv + K[i] * lic.r;\n    }\n\n  if (dontUse)\n    {\n    EEOutput = vec4(texture2D(texLIC, lictc).rg, 0.0, 1.0);\n    }\n  else\n    {\n    conv = clamp(conv, 0.0, 1.0);\n    EEOutput = vec4(conv,texture2D(texLIC, lictc).g, 0.0, 1.0);\n    }\n\n}\n"),t.AAHProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_AAH.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// Anti-alias stage in vtkLineIntegralConvolution2D\n// horizontal pass of a Gaussian convolution\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\nuniform sampler2D texLIC; // input texture\nuniform float     uDx;    // fragment size\n\nin vec2 tcoordVC;\n\n// factored 3x3 Gaussian kernel\n// K^T*K = G\nfloat K[3] = float[3](0.141421356, 0.707106781, 0.141421356);\n\n// determine if the fragment was masked\nbool Masked(float val){ return val != 0.0; }\n\nvoid main(void)\n{\n// neighbor offsets\nvec2 fragDx[3] = vec2[3](vec2(-uDx,0.0), vec2(0.0,0.0), vec2(uDx,0.0));\n\n  vec2 lictc = tcoordVC.st;\n  vec4 lic[3];\n  bool dontUse = false;\n  float conv = 0.0;\n  for (int i=0; i<3; ++i)\n    {\n    vec2 tc = lictc + fragDx[i];\n    lic[i] = texture2D(texLIC, tc);\n    dontUse = dontUse || Masked(lic[i].g);\n    conv = conv + K[i] * lic[i].r;\n    }\n  // output is (conv, mask, skip, 1)\n  if (dontUse)\n    {\n    LICOutput = vec4(lic[1].rg, 1.0, 1.0);\n    }\n  else\n    {\n    LICOutput = vec4(conv, lic[1].gb, 1.0);\n    }\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\n}\n"),t.AAVProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_AAV.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// Anti-alias stage in vtkLineIntegralConvolution2D\n// vertical pass of a Gaussian convolution\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\nuniform sampler2D texLIC; // input texture\nuniform float     uDy;    // fragment size\n\nin vec2 tcoordVC;\n\n\n// factored 3x3 Gaussian kernel\n// K^T*K = G\nfloat K[3] = float[3](0.141421356, 0.707106781, 0.141421356);\n\n// determine if the fragment was masked\nbool Masked(float val){ return val != 0.0; }\n\nvoid main(void)\n{\n// neighbor offsets\nvec2 fragDy[3] = vec2[3](vec2(0.0,-uDy), vec2(0.0,0.0), vec2(0.0,uDy));\n\n\n  vec2 lictc = tcoordVC.st;\n  vec4 lic[3];\n  bool dontUse = false;\n  float conv = 0.0;\n  for (int i=0; i<3; ++i)\n    {\n    vec2 tc = lictc + fragDy[i];\n    lic[i] = texture2D(texLIC, tc);\n    dontUse = dontUse || Masked(lic[i].g);\n    conv = conv + K[i] * lic[i].r;\n    }\n  // output is (conv, mask, skip, 1)\n  if (dontUse)\n    {\n    LICOutput = vec4(lic[1].rg, 1.0, 1.0);\n    }\n  else\n    {\n    LICOutput = vec4(conv, lic[1].gb, 1.0);\n    }\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\n}\n")},e.executeLIC=(o,a,i,s,l,c)=>{if(t._openGLRenderWindow=l,t.context=l.getContext(),Object.assign(t,c),o[0]<=0||o[1]<=0)return null;const u=[1/o[0],1/o[1]];let d=t.stepSize*Math.sqrt(u[0]*u[0]+u[1]*u[1]);d<=0&&(d=1e-10);const p=t.context;let f=t.framebuffer;const g=f?.getSize();f&&g&&o[0]===g&&o[1]===g||(f=Zd.newInstance(),f.setOpenGLRenderWindow(t._openGLRenderWindow),f.saveCurrentBindingsAndBuffers(),f.create(...o),f.populateFramebuffer(),f.restorePreviousBindingsAndBuffers(),t.framebuffer=f),f.saveCurrentBindingsAndBuffers(),f.bind(),p.viewport(0,0,...o),p.scissor(0,0,...o),t.shadersNeedBuild&&(e.buildShaders(),t.shadersNeedBuild=!1),t.bufs?(t.bufs.setVectorTexture(a),t.bufs.setMaskVectorTexture(i),t.bufs.setNoiseTexture(s)):t.bufs=zf.newInstance({openGLRenderWindow:l,doEEPass:t.enhancedLIC,doVTPass:t.transformVectors,vectorTexture:a,maskVectorTexture:i,noiseTexture:s,framebuffer:f,size:o});const m=[(s.getWidth()+1)/o[0],(s.getHeight()+1)/o[1]],h=1/o[0],v=1/o[1],T=t._openGLRenderWindow.getShaderCache();if(t.transformVectors){const e=t.VTProgram;T.readyShaderProgram(e),t.bufs.attachImageVectorBuffer(),e.setUniform2f("uTexSize",...o),e.setUniformi("texVectors",t.bufs.getVectorTextureUnit()),p.clearColor(0,0,0,0),p.clear(p.COLOR_BUFFER_BIT),t.bufs.renderQuad(o,e),t.bufs.detachImageVectorBuffer()}t.bufs.clearBuffers(t.enhancedLIC),t.bufs.activateVectorTextures(),t.bufs.activateNoiseTexture(0);const{LIC0ShaderProgram:y}=t;T.readyShaderProgram(y),y.setUniformi("uStepNo",0),y.setUniformi("uPassNo",0),y.setUniformf("uMaskThreshold",t.maskThreshold),y.setUniform2f("uNoiseBoundsPt1",...m),y.setUniformi("texMaskVectors",t.bufs.getMaskVectorTextureUnit()),y.setUniformi("texLIC",t.bufs.getLICTextureUnit()),y.setUniformi("texNoise",t.bufs.getNoiseTextureUnit(0)),r(t.bufs,o,y);const{LICIShaderProgram:b}=t;T.readyShaderProgram(b),b.setUniformi("uPassNo",0),b.setUniformf("uStepSize",-d),b.setUniform2f("uNoiseBoundsPt1",...m),b.setUniformi("texVectors",t.bufs.getImageVectorTextureUnit()),b.setUniformi("texNoise",t.bufs.getNoiseTextureUnit(0));for(let e=0;e<t.numberOfSteps;++e)n(b,t.bufs),r(t.bufs,o,b);T.readyShaderProgram(y),y.setUniformi("uStepNo",1),n(y,t.bufs),r(t.bufs,o,y),T.readyShaderProgram(b),b.setUniformf("uStepSize",d);for(let e=0;e<t.numberOfSteps;++e)n(b,t.bufs),r(t.bufs,o,b);t.bufs.deactivateNoiseTexture(0),t.bufs.deactivateVectorTextures();const{LICNShaderProgram:x}=t;if(T.readyShaderProgram(x),x.setUniformi("texLIC",t.bufs.getLICTextureUnit()),r(t.bufs,o,x),t.enhancedLIC){t.enhanceContrast!==Hf&&t.enhanceContrast!==Kf||e.contrastEnhance(!1,o),t.bufs.attachEEBuffer();const{EEProgram:a}=t;T.readyShaderProgram(a),a.setUniformi("texLIC",t.bufs.getLICTextureUnit()),a.setUniformf("uDx",h),a.setUniformf("uDy",v),t.bufs.renderQuad(o,a),t.bufs.detachEEBuffer(),t.bufs.detachBuffers(),t.bufs.clearBuffers(!1),t.bufs.activateVectorTextures(),t.bufs.activateNoiseTexture(1),T.readyShaderProgram(y),y.setUniformi("uStepNo",0),y.setUniformi("uPassNo",1),n(y,t.bufs),y.setUniformi("texNoise",t.bufs.getNoiseTextureUnit(1)),r(t.bufs,o,y),T.readyShaderProgram(b),b.setUniformi("uPassNo",1),b.setUniformf("uStepSize",-d),b.setUniformi("texNoise",t.bufs.getNoiseTextureUnit(1));const i=t.numberOfSteps/2;for(let e=0;e<i;++e)n(b,t.bufs),r(t.bufs,o,b);T.readyShaderProgram(y),y.setUniformi("uStepNo",1),n(y,t.bufs),r(t.bufs,o,y),T.readyShaderProgram(b),b.setUniformf("uStepSize",d);for(let e=0;e<i;++e)n(b,t.bufs),r(t.bufs,o,b);t.bufs.deactivateNoiseTexture(1),t.bufs.deactivateVectorTextures(),T.readyShaderProgram(x),x.setUniformi("texLIC",t.bufs.getLICTextureUnit()),x.setUniformi("texSeedPts",t.bufs.getSeedTextureUnit()),r(t.bufs,o,x)}if(t.antiAlias){const e=t.AAHProgram;T.readyShaderProgram(e),e.setUniformi("texLIC",t.bufs.getLICTextureUnit()),e.setUniformf("uDx",h);const a=t.AAVProgram;T.readyShaderProgram(a),a.setUniformi("texLIC",t.bufs.getLICTextureUnit()),a.setUniformf("uDy",v);for(let i=0;i<t.antiAlias;++i)T.readyShaderProgram(e),n(e,t.bufs),r(t.bufs,o,e),T.readyShaderProgram(a),n(a,t.bufs),r(t.bufs,o,a)}return t.enhanceContrast!==Hf&&t.enhanceContrast!==Kf||e.contrastEnhance(!0,o),t.bufs.detachBuffers(),f.restorePreviousBindingsAndBuffers(),t.bufs.getLastLICBuffer()},e.contrastEnhance=(n,o)=>{const a=t._openGLRenderWindow.getShaderCache();let{min:i,max:s}=e.getTextureMinMax(t.bufs.getLastLICBuffer(),o,t.context,t._openGLRenderWindow);(s<=i||s>1||i<0)&&(console.error("Invalid color range: ",i,s),i=0,s=1);let l=s-i;n&&(i+=l*t.lowLICContrastEnhancementFactor,s-=l*t.highLICContrastEnhancementFactor,l=s-i);const{CEProgram:c}=t;a.readyShaderProgram(c),c.setUniformi("texLIC",t.bufs.getLICTextureUnit()),c.setUniformf("uMin",i),c.setUniformf("uMaxMinDiff",l),r(t.bufs,o,c)}}(e,t)}var Yf={newInstance:Ht.newInstance(Xf,"vtkLineIntegralConvolution2D"),extend:Xf};const Zf={enableLIC:!1,nuberOfSteps:40,stepSize:.25,transformVectors:!0,normalizeVectors:!0,maskOnSurface:!1,maskThreshold:0,maskColor:[0,0,0],maskIntensity:0,enhancedLIC:!0,enhanceContrast:Wf,lowLICContrastEnhancementFactor:0,highLICContrastEnhancementFactor:0,lowColorContrastEnhancementFactor:0,highColorContrastEnhancementFactor:0,antiAlias:0,colorMode:0,LICIntensity:1,mapModeBias:0,noiseTextureSize:200,noiseTextureType:$f,noiseGrainSize:8,noiseImpulseProbability:.1,noiseImpulseBackgroundValue:0,noiseGeneratorSeed:0,minNoiseValue:0,maxNoiseValue:1,numberOfNoiseLevels:2,shadersNeedBuilding:!0,reallocateTextures:!0,rebuildNoiseTexture:!1,viewPortScale:1};function Qf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Zf,n),Ht.obj(e,t),Ht.setGet(e,t,["enableLIC","numberOfSteps","stepSize","normalizeVectors","transformVectors","maskOnSurface","maskThreshold","maskColor","maskIntensity","enhancedLIC","enhanceContrast","lowLICContrastEnhancementFactor","highLICContrastEnhancementFactor","lowColorContrastEnhancementFactor","highColorContrastEnhancementFactor","antiAlias","colorMode","LICIntensity","mapModeBias","noiseTextureSize","noiseTextureType","noiseGrainSize","minNoiseValue","maxNoiseValue","numberOfNoiseLevels","noiseImpulseProbability","noiseImpulseBackgroundValue","noiseGeneratorSeed","viewPortScale","rebuildNoiseTexture"]),function(e,t){t.classHierarchy.push("vtkSurfaceLICInterface")}(0,t)}var Jf={newInstance:Ht.newInstance(Qf,"vtkSurfaceLICInterface"),extend:Qf};const{Representation:eg}=ts;const tg={context:null,shadersNeedBuilding:!0,reallocateTextures:!0,size:null,licInterface:null};function ng(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,tg,n),Jf.extend(e,t,n),Ht.obj(e,t),Ht.setGet(e,t,["context","_openGLRenderWindow","reallocateTextures","licInterface","size"]),Ht.moveToProtected(e,t,["openGLRenderWindow"]),function(e,t){t.classHierarchy.push("vtkOpenGLSurfaceLICInterface"),e.renderQuad=(e,n)=>{const r=t.licQuad,o=t.context;let a=t.licQuadVAO;a||(a=Ru.newInstance(),a.setOpenGLRenderWindow(t._openGLRenderWindow),t.licQuadVAO=a),t.previousProgramHash!==n.getMd5Hash()&&(a.shaderProgramChanged(),r.getCABO().bind(),a.addAttributeArray(n,r.getCABO(),"vertexDC",r.getCABO().getVertexOffset(),r.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE),a.addAttributeArray(n,r.getCABO(),"tcoordDC",r.getCABO().getTCoordOffset(),r.getCABO().getStride(),t.context.FLOAT,2,t.context.FALSE),t.previousProgramHash=n.getMd5Hash()),o.drawArrays(o.TRIANGLES,0,r.getCABO().getElementCount()),a.release()},e.generateNoiseTexture=e=>{if(!t.noiseTexture||t.licInterface.getRebuildNoiseTexture()){t.licInterface.setRebuildNoiseTexture(!1),t.noiseTexture&&t.noiseTexture.releaseGraphicsResources(),io()(t.noiseGeneratorSeed,{global:!0});let n=[];const{noiseTextureType:r,noiseGrainSize:o,numberOfNoiseLevels:a,noiseImpulseProbability:i,noiseImpulseBackgroundValue:s,minNoiseValue:l,maxNoiseValue:c}=t.licInterface.get("noiseTextureType","noiseGrainSize","numberOfNoiseLevels","noiseImpulseProbability","noiseImpulseBackgroundValue","minNoiseValue","maxNoiseValue");n=r===$f?function(e,t,n,r,o,a){const i=Math.max(0,Math.min(1,n)),s=Float32Array.from({length:e*e},(()=>{let e=0;if(1===i||Math.random()>1-i)for(let t=0;t<2048;++t)e+=Math.random();return e}));let l=0,c=2049;s.forEach((e=>{c=1===i?e<c?e:c:e<c&&e>0?e:c,l=e>l?e:l}));let u=l-c;0===u&&(c=0,u=0===l?1:l);const d=t-1,p=0!==d?1/d:0,f=a-o;return s.map((e=>{const n=e<c?e:(e-c)/u,i=Math.floor(n*t);return e>=c?1===t?a:o+(i>d?d:i)*p*f:r}))}(Math.floor(e/o),a,i,s,l,c):function(e,t,n,r){let[o,a]=e;const i=r-n;return Float32Array.from({length:o*a},(()=>{let e=Math.random();return e=Math.floor(e*t)/t,e=e*i+n,e>1?1:e<0?0:e}))}([Math.ceil(e/o),Math.ceil(e/o)],a,l,c);const u=1/o,d=Float32Array.from({length:e*e*4},((t,r)=>{const a=r/4;if(r%4==0){const t=Math.floor(a%e*u),r=Math.floor(a/e*u);return n[r*(e/o)+t]}return r%4==1||r%4==3?1:0})),p=Ju.newInstance({wrapS:Ju.Wrap.REPEAT,wrapT:Ju.Wrap.REPEAT,minificationFilter:Ju.Filter.NEAREST,magnificationFilter:Ju.Filter.NEAREST,generateMipMap:!1,openGLDataType:t.context.FLOAT,baseLevel:0,maxLevel:0,autoParameters:!1});p.setOpenGLRenderWindow(t._openGLRenderWindow),p.create2DFromRaw({width:e,height:e,numComps:4,dataType:"Float32Array",data:d}),p.activate(),p.sendParameters(),p.deactivate(),t.noiseTexture=p}},e.buildAShader=e=>t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(Nf,e,""),e.allocateTextures=()=>{const n=Ju.Filter.NEAREST,r=Ju.Filter.LINEAR,o=t._openGLRenderWindow;t.geometryImage||(t.geometryImage=e.allocateTexture(o,n)),t.vectorImage||(t.vectorImage=e.allocateTexture(o,r)),t.maskVectorImage||(t.maskVectorImage=e.allocateTexture(o,r)),t.LICImage||(t.LICImage=e.allocateTexture(o,n)),t.RGBColorImage||(t.RGBColorImage=e.allocateTexture(o,n)),t.HSLColorImage||(t.HSLColorImage=e.allocateTexture(o,n)),t.depthTexture||(t.depthTexture=e.allocateDepthTexture(o))},e.allocateTexture=(e,n)=>{const r=t.context,o=Ju.newInstance({wrapS:Ju.Wrap.CLAMP_TO_EDGE,wrapT:Ju.Wrap.CLAMP_TO_EDGE,minificationFilter:n,magnificationFilter:n,generateMipmap:!1,openGLDataType:r.FLOAT,baseLevel:0,maxLevel:0,autoParameters:!1});return o.setOpenGLRenderWindow(e),o.setInternalFormat(r.RGBA32F),o.create2DFromRaw({width:t.size[0],height:t.size[1],numComps:4,dataType:"Float32Array",data:null}),o.activate(),o.sendParameters(),o.deactivate(),o},e.allocateDepthTexture=e=>{const n=t.context,r=Ju.newInstance({generateMipmap:!1,openGLDataType:n.FLOAT,autoParameters:!1});return r.setOpenGLRenderWindow(e),r.createDepthFromRaw({width:t.size[0],height:t.size[1],dataType:"Float32Array",data:null}),r.activate(),r.sendParameters(),r.deactivate(),r},e.createFBO=()=>{if(!t.framebuffer){t.licHelper=null;const e=Zd.newInstance();e.setOpenGLRenderWindow(t._openGLRenderWindow),e.saveCurrentBindingsAndBuffers(),e.create(...t.size),e.populateFramebuffer(),t.framebuffer=e,e.restorePreviousBindingsAndBuffers()}},e.completedGeometry=()=>{const e=t.context,n=t.framebuffer;n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeDepthBuffer(),e.drawBuffers([e.NONE]),n.restorePreviousBindingsAndBuffers()},e.buildAllShaders=()=>{t.shadersNeedBuilding&&(t.licColorPass=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkSurfaceLICMapper_fs2.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// This shader combines surface geometry, LIC, and  scalar colors.\n\n// the output of this shader\nlayout(location = 0) out vec4 RGBOutput;\nlayout(location = 1) out vec4 HSLOutput;\n\nuniform sampler2D texVectors;       // vectors, depth\nuniform sampler2D texGeomColors;    // scalar colors + lighting\nuniform sampler2D texLIC;           // image lic\nuniform int       uScalarColorMode; // select between blend, and map shader\nuniform float     uLICIntensity;    // blend shader: blending factor for lic'd colors\nuniform float     uMapBias;         // map shader: adjust the brightness of the result\nuniform float     uMaskIntensity;   // blending factor for mask color\nuniform vec3      uMaskColor;       // color for the masked out fragments\n\nin vec2 tcoordVC;\n\n/**\nConvert from RGB color space into HSL colorspace.\n*/\nvec3 RGBToHSL(vec3 RGB)\n{\n  vec3 HSL = vec3(0.0, 0.0, 0.0);\n\n  float RGBMin = min(min(RGB.r, RGB.g), RGB.b);\n  float RGBMax = max(max(RGB.r, RGB.g), RGB.b);\n  float RGBMaxMinDiff = RGBMax - RGBMin;\n\n  HSL.z = (RGBMax + RGBMin) / 2.0;\n\n  if (RGBMaxMinDiff == 0.0)\n    {\n    // Gray scale\n    HSL.x = 0.0;\n    HSL.y = 0.0;\n    }\n  else\n    {\n    // Color\n    if (HSL.z < 0.5)\n      HSL.y = RGBMaxMinDiff / (RGBMax + RGBMin);\n    else\n      HSL.y = RGBMaxMinDiff / (2.0 - RGBMax - RGBMin);\n\n    float dR\n      = (((RGBMax - RGB.r) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\n    float dG\n      = (((RGBMax - RGB.g) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\n    float dB\n      = (((RGBMax - RGB.b) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\n\n    if (RGB.r == RGBMax)\n      HSL.x = dB - dG;\n    else\n    if (RGB.g == RGBMax)\n      HSL.x = (1.0 / 3.0) + dR - dB;\n    else\n    if (RGB.b == RGBMax)\n      HSL.x = (2.0 / 3.0) + dG - dR;\n\n    if (HSL.x < 0.0)\n      HSL.x += 1.0;\n\n    if (HSL.x > 1.0)\n      HSL.x -= 1.0;\n    }\n\n  return HSL;\n}\n\n/**\nHelper for HSL to RGB conversion.\n*/\nfloat Util(float v1, float v2, float vH)\n{\n  if (vH < 0.0)\n    vH += 1.0;\n\n  if (vH > 1.0)\n     vH -= 1.0;\n\n  if ((6.0 * vH) < 1.0)\n    return (v1 + (v2 - v1) * 6.0 * vH);\n\n  if ((2.0 * vH) < 1.0)\n    return (v2);\n\n  if ((3.0 * vH) < 2.0)\n    return (v1 + (v2 - v1) * ((2.0 / 3.0) - vH) * 6.0);\n\n  return v1;\n}\n\n/**\nConvert from HSL space into RGB space.\n*/\nvec3 HSLToRGB(vec3 HSL)\n{\n  vec3 RGB;\n  if (HSL.y == 0.0)\n    {\n    // Gray\n    RGB.r = HSL.z;\n    RGB.g = HSL.z;\n    RGB.b = HSL.z;\n    }\n  else\n    {\n    // Chromatic\n    float v2;\n    if (HSL.z < 0.5)\n      v2 = HSL.z * (1.0 + HSL.y);\n    else\n      v2 = (HSL.z + HSL.y) - (HSL.y * HSL.z);\n\n    float v1 = 2.0 * HSL.z - v2;\n\n    RGB.r = Util(v1, v2, HSL.x + (1.0 / 3.0));\n    RGB.g = Util(v1, v2, HSL.x);\n    RGB.b = Util(v1, v2, HSL.x - (1.0 / 3.0));\n    }\n\n  return RGB.rgb;\n}\n\nvoid main()\n{\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\n  vec4 geomColor = texture2D(texGeomColors, tcoordVC.st);\n\n  // depth is used to determine which fragment belong to us\n  // and we can change\n  float depth = texture2D(texVectors, tcoordVC.st).a;\n\n  vec3 fragColorRGB;\n  float valid;\n  if (depth > 1.0e-3)\n    {\n    // we own it\n    // shade LIC'ed geometry, or apply mask\n    if (lic.g!=0.0)\n      {\n      // it's masked\n      // apply fragment mask\n      fragColorRGB = uMaskIntensity * uMaskColor + (1.0 - uMaskIntensity) * geomColor.rgb;\n      valid = 0.0;\n      }\n    else\n      {\n      if (uScalarColorMode==0)\n        {\n        // blend with scalars\n        fragColorRGB = lic.rrr * uLICIntensity + geomColor.rgb * (1.0 - uLICIntensity);\n        }\n      else\n        {\n        // multiply with scalars\n        fragColorRGB = geomColor.rgb * clamp((uMapBias + lic.r), 0.0, 1.0);\n        }\n      if (lic.b != 0.0)\n        {\n        // didn't have the required guard pixels\n        // don't consider it in min max estimation\n        // for histpgram stretching\n        valid = 0.0;\n        }\n      else\n        {\n        // ok to use in min/max estimates for histogram\n        // stretching\n        valid = 1.0;\n        }\n      }\n    }\n  else\n    {\n    // we don't own it\n    // pass through scalars\n    fragColorRGB = geomColor.rgb;\n    valid = 0.0;\n    }\n\n  // if no further stages this texture is\n  // copied to the screen\n  RGBOutput = vec4(fragColorRGB, geomColor.a);\n\n  // if further stages, move to hsl space for contrast\n  // enhancement. encoding validity saves moving a texture to the cpu\n  vec3 fragColorHSL = RGBToHSL(fragColorRGB);\n  HSLOutput = vec4(fragColorHSL, valid);\n}\n"),t.licCopyPass=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkSurfaceLICMapper_DCpy.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// This shader copies fragments and depths to the output buffer\n\n// the output of this shader\n//VTK::Output::Dec\n\nuniform sampler2D texDepth;     // z values from vertex shader\nuniform sampler2D texRGBColors; // final rgb LIC colors\n\nin vec2 tcoordVC;\n\nvoid main()\n{\n  gl_FragDepth = texture2D(texDepth, tcoordVC).x;\n  gl_FragData[0] = texture2D(texRGBColors, tcoordVC);\n\n  // since we render a screen aligned quad\n  // we're going to be writing fragments\n  // not touched by the original geometry\n  // it's critical not to modify those\n  // fragments.\n  if (gl_FragDepth == 1.0)\n    {\n    discard;\n    }\n}\n"),t.enhanceContrastPass=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkSurfaceLICMapper_CE.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// color contrast enhance stage implemented via histogram stretching\n// on lightness channel. if the min and max are tweaked it can generate\n// out-of-range values these will be clamped in 0 to 1\n\n// the output of this shader\n//VTK::Output::Dec\n\nuniform sampler2D texGeomColors; // scalars + lighting\nuniform sampler2D texLIC;        // image lic, mask\nuniform sampler2D texHSLColors;  // hsla colors\n\nuniform float     uLMin;         // min lightness over all fragments\nuniform float     uLMaxMinDiff;  // max - min lightness over all fragments\n\nin vec2 tcoordVC;\n\nvec3 HSLToRGB(vec3 HSL)\n{\n  vec3 RGB;\n  float v;\n  float h = HSL.x;\n  float sl = HSL.y;\n  float l = HSL.z;\n\n  v = (l <= 0.5) ? (l * (1.0 + sl)) : (l + sl - l * sl);\n  if (v <= 0.0) {\n    RGB = vec3(0.0,0.0,0.0);\n  } else {\n    float m;\n    int sextant;\n    float fract, vsf, mid1, mid2;\n\n    m = l + l - v;\n    h *= 6.0;\n    sextant = int(h);\n    fract = h - float(sextant);\n\n    vsf = (v - m) * fract;\n    mid1 = m + vsf;\n    mid2 = v - vsf;\n    switch (sextant) {\n      case 0: RGB.r = v; RGB.g = mid1; RGB.b = m; break;\n      case 1: RGB.r = mid2; RGB.g = v; RGB.b = m; break;\n      case 2: RGB.r = m; RGB.g = v; RGB.b = mid1; break;\n      case 3: RGB.r = m; RGB.g = mid2; RGB.b = v; break;\n      case 4: RGB.r = mid1; RGB.g = m; RGB.b = v; break;\n      case 5: RGB.r = v; RGB.g = m; RGB.b = mid2; break;\n    }\n  }\n  return RGB;\n}\n\nvoid main()\n{\n  // lookup hsl color , mask\n  vec4 fragColor = texture2D(texHSLColors, tcoordVC.st);\n\n  // don't modify masked fragments (masked => lic.g==1)\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\n  if (lic.g==0.0)\n    {\n    // normalize lightness channel\n    fragColor.z = clamp((fragColor.z - uLMin)/uLMaxMinDiff, 0.0, 1.0);\n    }\n\n  // back into rgb space\n  fragColor.rgb = HSLToRGB(fragColor.xyz);\n\n  // add alpha\n  vec4 geomColor = texture2D(texGeomColors, tcoordVC.st);\n  fragColor.a = geomColor.a;\n\n  gl_FragData[0] = fragColor;\n}\n"),t.shadersNeedBuilding=!1)},e.initializeResources=()=>{e.createFBO(),e.generateNoiseTexture(t.licInterface.getNoiseTextureSize()),e.allocateTextures(),e.buildAllShaders(),t.licQuad||(t.licQuad=function(e){const t=Du.newInstance();t.setOpenGLRenderWindow(e);const n=new Float32Array(12);for(let e=0;e<4;e++)n[3*e]=e%2*2-1,n[3*e+1]=e>1?1:-1,n[3*e+2]=0;const r=new Float32Array([0,0,1,0,0,1,1,1]),o=new Uint16Array(8);o[0]=3,o[1]=0,o[2]=1,o[3]=3,o[4]=3,o[5]=0,o[6]=3,o[7]=2;const a=Ts.newInstance({numberOfComponents:3,values:n});a.setName("points");const i=Ts.newInstance({numberOfComponents:1,values:o}),s=Ts.newInstance({numberOfComponents:2,values:r});return t.getCABO().createVBO(i,"polys",eg.SURFACE,{points:a,cellOffset:0,tcoords:s}),t}(t._openGLRenderWindow)),t.licHelper||(t.licHelper=Yf.newInstance())},e.prepareForGeometry=()=>{const e=t.framebuffer;e.saveCurrentBindingsAndBuffers(),e.bind(),t.geometryImage.activate(),t.vectorImage.activate(),t.maskVectorImage.activate(),e.removeColorBuffer(0),e.removeColorBuffer(2),e.removeColorBuffer(3),e.setColorBuffer(t.geometryImage,0),e.setColorBuffer(t.vectorImage,2),e.setColorBuffer(t.maskVectorImage,3),e.setDepthBuffer(t.depthTexture);const n=t.context;n.drawBuffers([n.COLOR_ATTACHMENT0,n.NONE,n.COLOR_ATTACHMENT2,n.COLOR_ATTACHMENT3]),n.viewport(0,0,...t.size),n.scissor(0,0,...t.size),n.disable(n.BLEND),n.disable(n.DEPTH_TEST),n.disable(n.SCISSOR_TEST),n.clearColor(0,0,0,0),n.clear(n.DEPTH_BUFFER_BIT|n.COLOR_BUFFER_BIT)},e.copyToScreen=n=>{t.RGBColorImage.activate(),t.depthTexture.activate(),t.licCopyPass||e.initializeResources();const r=t.licCopyPass;t._openGLRenderWindow.getShaderCache().readyShaderProgram(r);const o=t.context;o.viewport(0,0,...n),o.scissor(0,0,...n),o.disable(o.BLEND),o.enable(o.DEPTH_TEST),o.disable(o.SCISSOR_TEST),r.setUniformi("texDepth",t.depthTexture.getTextureUnit()),r.setUniformi("texRGBColors",t.RGBColorImage.getTextureUnit()),e.renderQuad(n,r),t.RGBColorImage.deactivate(),t.depthTexture.deactivate()},e.combineColorsAndLIC=()=>{const n=t.context,r=t.framebuffer;r.saveCurrentBindingsAndBuffers(),r.bind(),r.create(...t.size),r.removeColorBuffer(0),r.removeColorBuffer(1),r.setColorBuffer(t.RGBColorImage,0),r.setColorBuffer(t.HSLColorImage,1),n.drawBuffers([n.COLOR_ATTACHMENT0,n.COLOR_ATTACHMENT1]),n.disable(n.DEPTH_TEST),n.clearColor(0,0,0,0),n.clear(n.COLOR_BUFFER_BIT),t.vectorImage.activate(),t.geometryImage.activate(),t.LICImage.activate(),t.licColorPass||e.initializeResources();const o=t.licColorPass;t._openGLRenderWindow.getShaderCache().readyShaderProgram(o),o.setUniformi("texVectors",t.vectorImage.getTextureUnit()),o.setUniformi("texGeomColors",t.geometryImage.getTextureUnit());const{colorMode:a,LICIntensity:i,mapModeBias:s,maskIntensity:l,maskColor:c,enhanceContrast:u,lowColorContrastEnhancementFactor:d,highColorContrastEnhancementFactor:p}=t.licInterface.get("colorMode","LICIntensity","mapModeBias","maskIntensity","maskColor","enhanceContrast","lowColorContrastEnhancementFactor","highColorContrastEnhancementFactor");if(o.setUniformi("texLIC",t.LICImage.getTextureUnit()),o.setUniformi("uScalarColorMode",a),o.setUniformf("uLICIntensity",i),o.setUniformf("uMapBias",s),o.setUniformf("uMaskIntensity",l),o.setUniform3f("uMaskColor",...c),e.renderQuad(t.size,o),t.vectorImage.deactivate(),t.geometryImage.deactivate(),t.LICImage.deactivate(),r.removeColorBuffer(0),r.removeColorBuffer(1),n.drawBuffers([n.NONE]),u===jf||u===Kf){let o=0,a=1,i=a-o;o+=i*d,a-=i*p,i=a-o,r.setColorBuffer(t.RGBColorImage),n.drawBuffers([n.COLOR_ATTACHMENT0]),t.geometryImage.activate(),t.HSLColorImage.activate(),t.LICImage.activate(),t.enhanceContrastPass||e.initializeResources();const{enhanceContrastPass:s}=t;t._openGLRenderWindow.getShaderCache().readyShaderProgram(s),s.setUniformi("texGeomColors",t.geometryImage.getTextureUnit()),s.setUniformi("texHSLColors",t.HSLColorImage.getTextureUnit()),s.setUniformi("texLIC",t.LICImage.getTextureUnit()),s.setUniformf("uLMin",o),s.setUniformf("uLMaxMinDiff",i),e.renderQuad(t.size,s),t.geometryImage.deactivate(),t.HSLColorImage.deactivate(),t.LICImage.deactivate(),r.removeColorBuffer(0),n.drawBuffers([n.NONE])}r.restorePreviousBindingsAndBuffers()},e.applyLIC=()=>{const e=t.licInterface.get("stepSize","numberOfSteps","enhancedLIC","enhanceContrast","lowLICContrastEnhancementFactor","highLICContrastEnhancementFactor","antiAlias","normalizeVectors","maskThreshold","transformVectors"),n=t.licHelper.executeLIC(t.size,t.vectorImage,t.maskVectorImage,t.noiseTexture,t._openGLRenderWindow,e);if(!n)return console.error("Failed to compute image LIC"),void(t.LICImage=null);t.LICImage=n},e.setSize=n=>{Array.isArray(n)&&2===n.length&&(t.size&&t.size[0]===n[0]&&t.size[1]===n[1]||(t.size=n,e.releaseGraphicsResources()))},e.releaseGraphicsResources=()=>{t.geometryImage&&(t.geometryImage.releaseGraphicsResources(),t.geometryImage=null),t.vectorImage&&(t.vectorImage.releaseGraphicsResources(),t.vectorImage=null),t.maskVectorImage&&(t.maskVectorImage.releaseGraphicsResources(),t.maskVectorImage=null),t.LICImage&&(t.LICImage.releaseGraphicsResources(),t.LICImage=null),t.RGBColorImage&&(t.RGBColorImage.releaseGraphicsResources(),t.RGBColorImage=null),t.HSLColorImage&&(t.HSLColorImage.releaseGraphicsResources(),t.HSLColorImage=null),t.depthTexture&&(t.depthTexture.releaseGraphicsResources(),t.depthTexture=null),t.framebuffer&&(t.framebuffer.releaseGraphicsResources(),t.framebuffer=null)}}(e,t)}var rg={newInstance:Ht.newInstance(ng,"vtkSurfaceLICInterface"),extend:ng};const{vtkErrorMacro:og}=jt,ag={canDrawLIC:!1,rebuildLICShaders:!1,rebuildLICBuffers:!1,openGLLicInterface:null};const ig=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ag,n),Td.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkOpenGLSurfaceLICMapper");const n={...e};e.getNeedToRebuildShaders=(e,r,o)=>t.rebuildLICShaders||n.getNeedToRebuildShaders(e,r,o),e.replaceShaderValues=(e,r,o)=>{const a=t.lastBoundBO.getReferenceByName("lastLightComplexity");let i=e.Vertex,s=e.Fragment;const l=t.renderable.getInputArrayToProcess(0);if(l&&t.canDrawLIC){s=wu.substitute(s,"//VTK::Output::Dec",["//VTK::Output::Dec","layout(location = 2) out vec4 vectorTexture;","layout(location = 3) out vec4 maskVectorTexture;"]).result;const n=`${l.getName()}MC`;0===a&&t.lastBoundBO.set({lastLightComplexity:1},!0),i=wu.substitute(i,"//VTK::TCoord::Dec",[`attribute vec3 ${n};`,"out vec3 licOutput;","//VTK::TCoord::Dec"]).result,i=wu.substitute(i,"//VTK::TCoord::Impl",[`licOutput = ${n};`,"//VTK::TCoord::Impl"]).result,s=wu.substitute(s,"//VTK::TCoord::Dec",["uniform int uMaskOnSurface;","uniform mat3 normalMatrix;","in vec3 licOutput;","//VTK::TCoord::Dec"]).result,s=wu.substitute(s,"//VTK::TCoord::Impl",["// projected vectors","  vec3 tcoordLIC = normalMatrix * licOutput;","  vec3 normN = normalize(normalVCVSOutput);","  float k = dot(tcoordLIC, normN);","  vec3 projected = (tcoordLIC - k*normN);","  vectorTexture = vec4(projected.x, projected.y, 0.0 , 1.0);","// vectors for fragment masking","  if (uMaskOnSurface == 0)","    {","    maskVectorTexture = vec4(licOutput, 1.0);","    }","  else","    {","    maskVectorTexture = vec4(projected.x, projected.y, 0.0 , 1.0);","    }","//VTK::TCoord::Impl"],!1).result,e.Vertex=i}t.rebuildLICShaders=!1,e.Fragment=s,n.replaceShaderValues(e,r,o),a>0&&t.lastBoundBO.set({lastLightComplexity:a},!0)},e.setMapperShaderParameters=(e,r,o)=>{n.setMapperShaderParameters(e,r,o),t.canDrawLIC&&e.getProgram().setUniformi("uMaskOnSurface",t.maskOnSurface)},e.getNeedToRebuildBufferObjects=(e,r)=>t.rebuildLICBuffers||n.getNeedToRebuildBufferObjects(e,r),e.buildBufferObjects=(e,r)=>{if(t.canDrawLIC){const e=t.renderable.getInputArrayToProcess(0);e&&e.getNumberOfComponents()>1&&t.renderable.setCustomShaderAttributes([e.getName()])}t.rebuildLICBuffers=!1,n.buildBufferObjects(e,r)},e.pushState=e=>{t.stateCache={[e.BLEND]:e.isEnabled(e.BLEND),[e.DEPTH_TEST]:e.isEnabled(e.DEPTH_TEST),[e.SCISSOR_TEST]:e.isEnabled(e.SCISSOR_TEST),[e.CULL_FACE]:e.isEnabled(e.CULL_FACE)}},e.popState=e=>{const n=n=>t.stateCache[n]?e.enable(n):e.disable(n);n(e.BLEND),n(e.DEPTH_TEST),n(e.SCISSOR_TEST),n(e.CULL_FACE)},e.renderPiece=(r,o)=>{let a=!0;t._openGLRenderWindow.getWebgl2()||(og("SurfaceLICMapper Requires WebGL 2"),a=!1),t.context.getExtension("EXT_color_buffer_float")&&t.context.getExtension("OES_texture_float_linear")||(og("SurfaceLICMapper requires the EXT_color_buffer_float and OES_texture_float_linear WebGL2 extensions."),a=!1),t.currentInput=t.renderable.getInputData(),t.currentInput||(og("No input"),a=!1);let i=t.renderable.getLicInterface();i||(i=Jf.newInstance(),t.renderable.setLicInterface(i)),t.openGLLicInterface||(t.openGLLicInterface=rg.newInstance()),i!==t.openGLLicInterface.getLicInterface()&&t.openGLLicInterface.setLicInterface(i);const s=t.renderable.getInputArrayToProcess(0);if(i.getEnableLIC()&&(!s||s.getNumberOfComponents()<2)&&(og("No vector input array"),a=!1),i.getEnableLIC()||(a=!1),t.canDrawLIC!==a&&(t.rebuildLICShaders=!0,t.rebuildLICBuffers=!0),t.canDrawLIC=a,!a||!i.getEnableLIC())return void n.renderPiece(r,o);const l=t.context,c=o.getProperty().getBackfaceCulling(),u=o.getProperty().getFrontfaceCulling();c||u?u?(t._openGLRenderWindow.enableCullFace(),l.cullFace(l.FRONT)):(t._openGLRenderWindow.enableCullFace(),l.cullFace(l.BACK)):t._openGLRenderWindow.disableCullFace();const d=t._openGLRenderWindow.getSize(),p=d.map((e=>Math.round(e*i.getViewPortScale())));t.openGLLicInterface.setSize(p),t.openGLLicInterface.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLLicInterface.setContext(t.context),e.pushState(t.context),t.openGLLicInterface.initializeResources(),t.openGLLicInterface.prepareForGeometry(),e.popState(t.context),n.renderPieceStart(r,o),n.renderPieceDraw(r,o),n.renderPieceFinish(r,o),e.pushState(t.context),t.VBOBuildTime.modified(),t.openGLLicInterface.completedGeometry(),t.context.disable(t.context.CULL_FACE),t.openGLLicInterface.applyLIC(),t.openGLLicInterface.combineColorsAndLIC(),t.openGLLicInterface.copyToScreen(d),e.popState(t.context)}}(e,t),St(e,t,["openGLLicInterface"])}),"vtkOpenGLSurfaceLICMapper");en("vtkSurfaceLICMapper",ig);const{vtkErrorMacro:sg}=jt,lg={};const cg=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,lg,n),Td.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkOpenGLSphereMapper");const n={...e};e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkSphereMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// this shader implements imposters in OpenGL for Spheres\n\nattribute vec4 vertexMC;\nattribute vec2 offsetMC;\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n//VTK::Picking::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\nuniform mat3 normalMatrix; // transform model coordinate directions to view coordinates\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvarying vec4 vertexVCVSOutput;\nvarying float radiusVCVSOutput;\nvarying vec3 centerVCVSOutput;\n\nuniform int cameraParallel;\nuniform float scaleFactor;\n\nvoid main()\n{\n  //VTK::Picking::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  // compute the projected vertex position\n  vec2 scaledOffsetMC = scaleFactor * offsetMC;\n  vertexVCVSOutput = MCVCMatrix * vertexMC;\n  centerVCVSOutput = vertexVCVSOutput.xyz;\n  radiusVCVSOutput = length(scaledOffsetMC)*0.5;\n\n  // make the triangle face the camera\n  if (cameraParallel == 0)\n    {\n    vec3 dir = normalize(-vertexVCVSOutput.xyz);\n    vec3 base2 = normalize(cross(dir,vec3(1.0,0.0,0.0)));\n    vec3 base1 = cross(base2,dir);\n    vertexVCVSOutput.xyz = vertexVCVSOutput.xyz + scaledOffsetMC.x*base1 + scaledOffsetMC.y*base2;\n    }\n  else\n    {\n    // add in the offset\n    vertexVCVSOutput.xy = vertexVCVSOutput.xy + scaledOffsetMC;\n    }\n\n  gl_Position = VCPCMatrix * vertexVCVSOutput;\n}\n",e.Fragment=td,e.Geometry=""},e.replaceShaderValues=(e,r,o)=>{let a=e.Vertex,i=e.Fragment;a=wu.substitute(a,"//VTK::Camera::Dec",["uniform mat4 VCPCMatrix;\n","uniform mat4 MCVCMatrix;"]).result,i=wu.substitute(i,"//VTK::PositionVC::Dec",["varying vec4 vertexVCVSOutput;"]).result,i=wu.substitute(i,"//VTK::PositionVC::Impl",["vec4 vertexVC = vertexVCVSOutput;\n"]).result,i=wu.substitute(i,"//VTK::Normal::Dec",["uniform float invertedDepth;\n","uniform int cameraParallel;\n","varying float radiusVCVSOutput;\n","varying vec3 centerVCVSOutput;\n","uniform mat4 VCPCMatrix;\n"]).result;let s="";t.context.getExtension("EXT_frag_depth")&&(s="gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\n"),t._openGLRenderWindow.getWebgl2()&&(s="gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\n"),i=wu.substitute(i,"//VTK::Depth::Impl",["  vec3 EyePos;\n","  vec3 EyeDir;\n","  if (cameraParallel != 0) {\n","    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\n","    EyeDir = vec3(0.0,0.0,-1.0); }\n","  else {\n","    EyeDir = vertexVC.xyz;\n","    EyePos = vec3(0.0,0.0,0.0);\n","    float lengthED = length(EyeDir);\n","    EyeDir = normalize(EyeDir);\n","    if (lengthED > radiusVCVSOutput*3.0) {\n","      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\n","    }\n","  EyePos = EyePos - centerVCVSOutput;\n","  EyePos = EyePos/radiusVCVSOutput;\n","  float b = 2.0*dot(EyePos,EyeDir);\n","  float c = dot(EyePos,EyePos) - 1.0;\n","  float d = b*b - 4.0*c;\n","  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\n","  if (d < 0.0) { discard; }\n","  else {\n","    float t = (-b - invertedDepth*sqrt(d))*0.5;\n","    normalVCVSOutput = invertedDepth*normalize(EyePos + t*EyeDir);\n","    vertexVC.xyz = normalVCVSOutput*radiusVCVSOutput + centerVCVSOutput;\n","    }\n","  vec4 pos = VCPCMatrix * vertexVC;\n",s]).result,i=wu.substitute(i,"//VTK::Normal::Impl","").result,t.haveSeenDepthRequest&&(i=wu.substitute(i,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float computedZ = (pos.z / pos.w + 1.0) / 2.0;","float iz = floor(computedZ * 65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),e.Vertex=a,e.Fragment=i,n.replaceShaderValues(e,r,o)},e.setMapperShaderParameters=(e,r,o)=>{if(e.getCABO().getElementCount()&&(t.VBOBuildTime>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())&&e.getProgram().isAttributeUsed("offsetMC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"offsetMC",12,e.getCABO().getStride(),t.context.FLOAT,2,!1)||sg("Error setting 'offsetMC' in shader VAO.")),e.getProgram().isUniformUsed("invertedDepth")&&e.getProgram().setUniformf("invertedDepth",t.invert?-1:1),e.getProgram().isUniformUsed("scaleFactor")){const n=t.currentInput.getPointData();null!=t.renderable.getScaleArray()&&n.hasArray(t.renderable.getScaleArray())?e.getProgram().setUniformf("scaleFactor",t.renderable.getScaleFactor()):e.getProgram().setUniformf("scaleFactor",1)}n.setMapperShaderParameters(e,r,o)},e.setCameraShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=n.getActiveCamera(),i=t.openGLCamera.getKeyMatrices(n);o.isUniformUsed("VCPCMatrix")&&o.setUniformMatrix("VCPCMatrix",i.vcpc);const s=new Float64Array(16);if(o.isUniformUsed("MCVCMatrix"))if(r.getIsIdentity())d(s,i.wcvc),e.getCABO().getCoordShiftAndScaleEnabled()&&y(s,s,e.getCABO().getInverseShiftAndScaleMatrix()),o.setUniformMatrix("MCVCMatrix",s);else{const n=t.openGLActor.getKeyMatrices();y(s,i.wcvc,n.mcwc),e.getCABO().getCoordShiftAndScaleEnabled()&&y(s,s,e.getCABO().getInverseShiftAndScaleMatrix()),o.setUniformMatrix("MCVCMatrix",s)}o.isUniformUsed("cameraParallel")&&e.getProgram().setUniformi("cameraParallel",a.getParallelProjection())},e.getOpenGLMode=(e,n)=>t.context.TRIANGLES,e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors(),a=t.primitives[t.primTypes.Tris].getCABO(),i=r.getPointData(),s=r.getPoints(),l=s.getNumberOfPoints(),c=s.getData();let u=null;null!=t.renderable.getScaleArray()&&i.hasArray(t.renderable.getScaleArray())&&(u=i.getArray(t.renderable.getScaleArray()).getData());let d=null,p=0,f=null;o?(p=o.getNumberOfComponents(),a.setColorOffset(0),a.setColorBOStride(4),d=o.getData(),f=new Uint8Array(3*l*4),a.getColorBO()||a.setColorBO(fu.newInstance()),a.getColorBO().setOpenGLRenderWindow(t._openGLRenderWindow)):a.getColorBO()&&a.setColorBO(null),a.setColorComponents(p);const g=new Float32Array(5*l*3);a.setStride(20);const m=Math.cos(yo(30));let h=0,v=0;const{useShiftAndScale:T,coordShift:y,coordScale:b}=gu(s);T&&a.setCoordShiftAndScale(y,b);let x=0,C=0;for(let e=0;e<l;++e){let n=t.renderable.getRadius();u&&(n=u[e]),h=3*e;const r=(c[h++]-y[0])*b[0],o=(c[h++]-y[1])*b[1],a=(c[h++]-y[2])*b[2];g[x++]=r,g[x++]=o,g[x++]=a,g[x++]=-2*n*m,g[x++]=-n,d&&(v=e*p,f[C++]=d[v],f[C++]=d[v+1],f[C++]=d[v+2],f[C++]=d[v+3]),g[x++]=r,g[x++]=o,g[x++]=a,g[x++]=2*n*m,g[x++]=-n,d&&(f[C++]=d[v],f[C++]=d[v+1],f[C++]=d[v+2],f[C++]=d[v+3]),g[x++]=r,g[x++]=o,g[x++]=a,g[x++]=0,g[x++]=2*n,d&&(f[C++]=d[v],f[C++]=d[v+1],f[C++]=d[v+2],f[C++]=d[v+3])}a.setElementCount(x/5),a.upload(g,lu.ARRAY_BUFFER),o&&a.getColorBO().upload(f,lu.ARRAY_BUFFER),t.VBOBuildTime.modified()}}(e,t)}),"vtkOpenGLSphereMapper");en("vtkSphereMapper",cg);const{vtkErrorMacro:ug}=jt,dg={};const pg=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,dg,n),Td.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkOpenGLStickMapper");const n={...e};e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkStickMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// this shader implements imposters in OpenGL for Sticks\n\nattribute vec4 vertexMC;\nattribute vec3 orientMC;\nattribute vec4 offsetMC;\nattribute float radiusMC;\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n//VTK::Picking::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\nuniform mat3 normalMatrix; // transform model coordinate directions to view coordinates\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvarying vec4 vertexVCVSOutput;\nvarying float radiusVCVSOutput;\nvarying float lengthVCVSOutput;\nvarying vec3 centerVCVSOutput;\nvarying vec3 orientVCVSOutput;\n\nuniform int cameraParallel;\n\nvoid main()\n{\n  //VTK::Picking::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  vertexVCVSOutput = MCVCMatrix * vertexMC;\n  centerVCVSOutput = vertexVCVSOutput.xyz;\n  radiusVCVSOutput = radiusMC;\n  lengthVCVSOutput = length(orientMC);\n  orientVCVSOutput = normalMatrix * normalize(orientMC);\n\n  // make sure it is pointing out of the screen\n  if (orientVCVSOutput.z < 0.0)\n    {\n    orientVCVSOutput = -orientVCVSOutput;\n    }\n\n  // make the basis\n  vec3 xbase;\n  vec3 ybase;\n  vec3 dir = vec3(0.0,0.0,1.0);\n  if (cameraParallel == 0)\n    {\n    dir = normalize(-vertexVCVSOutput.xyz);\n    }\n  if (abs(dot(dir,orientVCVSOutput)) == 1.0)\n    {\n    xbase = normalize(cross(vec3(0.0,1.0,0.0),orientVCVSOutput));\n    ybase = cross(xbase,orientVCVSOutput);\n    }\n  else\n    {\n    xbase = normalize(cross(orientVCVSOutput,dir));\n    ybase = cross(orientVCVSOutput,xbase);\n    }\n\n  vec3 offsets = offsetMC.xyz*2.0-1.0;\n  vertexVCVSOutput.xyz = vertexVCVSOutput.xyz +\n    radiusVCVSOutput*offsets.x*xbase +\n    radiusVCVSOutput*offsets.y*ybase +\n    0.5*lengthVCVSOutput*offsets.z*orientVCVSOutput;\n\n  gl_Position = VCPCMatrix * vertexVCVSOutput;\n}\n",e.Fragment=td,e.Geometry=""},e.replaceShaderValues=(e,r,o)=>{let a=e.Vertex,i=e.Fragment;a=wu.substitute(a,"//VTK::Camera::Dec",["uniform mat4 VCPCMatrix;\n","uniform mat4 MCVCMatrix;"]).result,i=wu.substitute(i,"//VTK::PositionVC::Dec","varying vec4 vertexVCVSOutput;").result,i=wu.substitute(i,"//VTK::PositionVC::Impl","  vec4 vertexVC = vertexVCVSOutput;\n").result,i=wu.substitute(i,"//VTK::Normal::Dec",["uniform int cameraParallel;\n","varying float radiusVCVSOutput;\n","varying vec3 orientVCVSOutput;\n","varying float lengthVCVSOutput;\n","varying vec3 centerVCVSOutput;\n","uniform mat4 VCPCMatrix;\n"]).result;let s="";t.context.getExtension("EXT_frag_depth")&&(s="  gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\n"),t._openGLRenderWindow.getWebgl2()&&(s="gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\n"),i=wu.substitute(i,"//VTK::Depth::Impl",["  vec3 EyePos;\n","  vec3 EyeDir;\n","  if (cameraParallel != 0) {\n","    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\n","    EyeDir = vec3(0.0,0.0,-1.0); }\n","  else {\n","    EyeDir = vertexVC.xyz;\n","    EyePos = vec3(0.0,0.0,0.0);\n","    float lengthED = length(EyeDir);\n","    EyeDir = normalize(EyeDir);\n","    if (lengthED > radiusVCVSOutput*3.0) {\n","      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\n","    }\n","  EyePos = EyePos - centerVCVSOutput;\n","  vec3 base1;\n","  if (abs(orientVCVSOutput.z) < 0.99) {\n","    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,0.0,1.0))); }\n","  else {\n","    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,1.0,0.0))); }\n","  vec3 base2 = cross(orientVCVSOutput,base1);\n","  EyePos = vec3(dot(EyePos,base1),dot(EyePos,base2),dot(EyePos,orientVCVSOutput));\n","  EyeDir = vec3(dot(EyeDir,base1),dot(EyeDir,base2),dot(EyeDir,orientVCVSOutput));\n","  EyePos = EyePos/radiusVCVSOutput;\n","  float a = EyeDir.x*EyeDir.x + EyeDir.y*EyeDir.y;\n","  float b = 2.0*(EyePos.x*EyeDir.x + EyePos.y*EyeDir.y);\n","  float c = EyePos.x*EyePos.x + EyePos.y*EyePos.y - 1.0;\n","  float d = b*b - 4.0*a*c;\n","  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\n","  if (d < 0.0) { discard; }\n","  else {\n","    float t =  (-b - sqrt(d))/(2.0*a);\n","    float tz = EyePos.z + t*EyeDir.z;\n","    vec3 iPoint = EyePos + t*EyeDir;\n","    if (abs(iPoint.z)*radiusVCVSOutput > lengthVCVSOutput*0.5) {\n","      float t2 = (-b + sqrt(d))/(2.0*a);\n","      float tz2 = EyePos.z + t2*EyeDir.z;\n","      if (tz2*radiusVCVSOutput > lengthVCVSOutput*0.5 || tz*radiusVCVSOutput < -0.5*lengthVCVSOutput) { discard; }\n","      else {\n","        normalVCVSOutput = orientVCVSOutput;\n","        float t3 = (lengthVCVSOutput*0.5/radiusVCVSOutput - EyePos.z)/EyeDir.z;\n","        iPoint = EyePos + t3*EyeDir;\n","        vertexVC.xyz = radiusVCVSOutput*(iPoint.x*base1 + iPoint.y*base2 + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\n","        }\n","      }\n","    else {\n","      normalVCVSOutput = iPoint.x*base1 + iPoint.y*base2;\n","      vertexVC.xyz = radiusVCVSOutput*(normalVCVSOutput + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\n","      }\n","    }\n","  vec4 pos = VCPCMatrix * vertexVC;\n",s]).result,i=wu.substitute(i,"//VTK::Normal::Impl","").result,t.haveSeenDepthRequest&&(i=wu.substitute(i,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float computedZ = (pos.z / pos.w + 1.0) / 2.0;","float iz = floor(computedZ * 65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),e.Vertex=a,e.Fragment=i,n.replaceShaderValues(e,r,o)},e.setMapperShaderParameters=(e,r,o)=>{e.getCABO().getElementCount()&&(t.VBOBuildTime>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())&&(e.getProgram().isAttributeUsed("orientMC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"orientMC",12,e.getCABO().getStride(),t.context.FLOAT,3,!1)||ug("Error setting 'orientMC' in shader VAO.")),e.getProgram().isAttributeUsed("offsetMC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO().getColorBO(),"offsetMC",0,e.getCABO().getColorBOStride(),t.context.UNSIGNED_BYTE,3,!0)||ug("Error setting 'offsetMC' in shader VAO.")),e.getProgram().isAttributeUsed("radiusMC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"radiusMC",24,e.getCABO().getStride(),t.context.FLOAT,1,!1)||ug("Error setting 'radiusMC' in shader VAO."))),n.setMapperShaderParameters(e,r,o)},e.setCameraShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=n.getActiveCamera(),i=t.openGLCamera.getKeyMatrices(n);if(o.isUniformUsed("VCPCMatrix")&&o.setUniformMatrix("VCPCMatrix",i.vcpc),r.getIsIdentity())o.isUniformUsed("MCVCMatrix")&&o.setUniformMatrix("MCVCMatrix",i.wcvc),o.isUniformUsed("normalMatrix")&&o.setUniformMatrix3x3("normalMatrix",i.normalMatrix);else{const e=t.openGLActor.getKeyMatrices();if(o.isUniformUsed("MCVCMatrix")){const t=new Float64Array(16);y(t,i.wcvc,e.mcwc),o.setUniformMatrix("MCVCMatrix",t)}if(o.isUniformUsed("normalMatrix")){const t=new Float64Array(9);ve(t,i.normalMatrix,e.normalMatrix),o.setUniformMatrix3x3("normalMatrix",t)}}o.isUniformUsed("cameraParallel")&&e.getProgram().setUniformi("cameraParallel",a.getParallelProjection())},e.getOpenGLMode=(e,n)=>t.context.TRIANGLES,e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors(),a=t.primitives[t.primTypes.Tris].getCABO(),i=r.getPointData(),s=r.getPoints(),l=s.getNumberOfPoints(),c=s.getData();let u=3;u+=4;let d=null,p=0;a.setColorBOStride(4),a.getColorBO()||a.setColorBO(fu.newInstance()),a.getColorBO().setOpenGLRenderWindow(t._openGLRenderWindow),o&&(p=o.getNumberOfComponents(),a.setColorOffset(4),d=o.getData(),a.setColorBOStride(8)),a.setColorComponents(p),a.setStride(28);const f=new Float32Array(7*l*12),g=new Uint8Array(12*l*(d?8:4));let m=null,h=null;null!=t.renderable.getScaleArray()&&i.hasArray(t.renderable.getScaleArray())&&(m=i.getArray(t.renderable.getScaleArray()).getData()),null!=t.renderable.getOrientationArray()&&i.hasArray(t.renderable.getOrientationArray())?h=i.getArray(t.renderable.getOrientationArray()).getData():ug(["Error setting orientationArray.\n","You have to specify the stick orientation"]);const v=[0,1,3,0,3,2,2,3,5,2,5,4];let T=0,y=0,b=0,x=0;for(let e=0;e<l;++e){let n=t.renderable.getLength(),r=t.renderable.getRadius();m&&(n=m[2*e],r=m[2*e+1]);for(let t=0;t<v.length;++t)T=3*e,f[b++]=c[T++],f[b++]=c[T++],f[b++]=c[T++],T=3*e,f[b++]=h[T++]*n,f[b++]=h[T++]*n,f[b++]=h[T++]*n,f[b++]=r,g[x++]=v[t]%2*255,g[x++]=v[t]>=4?255:0,g[x++]=v[t]>=2?255:0,g[x++]=255,y=e*p,d&&(g[x++]=d[y],g[x++]=d[y+1],g[x++]=d[y+2],g[x++]=d[y+3])}a.setElementCount(b/7),a.upload(f,lu.ARRAY_BUFFER),a.getColorBO().upload(g,lu.ARRAY_BUFFER),t.VBOBuildTime.modified()}}(e,t)}),"vtkOpenGLStickMapper");en("vtkStickMapper",pg);const fg=[];fg["-".charCodeAt(0)]=62,fg["_".charCodeAt(0)]=63;const gg="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";for(let e=0;e<64;e++)fg[gg.charCodeAt(e)]=e;function mg(e){return void 0!==fg[e.charCodeAt(0)]}function hg(e,t,n,r){const{start:o,count:a}=t,i=a%4,s=Math.floor(a/4);let l=o,c=null,u=n;for(let t=0;t<s;t++){for(;!mg(e[l]);)l++;for(c=fg[e.charCodeAt(l++)]<<18;!mg(e[l]);)l++;for(c|=fg[e.charCodeAt(l++)]<<12;!mg(e[l]);)l++;for(c|=fg[e.charCodeAt(l++)]<<6;!mg(e[l]);)l++;c|=fg[e.charCodeAt(l++)],r[u++]=c>>16&255,r[u++]=c>>8&255,r[u++]=255&c}switch(i){case 3:for(;!mg(e[l]);)l++;for(c=fg[e.charCodeAt(l++)]<<10;!mg(e[l]);)l++;for(c|=fg[e.charCodeAt(l++)]<<4;!mg(e[l]);)l++;c|=fg[e.charCodeAt(l++)]>>2,r[u++]=c>>8&255,r[u++]=255&c;break;case 2:for(;!mg(e[l]);)l++;for(c=fg[e.charCodeAt(l++)]<<2;!mg(e[l]);)l++;c|=fg[e.charCodeAt(l++)]>>4,r[u++]=255&c;break;case 1:throw new Error("BASE64: remain 1 should not happen")}return u}function vg(e,t,n){const r=(e<<16)+(t<<8)+n;return gg[r>>18]+gg[r>>12&63]+gg[r>>6&63]+gg[63&r]}function Tg(e){const t=new Uint8Array(e),n=e.byteLength%3,r=e.byteLength-n,o=Array(r/3);for(let e=0;e<o.length;e++){const n=3*e;o[e]=vg(t[n],t[n+1],t[n+2])}if(n>0){const e=vg(t[r],t[r+1]||0,t[r+2]||0);1===n?o.push(`${e.substr(0,2)}==`):2===n&&o.push(`${e.substr(0,3)}=`)}return o.join("")}var yg={toArrayBuffer:function(e){const t=function(e){const t=e.length,n=[];let r=null;for(let o=0;o<t;o++)mg(e[o])?(r||(r={start:o,count:0}),r.count++,r.end=o):"="===e[o]&&r&&(n.push(r),r=null);return r&&n.push(r),n}(e),n=t[t.length-1].end+1,r=(4-n%4)%4,o=new ArrayBuffer(3*(n+r)/4-r),a=new Uint8Array(o);let i=0;for(let n=0;n<t.length;n++)i+=hg(e,t[n],i,a),i+=(4-t[n].count%4)%4;return o},fromArrayBuffer:Tg};const bg={};function xg(e,t){bg[e]=t}var Cg={get:function(){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return bg[arguments.length>0&&void 0!==arguments[0]?arguments[0]:"http"](e)},has:function(e){return!!bg[e]},registerType:xg},Sg=Uint8Array,Ag=Uint16Array,Ig=Uint32Array,wg=new Sg([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),Og=new Sg([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),Pg=new Sg([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Rg=function(e,t){for(var n=new Ag(31),r=0;r<31;++r)n[r]=t+=1<<e[r-1];var o=new Ig(n[30]);for(r=1;r<30;++r)for(var a=n[r];a<n[r+1];++a)o[a]=a-n[r]<<5|r;return[n,o]},Mg=Rg(wg,2),Eg=Mg[0],Vg=Mg[1];Eg[28]=258,Vg[258]=28;for(var Dg=Rg(Og,0),Lg=Dg[0],Bg=(Dg[1],new Ag(32768)),Ng=0;Ng<32768;++Ng){var Fg=(43690&Ng)>>>1|(21845&Ng)<<1;Fg=(61680&(Fg=(52428&Fg)>>>2|(13107&Fg)<<2))>>>4|(3855&Fg)<<4,Bg[Ng]=((65280&Fg)>>>8|(255&Fg)<<8)>>>1}var _g=function(e,t,n){for(var r=e.length,o=0,a=new Ag(t);o<r;++o)e[o]&&++a[e[o]-1];var i,s=new Ag(t);for(o=0;o<t;++o)s[o]=s[o-1]+a[o-1]<<1;if(n){i=new Ag(1<<t);var l=15-t;for(o=0;o<r;++o)if(e[o])for(var c=o<<4|e[o],u=t-e[o],d=s[e[o]-1]++<<u,p=d|(1<<u)-1;d<=p;++d)i[Bg[d]>>>l]=c}else for(i=new Ag(r),o=0;o<r;++o)e[o]&&(i[o]=Bg[s[e[o]-1]++]>>>15-e[o]);return i},kg=new Sg(288);for(Ng=0;Ng<144;++Ng)kg[Ng]=8;for(Ng=144;Ng<256;++Ng)kg[Ng]=9;for(Ng=256;Ng<280;++Ng)kg[Ng]=7;for(Ng=280;Ng<288;++Ng)kg[Ng]=8;var Gg=new Sg(32);for(Ng=0;Ng<32;++Ng)Gg[Ng]=5;var Ug=_g(kg,9,1),zg=_g(Gg,5,1),Wg=function(e){for(var t=e[0],n=1;n<e.length;++n)e[n]>t&&(t=e[n]);return t},Hg=function(e,t,n){var r=t/8|0;return(e[r]|e[r+1]<<8)>>(7&t)&n},jg=function(e,t){var n=t/8|0;return(e[n]|e[n+1]<<8|e[n+2]<<16)>>(7&t)},Kg=function(e,t,n){(null==t||t<0)&&(t=0),(null==n||n>e.length)&&(n=e.length);var r=new(2==e.BYTES_PER_ELEMENT?Ag:4==e.BYTES_PER_ELEMENT?Ig:Sg)(n-t);return r.set(e.subarray(t,n)),r},$g=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],qg=function(e,t,n){var r=new Error(t||$g[e]);if(r.code=e,Error.captureStackTrace&&Error.captureStackTrace(r,qg),!n)throw r;return r},Xg=function(e,t,n){var r=e.length;if(!r||n&&n.f&&!n.l)return t||new Sg(0);var o=!t||n,a=!n||n.i;n||(n={}),t||(t=new Sg(3*r));var i,s=function(e){var n=t.length;if(e>n){var r=new Sg(Math.max(2*n,e));r.set(t),t=r}},l=n.f||0,c=n.p||0,u=n.b||0,d=n.l,p=n.d,f=n.m,g=n.n,m=8*r;do{if(!d){l=Hg(e,c,1);var h=Hg(e,c+1,3);if(c+=3,!h){var v=e[(i=c,(P=4+((i+7)/8|0))-4)]|e[P-3]<<8,T=P+v;if(T>r){a&&qg(0);break}o&&s(u+v),t.set(e.subarray(P,T),u),n.b=u+=v,n.p=c=8*T,n.f=l;continue}if(1==h)d=Ug,p=zg,f=9,g=5;else if(2==h){var y=Hg(e,c,31)+257,b=Hg(e,c+10,15)+4,x=y+Hg(e,c+5,31)+1;c+=14;for(var C=new Sg(x),S=new Sg(19),A=0;A<b;++A)S[Pg[A]]=Hg(e,c+3*A,7);c+=3*b;var I=Wg(S),w=(1<<I)-1,O=_g(S,I,1);for(A=0;A<x;){var P,R=O[Hg(e,c,w)];if(c+=15&R,(P=R>>>4)<16)C[A++]=P;else{var M=0,E=0;for(16==P?(E=3+Hg(e,c,3),c+=2,M=C[A-1]):17==P?(E=3+Hg(e,c,7),c+=3):18==P&&(E=11+Hg(e,c,127),c+=7);E--;)C[A++]=M}}var V=C.subarray(0,y),D=C.subarray(y);f=Wg(V),g=Wg(D),d=_g(V,f,1),p=_g(D,g,1)}else qg(1);if(c>m){a&&qg(0);break}}o&&s(u+131072);for(var L=(1<<f)-1,B=(1<<g)-1,N=c;;N=c){var F=(M=d[jg(e,c)&L])>>>4;if((c+=15&M)>m){a&&qg(0);break}if(M||qg(2),F<256)t[u++]=F;else{if(256==F){N=c,d=null;break}var _=F-254;if(F>264){var k=wg[A=F-257];_=Hg(e,c,(1<<k)-1)+Eg[A],c+=k}var G=p[jg(e,c)&B],U=G>>>4;if(G||qg(3),c+=15&G,D=Lg[U],U>3&&(k=Og[U],D+=jg(e,c)&(1<<k)-1,c+=k),c>m){a&&qg(0);break}o&&s(u+131072);for(var z=u+_;u<z;u+=4)t[u]=t[u-D],t[u+1]=t[u+1-D],t[u+2]=t[u+2-D],t[u+3]=t[u+3-D];u=z}}n.l=d,n.p=N,n.b=u,n.f=l,d&&(l=1,n.m=f,n.d=p,n.n=g)}while(!l);return u==t.length?t:Kg(t,0,u)},Yg=new Sg(0),Zg=function(e,t){return e[t]|e[t+1]<<8},Qg=function(e,t){return(e[t]|e[t+1]<<8|e[t+2]<<16|e[t+3]<<24)>>>0},Jg=function(e,t){return Qg(e,t)+4294967296*Qg(e,t+4)};function em(e,t){return Xg(e,t)}function tm(e,t){return Xg(e.subarray(function(e){31==e[0]&&139==e[1]&&8==e[2]||qg(6,"invalid gzip data");var t=e[3],n=10;4&t&&(n+=e[10]|2+(e[11]<<8));for(var r=(t>>3&1)+(t>>4&1);r>0;r-=!e[n++]);return n+(2&t)}(e),-8),t||new Sg((r=(n=e).length,(n[r-4]|n[r-3]<<8|n[r-2]<<16|n[r-1]<<24)>>>0)));var n,r}function nm(e,t){return Xg(((8!=(15&(n=e)[0])||n[0]>>>4>7||(n[0]<<8|n[1])%31)&&qg(6,"invalid zlib data"),32&n[1]&&qg(6,"invalid zlib data: preset dictionaries not supported"),e.subarray(2,-4)),t);var n}function rm(e,t){return 31==e[0]&&139==e[1]&&8==e[2]?tm(e,t):8!=(15&e[0])||e[0]>>4>7||(e[0]<<8|e[1])%31?em(e,t):nm(e,t)}var om="undefined"!=typeof TextEncoder&&new TextEncoder,am="undefined"!=typeof TextDecoder&&new TextDecoder;try{am.decode(Yg,{stream:!0})}catch(e){}function im(e,t){if(t){for(var n="",r=0;r<e.length;r+=16384)n+=String.fromCharCode.apply(null,e.subarray(r,r+16384));return n}if(am)return am.decode(e);var o=function(e){for(var t="",n=0;;){var r=e[n++],o=(r>127)+(r>223)+(r>239);if(n+o>e.length)return[t,Kg(e,n-1)];o?3==o?(r=((15&r)<<18|(63&e[n++])<<12|(63&e[n++])<<6|63&e[n++])-65536,t+=String.fromCharCode(55296|r>>10,56320|1023&r)):t+=1&o?String.fromCharCode((31&r)<<6|63&e[n++]):String.fromCharCode((15&r)<<12|(63&e[n++])<<6|63&e[n++]):t+=String.fromCharCode(r)}}(e),a=o[0];return o[1].length&&qg(8),a}var sm=function(e,t){return t+30+Zg(e,t+26)+Zg(e,t+28)},lm=function(e,t,n){var r=Zg(e,t+28),o=im(e.subarray(t+46,t+46+r),!(2048&Zg(e,t+8))),a=t+46+r,i=Qg(e,t+20),s=n&&4294967295==i?cm(e,a):[i,Qg(e,t+24),Qg(e,t+42)],l=s[0],c=s[1],u=s[2];return[Zg(e,t+10),l,c,o,a+Zg(e,t+30)+Zg(e,t+32),u]},cm=function(e,t){for(;1!=Zg(e,t);t+=4+Zg(e,t+2));return[Jg(e,t+12),Jg(e,t+4),Jg(e,t+20)]};function um(e,t){for(var n={},r=e.length-22;101010256!=Qg(e,r);--r)(!r||e.length-r>65558)&&qg(13);var o=Zg(e,r+8);if(!o)return{};var a=Qg(e,r+16),i=4294967295==a;i&&(r=Qg(e,r-12),101075792!=Qg(e,r)&&qg(13),o=Qg(e,r+32),a=Qg(e,r+48));for(var s=t&&t.filter,l=0;l<o;++l){var c=lm(e,a,i),u=c[0],d=c[1],p=c[2],f=c[3],g=c[4],m=c[5],h=sm(e,m);a=g,s&&!s({name:f,size:d,originalSize:p,compression:u})||(u?8==u?n[f]=em(e.subarray(h,h+d),new Sg(p)):qg(14,"unknown compression type "+u):n[f]=Kg(e,h,h+d))}return n}function dm(){const e=new ArrayBuffer(4),t=new Uint8Array(e),n=new Uint32Array(e);return t[0]=161,t[1]=178,t[2]=195,t[3]=212,3569595041===n[0]?"LittleEndian":2712847316===n[0]?"BigEndian":null}"function"==typeof queueMicrotask?queueMicrotask:"function"==typeof setTimeout&&setTimeout;var pm=dm(),fm=function(e,t){if(t<2)return;const n=new Int8Array(e),r=n.length,o=[];for(let e=0;e<r;e+=t){for(let r=0;r<t;r++)o.push(n[e+r]);for(let r=0;r<t;r++)n[e+r]=o.pop()}};const{vtkErrorMacro:gm,vtkDebugMacro:mm}=Ht;let hm=0;function vm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=new XMLHttpRequest;return r.open(e,t,!0),n.headers&&Object.entries(n.headers).forEach((e=>{let[t,n]=e;return r.setRequestHeader(t,n)})),n.progressCallback&&r.addEventListener("progress",n.progressCallback),r}const Tm={fetchArray:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return n.ref&&!n.ref.pending?new Promise(((o,a)=>{let i=null;i=n.ref.url?n.ref.url:[t,n.ref.basepath,r.compression?`${n.ref.id}.gz`:n.ref.id].join("/");const s=vm("GET",i,r);s.onreadystatechange=t=>{1===s.readyState&&(n.ref.pending=!0,1==++hm&&e?.invokeBusy&&e.invokeBusy(!0)),4===s.readyState&&(n.ref.pending=!1,200===s.status||0===s.status?(n.buffer=s.response,r.compression&&("string"===n.dataType||"JSON"===n.dataType?n.buffer=im(rm(new Uint8Array(n.buffer))):n.buffer=rm(new Uint8Array(n.buffer)).buffer),"JSON"===n.ref.encode?n.values=JSON.parse(n.buffer):(pm!==n.ref.encode&&pm&&(mm(`Swap bytes of ${n.name}`),fm(n.buffer,as[n.dataType])),n.values=Ht.newTypedArray(n.dataType,n.buffer)),n.values.length!==n.size&&gm(`Error in FetchArray: ${n.name}, does not have the proper array size. Got ${n.values.length}, instead of ${n.size}`),delete n.ref,0==--hm&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),o(n)):a({xhr:s,e:t}))},s.responseType=r.compression||"string"!==n.dataType?"arraybuffer":"text",s.send()})):Promise.resolve(n)},fetchJSON:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return new Promise(((r,o)=>{const a=vm("GET",t,n);a.onreadystatechange=t=>{1===a.readyState&&1==++hm&&e?.invokeBusy&&e.invokeBusy(!0),4===a.readyState&&(0==--hm&&e?.invokeBusy&&e.invokeBusy(!1),200===a.status||0===a.status?n.compression?r(JSON.parse(im(rm(new Uint8Array(a.response))))):r(JSON.parse(a.responseText)):o({xhr:a,e:t}))},a.responseType=n.compression?"arraybuffer":"text",a.send()}))},fetchText:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return n&&n.compression&&"gz"!==n.compression&&(gm("Supported algorithms are: [gz]"),gm(`Unkown compression algorithm: ${n.compression}`)),new Promise(((r,o)=>{const a=vm("GET",t,n);a.onreadystatechange=t=>{1===a.readyState&&1==++hm&&e?.invokeBusy&&e.invokeBusy(!0),4===a.readyState&&(0==--hm&&e?.invokeBusy&&e.invokeBusy(!1),200===a.status||0===a.status?n.compression?r(im(rm(new Uint8Array(a.response)))):r(a.responseText):o({xhr:a,e:t}))},a.responseType=n.compression?"arraybuffer":"text",a.send()}))},fetchBinary:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return t&&t.compression&&"gz"!==t.compression&&(gm("Supported algorithms are: [gz]"),gm(`Unkown compression algorithm: ${t.compression}`)),new Promise(((n,r)=>{const o=vm("GET",e,t);o.onreadystatechange=e=>{4===o.readyState&&(200===o.status||0===o.status?t.compression?n(rm(new Uint8Array(o.response)).buffer):n(o.response):r({xhr:o,e:e}))},o.responseType="arraybuffer",o.send()}))},fetchImage:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return new Promise(((e,r)=>{const o=new Image;n.crossOrigin&&(o.crossOrigin=n.crossOrigin),o.onload=()=>e(o),o.onerror=r,o.src=t}))}};xg("http",(e=>Tm));const{vtkDebugMacro:ym}=Ht,bm={position:[0,0,1],focalPoint:[0,0,0],viewUp:[0,1,0],directionOfProjection:[0,0,-1],parallelProjection:!1,useHorizontalViewAngle:!1,viewAngle:30,parallelScale:1,clippingRange:[.01,1000.01],windowCenter:[0,0],viewPlaneNormal:[0,0,1],useOffAxisProjection:!1,screenBottomLeft:[-.5,-.5,-.5],screenBottomRight:[.5,-.5,-.5],screenTopRight:[.5,.5,-.5],freezeFocalPoint:!1,projectionMatrix:null,viewMatrix:null,cameraLightTransform:c(),physicalTranslation:[0,0,0],physicalScale:1,physicalViewUp:[0,1,0],physicalViewNorth:[0,0,-1]};function xm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bm,n),Ht.obj(e,t),Ht.get(e,t,["distance"]),Ht.setGet(e,t,["parallelProjection","useHorizontalViewAngle","viewAngle","parallelScale","useOffAxisProjection","freezeFocalPoint","physicalScale"]),Ht.getArray(e,t,["directionOfProjection","viewPlaneNormal","position","focalPoint"]),Ht.setGetArray(e,t,["clippingRange","windowCenter"],2),Ht.setGetArray(e,t,["viewUp","screenBottomLeft","screenBottomRight","screenTopRight","physicalTranslation","physicalViewUp","physicalViewNorth"],3),function(e,t){t.classHierarchy.push("vtkCamera");const n=new Float64Array(3),r=new Float64Array([0,0,-1]),o=new Float64Array([0,1,0]),a=g(new Float64Array(16)),i=g(new Float64Array(16)),s=new Float64Array(3),l=new Float64Array(3),c=new Float64Array(3),u=g(new Float64Array(16)),p=g(new Float64Array(16)),f=new Float64Array(3),v=new Float64Array(3);function T(){t.viewPlaneNormal[0]=-t.directionOfProjection[0],t.viewPlaneNormal[1]=-t.directionOfProjection[1],t.viewPlaneNormal[2]=-t.directionOfProjection[2]}e.orthogonalizeViewUp=()=>{const n=e.getViewMatrix();t.viewUp[0]=n[4],t.viewUp[1]=n[5],t.viewUp[2]=n[6],e.modified()},e.setPosition=(n,r,o)=>{n===t.position[0]&&r===t.position[1]&&o===t.position[2]||(t.position[0]=n,t.position[1]=r,t.position[2]=o,e.computeDistance(),e.modified())},e.setFocalPoint=(n,r,o)=>{n===t.focalPoint[0]&&r===t.focalPoint[1]&&o===t.focalPoint[2]||(t.focalPoint[0]=n,t.focalPoint[1]=r,t.focalPoint[2]=o,e.computeDistance(),e.modified())},e.setDistance=n=>{if(t.distance===n)return;t.distance=n,t.distance<1e-20&&(t.distance=1e-20,ym("Distance is set to minimum."));const r=t.directionOfProjection;t.focalPoint[0]=t.position[0]+r[0]*t.distance,t.focalPoint[1]=t.position[1]+r[1]*t.distance,t.focalPoint[2]=t.position[2]+r[2]*t.distance,e.modified()},e.computeDistance=()=>{const e=t.focalPoint[0]-t.position[0],n=t.focalPoint[1]-t.position[1],r=t.focalPoint[2]-t.position[2];if(t.distance=Math.sqrt(e*e+n*n+r*r),t.distance<1e-20){t.distance=1e-20,ym("Distance is set to minimum.");const e=t.directionOfProjection;t.focalPoint[0]=t.position[0]+e[0]*t.distance,t.focalPoint[1]=t.position[1]+e[1]*t.distance,t.focalPoint[2]=t.position[2]+e[2]*t.distance}t.directionOfProjection[0]=e/t.distance,t.directionOfProjection[1]=n/t.distance,t.directionOfProjection[2]=r/t.distance,T()},e.dolly=n=>{if(n<=0)return;const r=t.distance/n;e.setPosition(t.focalPoint[0]-r*t.directionOfProjection[0],t.focalPoint[1]-r*t.directionOfProjection[1],t.focalPoint[2]-r*t.directionOfProjection[2])},e.roll=n=>{const r=t.position,o=t.focalPoint,a=t.viewUp,i=new Float64Array([a[0],a[1],a[2],0]);g(u);const s=new Float64Array([o[0]-r[0],o[1]-r[1],o[2]-r[2]]);C(u,u,yo(n),s),Ba(i,i,u),t.viewUp[0]=i[0],t.viewUp[1]=i[1],t.viewUp[2]=i[2],e.modified()},e.azimuth=n=>{const r=t.focalPoint;g(p),b(p,p,r),C(p,p,yo(n),t.viewUp),b(p,p,[-r[0],-r[1],-r[2]]),wn(f,t.position,p),e.setPosition(f[0],f[1],f[2])},e.yaw=n=>{const r=t.position;g(p),b(p,p,r),C(p,p,yo(n),t.viewUp),b(p,p,[-r[0],-r[1],-r[2]]),wn(v,t.focalPoint,p),e.setFocalPoint(v[0],v[1],v[2])},e.elevation=n=>{const r=t.focalPoint,o=e.getViewMatrix(),a=[-o[0],-o[1],-o[2]];g(p),b(p,p,r),C(p,p,yo(n),a),b(p,p,[-r[0],-r[1],-r[2]]),wn(f,t.position,p),e.setPosition(f[0],f[1],f[2])},e.pitch=n=>{const r=t.position,o=e.getViewMatrix(),a=[o[0],o[1],o[2]];g(p),b(p,p,r),C(p,p,yo(n),a),b(p,p,[-r[0],-r[1],-r[2]]),wn(v,t.focalPoint,p),e.setFocalPoint(...v)},e.zoom=n=>{n<=0||(t.parallelProjection?t.parallelScale/=n:t.viewAngle/=n,e.modified())},e.translate=(n,r,o)=>{const a=[n,r,o];Eo(t.position,a,t.position),Eo(t.focalPoint,a,t.focalPoint),e.computeDistance(),e.modified()},e.applyTransform=n=>{const r=[...t.viewUp,1],o=[],a=[],i=[];r[0]+=t.position[0],r[1]+=t.position[1],r[2]+=t.position[2],Ba(o,[...t.position,1],n),Ba(a,[...t.focalPoint,1],n),Ba(i,r,n),i[0]-=o[0],i[1]-=o[1],i[2]-=o[2],e.setPosition(...o.slice(0,3)),e.setFocalPoint(...a.slice(0,3)),e.setViewUp(...i.slice(0,3))},e.getThickness=()=>t.clippingRange[1]-t.clippingRange[0],e.setThickness=n=>{let r=n;r<1e-20&&(r=1e-20,ym("Thickness is set to minimum.")),e.setClippingRange(t.clippingRange[0],t.clippingRange[0]+r)},e.setThicknessFromFocalPoint=n=>{let r=n;r<1e-20&&(r=1e-20,ym("Thickness is set to minimum.")),e.setClippingRange(t.distance-r/2,t.distance+r/2)},e.setRoll=e=>{},e.getRoll=()=>{},e.setObliqueAngles=(e,t)=>{},e.getOrientation=()=>{},e.getOrientationWXYZ=()=>{},e.getFrustumPlanes=e=>{},e.getCameraLightTransformMatrix=e=>(d(e,t.cameraLightTransform),e),e.computeCameraLightTransform=()=>{d(a,e.getViewMatrix()),h(a,a),O(i,[t.distance,t.distance,t.distance]),y(a,a,i),g(t.cameraLightTransform),b(t.cameraLightTransform,a,[0,0,-1])},e.deepCopy=e=>{},e.physicalOrientationToWorldDirection=e=>{const t=ka(e[0],e[1],e[2],e[3]),n=Na(),r=ka(0,0,1,0);var o,a;return a=t,(o=n)[0]=-a[0],o[1]=-a[1],o[2]=-a[2],o[3]=a[3],_a(r,t,r),_a(r,r,n),[r[0],r[1],r[2]]},e.getPhysicalToWorldMatrix=t=>{e.getWorldToPhysicalMatrix(t),h(t,t)},e.getWorldToPhysicalMatrix=e=>{g(e);const n=[3];Fo(t.physicalViewNorth,t.physicalViewUp,n),e[0]=n[0],e[1]=n[1],e[2]=n[2],e[4]=t.physicalViewUp[0],e[5]=t.physicalViewUp[1],e[6]=t.physicalViewUp[2],e[8]=-t.physicalViewNorth[0],e[9]=-t.physicalViewNorth[1],e[10]=-t.physicalViewNorth[2],m(e,e),vn(s,1/t.physicalScale,1/t.physicalScale,1/t.physicalScale),x(e,e,s),b(e,e,t.physicalTranslation)},e.computeViewParametersFromViewMatrix=i=>{h(a,i),wn(s,n,a),e.computeDistance();const u=t.distance;e.setPosition(s[0],s[1],s[2]),wn(l,r,a),yn(l,l,s),Sn(l,l),e.setDirectionOfProjection(l[0],l[1],l[2]),wn(c,o,a),yn(c,c,s),Sn(c,c),e.setViewUp(c[0],c[1],c[2]),e.setDistance(u)},e.computeViewParametersFromPhysicalMatrix=t=>{e.getWorldToPhysicalMatrix(a),y(a,t,a),e.computeViewParametersFromViewMatrix(a)},e.setViewMatrix=n=>{t.viewMatrix=n,t.viewMatrix&&(d(a,t.viewMatrix),e.computeViewParametersFromViewMatrix(a),m(t.viewMatrix,t.viewMatrix))},e.getViewMatrix=()=>{if(t.viewMatrix)return t.viewMatrix;q(a,t.position,t.focalPoint,t.viewUp),m(a,a);const e=new Float64Array(16);return d(e,a),e},e.setProjectionMatrix=e=>{t.projectionMatrix=e},e.getProjectionMatrix=(e,n,r)=>{const o=new Float64Array(16);if(g(o),t.projectionMatrix){const e=1/t.physicalScale;return vn(s,e,e,e),d(o,t.projectionMatrix),x(o,o,s),m(o,o),o}g(a);const i=t.clippingRange[1]-t.clippingRange[0],l=[t.clippingRange[0]+(n+1)*i/2,t.clippingRange[0]+(r+1)*i/2];if(t.parallelProjection){const n=t.parallelScale*e,r=t.parallelScale,o=(t.windowCenter[0]-1)*n,i=(t.windowCenter[0]+1)*n,s=(t.windowCenter[1]-1)*r,c=(t.windowCenter[1]+1)*r;K(a,o,i,s,c,l[0],l[1]),m(a,a)}else{if(t.useOffAxisProjection)throw new Error("Off-Axis projection is not supported at this time");{const n=Math.tan(yo(t.viewAngle)/2);let r,o;!0===t.useHorizontalViewAngle?(r=t.clippingRange[0]*n,o=t.clippingRange[0]*n/e):(r=t.clippingRange[0]*n*e,o=t.clippingRange[0]*n);const i=(t.windowCenter[0]-1)*r,s=(t.windowCenter[0]+1)*r,c=(t.windowCenter[1]-1)*o,u=(t.windowCenter[1]+1)*o,d=l[0],p=l[1];a[0]=2*d/(s-i),a[5]=2*d/(u-c),a[2]=(i+s)/(s-i),a[6]=(c+u)/(u-c),a[10]=-(d+p)/(p-d),a[14]=-1,a[11]=-2*d*p/(p-d),a[15]=0}}return d(o,a),o},e.getCompositeProjectionMatrix=(t,n,r)=>{const o=e.getViewMatrix(),a=e.getProjectionMatrix(t,n,r);return y(a,o,a),a},e.setDirectionOfProjection=(e,n,r)=>{if(t.directionOfProjection[0]===e&&t.directionOfProjection[1]===n&&t.directionOfProjection[2]===r)return;t.directionOfProjection[0]=e,t.directionOfProjection[1]=n,t.directionOfProjection[2]=r;const o=t.directionOfProjection;t.focalPoint[0]=t.position[0]+o[0]*t.distance,t.focalPoint[1]=t.position[1]+o[1]*t.distance,t.focalPoint[2]=t.position[2]+o[2]*t.distance,T()},e.setDeviceAngles=(n,r,o,a)=>{const i=[3];Fo(t.physicalViewNorth,t.physicalViewUp,i);const s=g(new Float64Array(16));C(s,s,yo(n),t.physicalViewUp),C(s,s,yo(r),i),C(s,s,yo(o),t.physicalViewNorth),C(s,s,yo(-a),t.physicalViewUp);const l=new Float64Array([-t.physicalViewUp[0],-t.physicalViewUp[1],-t.physicalViewUp[2]]),c=new Float64Array(t.physicalViewNorth);wn(l,l,s),wn(c,c,s),e.setDirectionOfProjection(l[0],l[1],l[2]),e.setViewUp(c[0],c[1],c[2]),e.modified()},e.setOrientationWXYZ=(t,n,r,o)=>{const a=g(new Float64Array(16));if(0!==t&&(0!==n||0!==r||0!==o)){const e=yo(t),i=Na();Fa(i,[n,r,o],e),k(a,i)}const i=new Float64Array(3);wn(i,[0,0,-1],a);const s=new Float64Array(3);wn(s,[0,1,0],a),e.setDirectionOfProjection(...i),e.setViewUp(...s),e.modified()},e.computeClippingRange=e=>{let n=null,r=null;n=t.viewPlaneNormal,r=t.position;const o=-n[0],a=-n[1],i=-n[2],s=-(o*r[0]+a*r[1]+i*r[2]),l=[o*e[0]+a*e[2]+i*e[4]+s,1e-18];for(let t=0;t<2;t++)for(let n=0;n<2;n++)for(let r=0;r<2;r++){const c=o*e[r]+a*e[2+n]+i*e[4+t]+s;l[0]=c<l[0]?c:l[0],l[1]=c>l[1]?c:l[1]}return l}}(e,t)}var Cm={newInstance:Ht.newInstance(xm,"vtkCamera"),extend:xm};const Sm={switch:!0,intensity:1,color:[1,1,1],position:[0,0,1],focalPoint:[0,0,0],positional:!1,exponent:1,coneAngle:30,coneFalloff:5,attenuationValues:[1,0,0],transformMatrix:null,lightType:"SceneLight",shadowAttenuation:1,direction:[0,0,0],directionMTime:0};function Am(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Sm,n),Ht.obj(e,t),Ht.setGet(e,t,["intensity","switch","positional","exponent","coneAngle","coneFalloff","transformMatrix","lightType","shadowAttenuation","attenuationValues"]),Ht.setGetArray(e,t,["color","position","focalPoint","attenuationValues"],3),function(e,t){t.classHierarchy.push("vtkLight");const n=new Float64Array(3);e.getTransformedPosition=()=>(t.transformMatrix?wn(n,t.position,t.transformMatrix):vn(n,t.position[0],t.position[1],t.position[2]),n),e.getTransformedFocalPoint=()=>(t.transformMatrix?wn(n,t.focalPoint,t.transformMatrix):vn(n,t.focalPoint[0],t.focalPoint[1],t.focalPoint[2]),n),e.getDirection=()=>(t.directionMTime<t.mtime&&(Mn(t.direction,t.focalPoint,t.position),ko(t.direction),t.directionMTime=t.mtime),t.direction),e.setDirection=e=>{const n=new Float64Array(3);Mn(n,t.position,e),t.focalPoint=n},e.setDirectionAngle=(t,n)=>{const r=yo(t),o=yo(n);e.setPosition(Math.cos(r)*Math.sin(o),Math.sin(r),Math.cos(r)*Math.cos(o)),e.setFocalPoint(0,0,0),e.setPositional(0)},e.setLightTypeToHeadLight=()=>{e.setLightType("HeadLight")},e.setLightTypeToCameraLight=()=>{e.setLightType("CameraLight")},e.setLightTypeToSceneLight=()=>{e.setTransformMatrix(null),e.setLightType("SceneLight")},e.lightTypeIsHeadLight=()=>"HeadLight"===t.lightType,e.lightTypeIsSceneLight=()=>"SceneLight"===t.lightType,e.lightTypeIsCameraLight=()=>"CameraLight"===t.lightType}(e,t)}var Im={newInstance:Ht.newInstance(Am,"vtkLight"),extend:Am,LIGHT_TYPES:["HeadLight","CameraLight","SceneLight"]};const{vtkErrorMacro:wm}=Ht;const Om={background:[0,0,0],background2:[.2,.2,.2],gradientBackground:!1,viewport:[0,0,1,1],aspect:[1,1],pixelAspect:[1,1],props:[],actors2D:[]};function Pm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Om,n),Ht.obj(e,t),Ht.event(e,t,"event"),Ht.setGetArray(e,t,["viewport"],4),Ht.setGetArray(e,t,["background","background2"],3),function(e,t){function n(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];t.push(e);const r=e.getNestedProps();if(r&&r.length)for(let e=0;e<r.length;e++)n(r[e],t);return t}t.classHierarchy.push("vtkViewport"),e.getViewProps=()=>t.props,e.hasViewProp=e=>t.props.includes(e),e.addViewProp=n=>{n&&!e.hasViewProp(n)&&t.props.push(n)},e.removeViewProp=e=>{const n=t.props.filter((t=>t!==e));t.props.length!==n.length&&(t.props=n)},e.removeAllViewProps=()=>{t.props=[]},e.getViewPropsWithNestedProps=()=>{let r=[];const o=e.getActors2D();o.sort(((e,t)=>e.getLayerNumber()-t.getLayerNumber()));const a=t.props.filter((e=>!o.includes(e)));for(let e=0;e<a.length;e++)n(a[e],r);return r=r.concat(o),r},e.addActor2D=e.addViewProp,e.removeActor2D=t=>{e.removeViewProp(t)},e.getActors2D=()=>(t.actors2D=[],t.props.forEach((e=>{t.actors2D=t.actors2D.concat(e.getActors2D())})),t.actors2D),e.displayToView=()=>wm("call displayToView on your view instead"),e.viewToDisplay=()=>wm("callviewtodisplay on your view instead"),e.getSize=()=>wm("call getSize on your View instead"),e.normalizedDisplayToProjection=(t,n,r)=>{const o=e.normalizedDisplayToNormalizedViewport(t,n,r);return e.normalizedViewportToProjection(o[0],o[1],o[2])},e.normalizedDisplayToNormalizedViewport=(e,n,r)=>{const o=[t.viewport[2]-t.viewport[0],t.viewport[3]-t.viewport[1]];return[(e-t.viewport[0])/o[0],(n-t.viewport[1])/o[1],r]},e.normalizedViewportToProjection=(e,t,n)=>[2*e-1,2*t-1,2*n-1],e.projectionToNormalizedDisplay=(t,n,r)=>{const o=e.projectionToNormalizedViewport(t,n,r);return e.normalizedViewportToNormalizedDisplay(o[0],o[1],o[2])},e.normalizedViewportToNormalizedDisplay=(e,n,r)=>{const o=[t.viewport[2]-t.viewport[0],t.viewport[3]-t.viewport[1]];return[e*o[0]+t.viewport[0],n*o[1]+t.viewport[1],r]},e.projectionToNormalizedViewport=(e,t,n)=>[.5*(e+1),.5*(t+1),.5*(n+1)],e.PickPropFrom=()=>wm("vtkViewport::PickPropFrom - NOT IMPLEMENTED")}(e,t)}var Rm={newInstance:Ht.newInstance(Pm,"vtkViewport"),extend:Pm};const{vtkDebugMacro:Mm,vtkErrorMacro:Em,vtkWarningMacro:Vm}=jt;function Dm(e){return()=>Em(`vtkRenderer::${e} - NOT IMPLEMENTED`)}const Lm={pickedProp:null,activeCamera:null,allBounds:[],ambient:[1,1,1],allocatedRenderTime:100,timeFactor:1,automaticLightCreation:!0,twoSidedLighting:!0,lastRenderTimeInSeconds:-1,renderWindow:null,lights:[],actors:[],volumes:[],lightFollowCamera:!0,numberOfPropsRendered:0,propArray:null,pathArray:null,layer:0,preserveColorBuffer:!1,preserveDepthBuffer:!1,computeVisiblePropBounds:Ra(),interactive:!0,nearClippingPlaneTolerance:0,clippingRangeExpansion:.05,erase:!0,draw:!0,useShadows:!1,useDepthPeeling:!1,occlusionRatio:0,maximumNumberOfPeels:4,selector:null,delegate:null,texturedBackground:!1,backgroundTexture:null,environmentTexture:null,environmentTextureDiffuseStrength:1,environmentTextureSpecularStrength:1,useEnvironmentTextureAsBackground:!1,pass:0};function Bm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};for(Object.assign(t,Lm,n),Rm.extend(e,t,n),t.background||(t.background=[0,0,0,1]);t.background.length<3;)t.background.push(0);3===t.background.length&&t.background.push(1),yt(e,t,["_renderWindow","allocatedRenderTime","timeFactor","lastRenderTimeInSeconds","numberOfPropsRendered","lastRenderingUsedDepthPeeling","selector"]),St(e,t,["twoSidedLighting","lightFollowCamera","automaticLightCreation","erase","draw","nearClippingPlaneTolerance","clippingRangeExpansion","backingStore","interactive","layer","preserveColorBuffer","preserveDepthBuffer","useDepthPeeling","occlusionRatio","maximumNumberOfPeels","delegate","backgroundTexture","texturedBackground","environmentTexture","environmentTextureDiffuseStrength","environmentTextureSpecularStrength","useEnvironmentTextureAsBackground","useShadows","pass"]),At(e,t,["actors","volumes","lights"]),wt(e,t,["background"],4,1),Ot(0,t,["renderWindow"]),function(e,t){t.classHierarchy.push("vtkRenderer");const n={type:"ComputeVisiblePropBoundsEvent",renderer:e},r={type:"ResetCameraClippingRangeEvent",renderer:e},o={type:"ResetCameraEvent",renderer:e};e.updateCamera=()=>(t.activeCamera||(Mm("No cameras are on, creating one."),e.getActiveCameraAndResetIfCreated()),t.activeCamera.render(e),!0),e.updateLightsGeometryToFollowCamera=()=>{const n=e.getActiveCameraAndResetIfCreated();t.lights.forEach((e=>{e.lightTypeIsSceneLight()||(e.lightTypeIsHeadLight()?(e.setPositionFrom(n.getPositionByReference()),e.setFocalPointFrom(n.getFocalPointByReference()),e.modified(n.getMTime())):e.lightTypeIsCameraLight()?e.setTransformMatrix(n.getCameraLightTransformMatrix(c())):Em("light has unknown light type",e.get()))}))},e.updateLightGeometry=()=>!t.lightFollowCamera||e.updateLightsGeometryToFollowCamera(),e.allocateTime=Dm("allocateTime"),e.updateGeometry=Dm("updateGeometry"),e.getVTKWindow=()=>t._renderWindow,e.setLayer=n=>{Mm(e.getClassName(),e,"setting Layer to ",n),t.layer!==n&&(t.layer=n,e.modified()),e.setPreserveColorBuffer(!!n)},e.setActiveCamera=n=>t.activeCamera!==n&&(t.activeCamera=n,e.modified(),e.invokeEvent({type:"ActiveCameraEvent",camera:n}),!0),e.makeCamera=()=>{const t=Cm.newInstance();return e.invokeEvent({type:"CreateCameraEvent",camera:t}),t},e.getActiveCamera=()=>(t.activeCamera||(t.activeCamera=e.makeCamera()),t.activeCamera),e.getActiveCameraAndResetIfCreated=()=>(t.activeCamera||(e.getActiveCamera(),e.resetCamera()),t.activeCamera),e.getActors=()=>(t.actors=[],t.props.forEach((e=>{t.actors=t.actors.concat(e.getActors())})),t.actors),e.addActor=e.addViewProp,e.removeActor=n=>{t.actors=t.actors.filter((e=>e!==n)),e.removeViewProp(n),e.modified()},e.removeAllActors=()=>{e.getActors().forEach((t=>{e.removeViewProp(t)})),t.actors=[],e.modified()},e.getVolumes=()=>(t.volumes=[],t.props.forEach((e=>{t.volumes=t.volumes.concat(e.getVolumes())})),t.volumes),e.addVolume=e.addViewProp,e.removeVolume=n=>{t.volumes=t.volumes.filter((e=>e!==n)),e.removeViewProp(n),e.modified()},e.removeAllVolumes=()=>{e.getVolumes().forEach((t=>{e.removeViewProp(t)})),t.volumes=[],e.modified()},e.hasLight=e=>t.lights.includes(e),e.addLight=n=>{n&&!e.hasLight(n)&&(t.lights.push(n),e.modified())},e.removeLight=n=>{t.lights=t.lights.filter((e=>e!==n)),e.modified()},e.removeAllLights=()=>{t.lights=[],e.modified()},e.setLightCollection=n=>{t.lights=n,e.modified()},e.makeLight=Im.newInstance,e.createLight=()=>{t.automaticLightCreation&&(t._createdLight&&(e.removeLight(t._createdLight),t._createdLight.delete(),t._createdLight=null),t._createdLight=e.makeLight(),e.addLight(t._createdLight),t._createdLight.setLightTypeToHeadLight(),t._createdLight.setPosition(e.getActiveCamera().getPosition()),t._createdLight.setFocalPoint(e.getActiveCamera().getFocalPoint()))},e.normalizedDisplayToWorld=(t,n,r,o)=>{let a=e.normalizedDisplayToProjection(t,n,r);return a=e.projectionToView(a[0],a[1],a[2],o),e.viewToWorld(a[0],a[1],a[2])},e.worldToNormalizedDisplay=(t,n,r,o)=>{let a=e.worldToView(t,n,r);return a=e.viewToProjection(a[0],a[1],a[2],o),e.projectionToNormalizedDisplay(a[0],a[1],a[2])},e.viewToWorld=(e,n,r)=>{if(null===t.activeCamera)return Em("ViewToWorld: no active camera, cannot compute view to world, returning 0,0,0"),[0,0,0];const o=t.activeCamera.getViewMatrix();h(o,o),m(o,o);const a=new Float64Array([e,n,r]);return wn(a,a,o),a},e.projectionToView=(e,n,r,o)=>{if(null===t.activeCamera)return Em("ProjectionToView: no active camera, cannot compute projection to view, returning 0,0,0"),[0,0,0];const a=t.activeCamera.getProjectionMatrix(o,-1,1);h(a,a),m(a,a);const i=new Float64Array([e,n,r]);return wn(i,i,a),i},e.worldToView=(e,n,r)=>{if(null===t.activeCamera)return Em("WorldToView: no active camera, cannot compute view to world, returning 0,0,0"),[0,0,0];const o=t.activeCamera.getViewMatrix();m(o,o);const a=new Float64Array([e,n,r]);return wn(a,a,o),a},e.viewToProjection=(e,n,r,o)=>{if(null===t.activeCamera)return Em("ViewToProjection: no active camera, cannot compute view to projection, returning 0,0,0"),[0,0,0];const a=t.activeCamera.getProjectionMatrix(o,-1,1);m(a,a);const i=new Float64Array([e,n,r]);return wn(i,i,a),i},e.computeVisiblePropBounds=()=>{t.allBounds[0]=Fi.INIT_BOUNDS[0],t.allBounds[1]=Fi.INIT_BOUNDS[1],t.allBounds[2]=Fi.INIT_BOUNDS[2],t.allBounds[3]=Fi.INIT_BOUNDS[3],t.allBounds[4]=Fi.INIT_BOUNDS[4],t.allBounds[5]=Fi.INIT_BOUNDS[5];let r=!0;e.invokeEvent(n);for(let e=0;e<t.props.length;++e){const n=t.props[e];if(n.getVisibility()&&n.getUseBounds()){const e=n.getBounds();e&&ba(e)&&(r=!1,e[0]<t.allBounds[0]&&(t.allBounds[0]=e[0]),e[1]>t.allBounds[1]&&(t.allBounds[1]=e[1]),e[2]<t.allBounds[2]&&(t.allBounds[2]=e[2]),e[3]>t.allBounds[3]&&(t.allBounds[3]=e[3]),e[4]<t.allBounds[4]&&(t.allBounds[4]=e[4]),e[5]>t.allBounds[5]&&(t.allBounds[5]=e[5]))}}return r&&(ya(t.allBounds),Mm("Can't compute bounds, no 3D props are visible")),t.allBounds},e.resetCamera=function(){const n=(arguments.length>0&&void 0!==arguments[0]?arguments[0]:null)||e.computeVisiblePropBounds(),r=[0,0,0];if(!ba(n))return Mm("Cannot reset camera!"),!1;let a=null;if(!e.getActiveCamera())return Em("Trying to reset non-existent camera"),!1;a=t.activeCamera.getViewPlaneNormal(),t.activeCamera.setViewAngle(30),r[0]=(n[0]+n[1])/2,r[1]=(n[2]+n[3])/2,r[2]=(n[4]+n[5])/2;let i=n[1]-n[0],s=n[3]-n[2],l=n[5]-n[4];i*=i,s*=s,l*=l;let c=i+s+l;c=0===c?1:c,c=.5*Math.sqrt(c);const u=yo(t.activeCamera.getViewAngle()),d=c,p=c/Math.sin(.5*u),f=t.activeCamera.getViewUp();return Math.abs(No(f,a))>.999&&(Vm("Resetting view-up since view plane normal is parallel"),t.activeCamera.setViewUp(-f[2],f[0],f[1])),t.activeCamera.setFocalPoint(r[0],r[1],r[2]),t.activeCamera.setPosition(r[0]+p*a[0],r[1]+p*a[1],r[2]+p*a[2]),e.resetCameraClippingRange(n),t.activeCamera.setParallelScale(d),t.activeCamera.setPhysicalScale(c),t.activeCamera.setPhysicalTranslation(-r[0],-r[1],-r[2]),e.invokeEvent(o),!0},e.resetCameraClippingRange=function(){const n=(arguments.length>0&&void 0!==arguments[0]?arguments[0]:null)||e.computeVisiblePropBounds();if(!ba(n))return Mm("Cannot reset camera clipping range!"),!1;if(e.getActiveCameraAndResetIfCreated(),!t.activeCamera)return Em("Trying to reset clipping range of non-existent camera"),!1;const o=t.activeCamera.computeClippingRange(n);let a=0;if(t.activeCamera.getParallelProjection())a=.2*t.activeCamera.getParallelScale();else{const e=yo(t.activeCamera.getViewAngle());a=.2*Math.tan(e/2)*o[1]}return o[1]-o[0]<a&&(a=a-o[1]+o[0],o[1]+=a/2,o[0]-=a/2),o[0]<0&&(o[0]=0),o[0]=.99*o[0]-(o[1]-o[0])*t.clippingRangeExpansion,o[1]=1.01*o[1]+(o[1]-o[0])*t.clippingRangeExpansion,o[0]=o[0]>=o[1]?.01*o[1]:o[0],t.nearClippingPlaneTolerance||(t.nearClippingPlaneTolerance=.01),o[0]<t.nearClippingPlaneTolerance*o[1]&&(o[0]=t.nearClippingPlaneTolerance*o[1]),t.activeCamera.setClippingRange(o[0],o[1]),e.invokeEvent(r),!1},e.setRenderWindow=e=>{e!==t._renderWindow&&(t._vtkWindow=e,t._renderWindow=e)},e.visibleActorCount=()=>t.props.filter((e=>e.getVisibility())).length,e.visibleVolumeCount=e.visibleActorCount,e.getMTime=()=>{let e=t.mtime;const n=t.activeCamera?t.activeCamera.getMTime():0;n>e&&(e=n);const r=t._createdLight?t._createdLight.getMTime():0;return r>e&&(e=r),e},e.getTransparent=()=>!!t.preserveColorBuffer,e.isActiveCameraCreated=()=>!!t.activeCamera}(e,t)}var Nm={newInstance:Et(Bm,"vtkRenderer"),extend:Bm};const Fm=Object.create(null);function _m(e,t){Fm[e]=t}function km(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Fm[e]&&Fm[e](t)}const Gm={defaultViewAPI:"WebGL",renderers:[],views:[],interactor:null,neverRendered:!0,numberOfLayers:1,childRenderWindows:[]};function Um(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Gm,n),Ht.obj(e,t),Ht.setGet(e,t,["interactor","numberOfLayers","_views","defaultViewAPI"]),Ht.get(e,t,["neverRendered"]),Ht.getArray(e,t,["renderers","childRenderWindows"]),Ht.moveToProtected(e,t,["views"]),Ht.event(e,t,"completion"),function(e,t){t.classHierarchy.push("vtkRenderWindow"),e.addRenderer=n=>{e.hasRenderer(n)||(n.setRenderWindow(e),t.renderers.push(n),e.modified())},e.removeRenderer=n=>{t.renderers=t.renderers.filter((e=>e!==n)),e.modified()},e.hasRenderer=e=>-1!==t.renderers.indexOf(e),e.newAPISpecificView=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return km(e||t.defaultViewAPI,n)},e.addView=n=>{e.hasView(n)||(n.setRenderable(e),t._views.push(n),e.modified())},e.removeView=n=>{t._views=t._views.filter((e=>e!==n)),e.modified()},e.hasView=e=>-1!==t._views.indexOf(e),e.preRender=()=>{t.renderers.forEach((e=>{e.isActiveCameraCreated()||e.resetCamera()}))},e.render=()=>{e.preRender(),t.interactor?t.interactor.render():t._views.forEach((e=>e.traverseAllPasses()))},e.getStatistics=()=>{const e={propCount:0,invisiblePropCount:0,gpuMemoryMB:0};return t._views.forEach((t=>{t.getGraphicsMemoryInfo&&(e.gpuMemoryMB+=t.getGraphicsMemoryInfo()/1e6)})),t.renderers.forEach((n=>{const r=n.getViewProps(),o=t._views[0].getViewNodeFor(n);r.forEach((t=>{if(t.getVisibility()){e.propCount+=1;const n=t.getMapper&&t.getMapper();if(n&&n.getPrimitiveCount){const t=o.getViewNodeFor(n);if(t){t.getAllocatedGPUMemoryInBytes&&(e.gpuMemoryMB+=t.getAllocatedGPUMemoryInBytes()/1e6);const r=n.getPrimitiveCount();Object.keys(r).forEach((t=>{e[t]||(e[t]=0),e[t]+=r[t]}))}}}else e.invisiblePropCount+=1}))})),e.str=Object.keys(e).map((t=>`${t}: ${e[t]}`)).join("\n"),e},e.captureImages=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"image/png",r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Ht.setImmediate(e.render),t._views.map((e=>e.captureNextImage?e.captureNextImage(n,r):void 0)).filter((e=>!!e))},e.addRenderWindow=n=>!t.childRenderWindows.includes(n)&&(t.childRenderWindows.push(n),e.modified(),!0),e.removeRenderWindow=n=>{const r=t.childRenderWindows.findIndex((e=>e===n));return!(r<0||(t.childRenderWindows.splice(r,1),e.modified(),0))}}(e,t)}var zm={newInstance:Ht.newInstance(Um,"vtkRenderWindow"),extend:Um,registerViewConstructor:_m,listViewAPIs:function(){return Object.keys(Fm)},newAPISpecificView:km};const Wm={Unknown:0,LeftController:1,RightController:2},Hm={Unknown:0,Trigger:1,TrackPad:2,Grip:3,Thumbstick:4,A:5,B:6,ApplicationMenu:7};var jm={Device:Wm,Input:Hm,Axis:{Unknown:0,TouchpadX:1,TouchpadY:2,ThumbstickX:3,ThumbstickY:4},MouseButton:{LeftButton:1,MiddleButton:2,RightButton:3}};const{Device:Km,Input:$m}=jm,{vtkWarningMacro:qm,vtkErrorMacro:Xm,normalizeWheel:Ym,vtkOnceErrorMacro:Zm}=Ht,Qm={ctrlKey:!1,altKey:!1,shiftKey:!1},Jm={"xr-standard":[$m.Trigger,$m.Grip,$m.TrackPad,$m.Thumbstick,$m.A,$m.B]},eh=["StartAnimation","Animation","EndAnimation","PointerEnter","PointerLeave","MouseEnter","MouseLeave","StartMouseMove","MouseMove","EndMouseMove","LeftButtonPress","LeftButtonRelease","MiddleButtonPress","MiddleButtonRelease","RightButtonPress","RightButtonRelease","KeyPress","KeyDown","KeyUp","StartMouseWheel","MouseWheel","EndMouseWheel","StartPinch","Pinch","EndPinch","StartPan","Pan","EndPan","StartRotate","Rotate","EndRotate","Button3D","Move3D","StartPointerLock","EndPointerLock","StartInteraction","Interaction","EndInteraction","AnimationFrameRateUpdate"];function th(e){e.cancelable&&e.preventDefault()}function nh(e){const t=Object.create(null);return e.forEach((e=>{let{pointerId:n,position:r}=e;t[n]=r})),t}const rh={renderWindow:null,interactorStyle:null,picker:null,pickingManager:null,initialized:!1,enabled:!1,enableRender:!0,currentRenderer:null,lightFollowCamera:!0,desiredUpdateRate:30,stillUpdateRate:2,container:null,recognizeGestures:!0,currentGesture:"Start",animationRequest:null,lastFrameTime:.1,recentAnimationFrameRate:10,wheelTimeoutID:0,moveTimeoutID:0,lastGamepadValues:{},preventDefaultOnPointerDown:!1,preventDefaultOnPointerUp:!1,mouseScrollDebounceByPass:!1};function oh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,rh,n),Ht.obj(e,t),t._animationExtendedEnd=0,Ht.event(e,t,"RenderEvent"),eh.forEach((n=>Ht.event(e,t,n))),Ht.get(e,t,["initialized","interactorStyle","lastFrameTime","recentAnimationFrameRate","_view"]),Ht.setGet(e,t,["container","lightFollowCamera","enabled","enableRender","recognizeGestures","desiredUpdateRate","stillUpdateRate","picker","preventDefaultOnPointerDown","preventDefaultOnPointerUp","mouseScrollDebounceByPass"]),Ht.moveToProtected(e,t,["view"]),function(e,t){t.classHierarchy.push("vtkRenderWindowInteractor");const n={...e},r=new Set,o=new Map;let a=1;function i(n,r){t._forcedRenderer||(t.currentRenderer=e.findPokedRenderer(n,r))}e.start=()=>{(t.initialized||(e.initialize(),t.initialized))&&e.startEventLoop()},e.setRenderWindow=e=>{Xm("you want to call setView(view) instead of setRenderWindow on a vtk.js interactor")},e.setInteractorStyle=n=>{t.interactorStyle!==n&&(null!=t.interactorStyle&&t.interactorStyle.setInteractor(null),t.interactorStyle=n,null!=t.interactorStyle&&t.interactorStyle.getInteractor()!==e&&t.interactorStyle.setInteractor(e))},e.initialize=()=>{t.initialized=!0,e.enable(),e.render()},e.enable=()=>e.setEnabled(!0),e.disable=()=>e.setEnabled(!1),e.startEventLoop=()=>qm("empty event loop"),e.getCurrentRenderer=()=>(t.currentRenderer||i(0,0),t.currentRenderer);const s=t._getScreenEventPositionFor||function(e){const n=t._view.getCanvas(),r=n.getBoundingClientRect(),a=n.width/r.width,s=n.height/r.height,l={x:a*(e.clientX-r.left),y:s*(r.height-e.clientY+r.top),z:0,movementX:a*e.movementX,movementY:s*e.movementY};return(o.size<=1||!t.currentRenderer)&&i(l.x,l.y),l};function l(e){return{controlKey:e.ctrlKey,altKey:e.altKey,shiftKey:e.shiftKey}}function c(e){const t=l(e);return{key:e.key,keyCode:e.charCode,...t}}function u(e){return e.pointerType||""}const d=()=>{if(null===t.container)return;const{container:n}=t;n.addEventListener("contextmenu",th),n.addEventListener("wheel",e.handleWheel),n.addEventListener("DOMMouseScroll",e.handleWheel),n.addEventListener("pointerenter",e.handlePointerEnter),n.addEventListener("pointerleave",e.handlePointerLeave),n.addEventListener("pointermove",e.handlePointerMove,{passive:!1}),n.addEventListener("pointerdown",e.handlePointerDown,{passive:!1}),n.addEventListener("pointerup",e.handlePointerUp),n.addEventListener("pointercancel",e.handlePointerCancel),n.addEventListener("keypress",e.handleKeyPress),n.addEventListener("keydown",e.handleKeyDown),document.addEventListener("keyup",e.handleKeyUp),document.addEventListener("pointerlockchange",e.handlePointerLockChange),n.tabIndex=0,n.style.touchAction="none",n.style.userSelect="none",n.style.webkitTapHighlightColor="rgba(0,0,0,0)"};e.bindEvents=e=>{null!==e&&n.setContainer(e)&&d()};const p=()=>{clearTimeout(t.moveTimeoutID),clearTimeout(t.wheelTimeoutID),t.moveTimeoutID=0,t.wheelTimeoutID=0,a=1;const{container:n}=t;n&&(n.removeEventListener("contextmenu",th),n.removeEventListener("wheel",e.handleWheel),n.removeEventListener("DOMMouseScroll",e.handleWheel),n.removeEventListener("pointerenter",e.handlePointerEnter),n.removeEventListener("pointerleave",e.handlePointerLeave),n.removeEventListener("pointermove",e.handlePointerMove,{passive:!1}),n.removeEventListener("pointerdown",e.handlePointerDown,{passive:!1}),n.removeEventListener("pointerup",e.handlePointerUp),n.removeEventListener("pointercancel",e.handlePointerCancel)),n.removeEventListener("keypress",e.handleKeyPress),n.removeEventListener("keydown",e.handleKeyDown),document.removeEventListener("keyup",e.handleKeyUp),document.removeEventListener("pointerlockchange",e.handlePointerLockChange),o.clear()};function f(){t._view&&t.enabled&&t.enableRender&&(t.inRender=!0,t._view.traverseAllPasses(),t.inRender=!1),e.invokeRenderEvent()}e.unbindEvents=()=>{p(),n.setContainer(null)},e.handleKeyPress=t=>{const n=c(t);e.keyPressEvent(n)},e.handleKeyDown=t=>{const n=c(t);e.keyDownEvent(n)},e.handleKeyUp=t=>{const n=c(t);e.keyUpEvent(n)},e.handlePointerEnter=t=>{const n={...l(t),position:s(t),deviceType:u(t)};e.pointerEnterEvent(n),"mouse"===n.deviceType&&e.mouseEnterEvent(n)},e.handlePointerLeave=t=>{const n={...l(t),position:s(t),deviceType:u(t)};e.pointerLeaveEvent(n),"mouse"===n.deviceType&&e.mouseLeaveEvent(n)},e.handlePointerDown=n=>{if(!(n.button>2||e.isPointerLocked()))switch(t.preventDefaultOnPointerDown&&th(n),n.target.hasPointerCapture(n.pointerId)&&n.target.releasePointerCapture(n.pointerId),t.container.setPointerCapture(n.pointerId),o.has(n.pointerId)&&qm("[RenderWindowInteractor] duplicate pointerId detected"),o.set(n.pointerId,{pointerId:n.pointerId,position:s(n)}),n.pointerType){case"pen":case"touch":e.handleTouchStart(n);break;default:e.handleMouseDown(n)}},e.handlePointerUp=n=>{if(o.has(n.pointerId))switch(t.preventDefaultOnPointerUp&&th(n),o.delete(n.pointerId),t.container.releasePointerCapture(n.pointerId),n.pointerType){case"pen":case"touch":e.handleTouchEnd(n);break;default:e.handleMouseUp(n)}},e.handlePointerCancel=t=>{if(o.has(t.pointerId))switch(o.delete(t.pointerId),t.pointerType){case"pen":case"touch":e.handleTouchEnd(t);break;default:e.handleMouseUp(t)}},e.handlePointerMove=t=>{switch(o.has(t.pointerId)&&(o.get(t.pointerId).position=s(t)),t.pointerType){case"pen":case"touch":e.handleTouchMove(t);break;default:e.handleMouseMove(t)}},e.handleMouseDown=t=>{const n={...l(t),position:s(t),deviceType:u(t)};switch(t.button){case 0:e.leftButtonPressEvent(n);break;case 1:e.middleButtonPressEvent(n);break;case 2:e.rightButtonPressEvent(n);break;default:Xm(`Unknown mouse button pressed: ${t.button}`)}},e.requestPointerLock=()=>{t.container&&t.container.requestPointerLock()},e.exitPointerLock=()=>document.exitPointerLock?.(),e.isPointerLocked=()=>!!t.container&&document.pointerLockElement===t.container,e.handlePointerLockChange=()=>{e.isPointerLocked()?e.startPointerLockEvent():e.endPointerLockEvent()},e.requestAnimation=n=>{void 0!==n?r.has(n)?qm("requester is already registered for animating"):(r.add(n),t.animationRequest||1!==r.size||t.xrAnimation||(t._animationStartTime=Date.now(),t._animationFrameCount=0,t.animationRequest=requestAnimationFrame(e.handleAnimation),e.startAnimationEvent())):Xm("undefined requester, can not start animating")},e.extendAnimation=n=>{const o=Date.now()+n;t._animationExtendedEnd=Math.max(t._animationExtendedEnd,o),t.animationRequest||0!==r.size||t.xrAnimation||(t._animationStartTime=Date.now(),t._animationFrameCount=0,t.animationRequest=requestAnimationFrame(e.handleAnimation),e.startAnimationEvent())},e.isAnimating=()=>t.xrAnimation||null!==t.animationRequest,e.cancelAnimation=function(n){let o=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(r.has(n))r.delete(n),t.animationRequest&&0===r.size&&Date.now()>t._animationExtendedEnd&&(cancelAnimationFrame(t.animationRequest),t.animationRequest=null,e.endAnimationEvent(),e.render());else if(!o){const e=n&&n.getClassName?n.getClassName():n;qm(`${e} did not request an animation`)}},e.switchToXRAnimation=()=>{t.animationRequest&&(cancelAnimationFrame(t.animationRequest),t.animationRequest=null),t.xrAnimation=!0},e.returnFromXRAnimation=()=>{t.xrAnimation=!1,0!==r.size&&(t.recentAnimationFrameRate=10,t.animationRequest=requestAnimationFrame(e.handleAnimation))},e.updateXRGamepads=(n,r,o)=>{n.inputSources.forEach((n=>{const a=null==n.gripSpace?null:r.getPose(n.gripSpace,o),i=null==n.gripSpace?null:r.getPose(n.targetRaySpace,o),s=n.gamepad,l=n.handedness;if(s){s.index in t.lastGamepadValues||(t.lastGamepadValues[s.index]={left:{buttons:{}},right:{buttons:{}},none:{buttons:{}}});for(let r=0;r<s.buttons.length;++r)r in t.lastGamepadValues[s.index][l].buttons||(t.lastGamepadValues[s.index][l].buttons[r]=!1),t.lastGamepadValues[s.index][l].buttons[r]!==s.buttons[r].pressed&&null!=a&&(e.button3DEvent({gamepad:s,position:a.transform.position,orientation:a.transform.orientation,targetPosition:i.transform.position,targetOrientation:i.transform.orientation,pressed:s.buttons[r].pressed,device:"left"===n.handedness?Km.LeftController:Km.RightController,input:Jm[s.mapping]&&Jm[s.mapping][r]?Jm[s.mapping][r]:$m.Trigger}),t.lastGamepadValues[s.index][l].buttons[r]=s.buttons[r].pressed),t.lastGamepadValues[s.index][l].buttons[r]&&null!=a&&e.move3DEvent({gamepad:s,position:a.transform.position,orientation:a.transform.orientation,targetPosition:i.transform.position,targetOrientation:i.transform.orientation,device:"left"===n.handedness?Km.LeftController:Km.RightController})}}))},e.handleMouseMove=n=>{const r={...l(n),position:s(n),deviceType:u(n)};0===t.moveTimeoutID?e.startMouseMoveEvent(r):(e.mouseMoveEvent(r),clearTimeout(t.moveTimeoutID)),t.moveTimeoutID=setTimeout((()=>{e.endMouseMoveEvent(),t.moveTimeoutID=0}),200)},e.handleAnimation=()=>{const n=Date.now();t._animationFrameCount++,n-t._animationStartTime>1e3&&t._animationFrameCount>1&&(t.recentAnimationFrameRate=1e3*(t._animationFrameCount-1)/(n-t._animationStartTime),t.lastFrameTime=1/t.recentAnimationFrameRate,e.animationFrameRateUpdateEvent(),t._animationStartTime=n,t._animationFrameCount=1),e.animationEvent(),f(),r.size>0||Date.now()<t._animationExtendedEnd?t.animationRequest=requestAnimationFrame(e.handleAnimation):(cancelAnimationFrame(t.animationRequest),t.animationRequest=null,e.endAnimationEvent(),e.render())},e.handleWheel=n=>{th(n);const r={...Ym(n),...l(n),position:s(n),deviceType:u(n)};0===t.wheelTimeoutID&&(a=Math.abs(r.spinY)>=.3?Math.abs(r.spinY):1),r.spinY/=a,0===t.wheelTimeoutID?(e.startMouseWheelEvent(r),e.mouseWheelEvent(r)):(e.mouseWheelEvent(r),clearTimeout(t.wheelTimeoutID)),t.mouseScrollDebounceByPass?(e.extendAnimation(600),e.endMouseWheelEvent(),t.wheelTimeoutID=0):t.wheelTimeoutID=setTimeout((()=>{e.extendAnimation(600),e.endMouseWheelEvent(),t.wheelTimeoutID=0}),200)},e.handleMouseUp=t=>{const n={...l(t),position:s(t),deviceType:u(t)};switch(t.button){case 0:e.leftButtonReleaseEvent(n);break;case 1:e.middleButtonReleaseEvent(n);break;case 2:e.rightButtonReleaseEvent(n);break;default:Xm(`Unknown mouse button released: ${t.button}`)}},e.handleTouchStart=n=>{const r=[...o.values()];if(t.recognizeGestures&&r.length>1){const t=nh(o);if(2===r.length){const t={...l(Qm),position:r[0].position,deviceType:u(n)};e.leftButtonReleaseEvent(t)}e.recognizeGesture("TouchStart",t)}else if(1===r.length){const t={...l(Qm),position:s(n),deviceType:u(n)};e.leftButtonPressEvent(t)}},e.handleTouchMove=n=>{const r=[...o.values()];if(t.recognizeGestures&&r.length>1){const t=nh(o);e.recognizeGesture("TouchMove",t)}else if(1===r.length){const t={...l(Qm),position:r[0].position,deviceType:u(n)};e.mouseMoveEvent(t)}},e.handleTouchEnd=n=>{const r=[...o.values()];if(t.recognizeGestures)if(0===r.length){const t={...l(Qm),position:s(n),deviceType:u(n)};e.leftButtonReleaseEvent(t)}else if(1===r.length){const t=nh(o);e.recognizeGesture("TouchEnd",t);const a={...l(Qm),position:r[0].position,deviceType:u(n)};e.leftButtonPressEvent(a)}else{const t=nh(o);e.recognizeGesture("TouchMove",t)}else if(1===r.length){const t={...l(Qm),position:r[0].position,deviceType:u(n)};e.leftButtonReleaseEvent(t)}},e.setView=n=>{t._view!==n&&(t._view=n,t._view.getRenderable().setInteractor(e),e.modified())},e.getFirstRenderer=()=>t._view?.getRenderable()?.getRenderersByReference()?.[0],e.findPokedRenderer=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!t._view)return null;const r=t._view?.getRenderable()?.getRenderers();if(!r||0===r.length)return null;r.sort(((e,t)=>e.getLayer()-t.getLayer()));let o=null,a=null,i=null,s=r.length;for(;s--;){const l=r[s];if(t._view.isInViewport(e,n,l)&&l.getInteractive()){i=l;break}null===o&&l.getInteractive()&&(o=l),null===a&&t._view.isInViewport(e,n,l)&&(a=l)}return null===i&&(i=o),null===i&&(i=a),null==i&&(i=r[0]),i},e.render=()=>{e.isAnimating()||t.inRender||f()},eh.forEach((n=>{const r=n.charAt(0).toLowerCase()+n.slice(1);e[`${r}Event`]=r=>{if(!t.enabled)return;if(!e.getCurrentRenderer())return void Zm("\n          Can not forward events without a current renderer on the interactor.\n        ");const o={type:n,pokedRenderer:t.currentRenderer,firstRenderer:e.getFirstRenderer(),...r};e[`invoke${n}`](o)}})),e.recognizeGesture=(n,r)=>{if(Object.keys(r).length>2)return;if(t.startingEventPositions||(t.startingEventPositions={}),"TouchStart"===n)return Object.keys(r).forEach((e=>{t.startingEventPositions[e]=r[e]})),void(t.currentGesture="Start");if("TouchEnd"===n)return"Pinch"===t.currentGesture&&(e.render(),e.endPinchEvent()),"Rotate"===t.currentGesture&&(e.render(),e.endRotateEvent()),"Pan"===t.currentGesture&&(e.render(),e.endPanEvent()),t.currentGesture="Start",void(t.startingEventPositions={});let o=0;const a=[],i=[];Object.keys(r).forEach((e=>{a[o]=r[e],i[o]=t.startingEventPositions[e],o++}));const s=Math.sqrt((i[0].x-i[1].x)*(i[0].x-i[1].x)+(i[0].y-i[1].y)*(i[0].y-i[1].y)),l=Math.sqrt((a[0].x-a[1].x)*(a[0].x-a[1].x)+(a[0].y-a[1].y)*(a[0].y-a[1].y));let c=bo(Math.atan2(i[1].y-i[0].y,i[1].x-i[0].x)),u=bo(Math.atan2(a[1].y-a[0].y,a[1].x-a[0].x)),d=u-c;u=u+180>=360?u-180:u+180,c=c+180>=360?c-180:c+180,Math.abs(u-c)<Math.abs(d)&&(d=u-c);const p=[];if(p[0]=(a[0].x-i[0].x+a[1].x-i[1].x)/2,p[1]=(a[0].y-i[0].y+a[1].y-i[1].y)/2,"TouchMove"===n)if("Start"===t.currentGesture){let n=.01*Math.sqrt(t.container.clientWidth*t.container.clientWidth+t.container.clientHeight*t.container.clientHeight);n<15&&(n=15);const o=Math.abs(l-s),a=3.1415926*l*Math.abs(d)/360,i=Math.sqrt(p[0]*p[0]+p[1]*p[1]);if(o>n&&o>a&&o>i){t.currentGesture="Pinch";const n={scale:1,touches:r};e.startPinchEvent(n)}else if(a>n&&a>i){t.currentGesture="Rotate";const n={rotation:0,touches:r};e.startRotateEvent(n)}else if(i>n){t.currentGesture="Pan";const n={translation:[0,0],touches:r};e.startPanEvent(n)}}else{if("Rotate"===t.currentGesture){const t={rotation:d,touches:r};e.rotateEvent(t)}if("Pinch"===t.currentGesture){const t={scale:l/s,touches:r};e.pinchEvent(t)}if("Pan"===t.currentGesture){const t={translation:p,touches:r};e.panEvent(t)}}},e.handleVisibilityChange=()=>{t._animationStartTime=Date.now(),t._animationFrameCount=0},e.setCurrentRenderer=e=>{t._forcedRenderer=!!e,t.currentRenderer=e},e.setContainer=e=>{p();const t=n.setContainer(e??null);return t&&d(),t},e.delete=()=>{for(;r.size;)e.cancelAnimation(r.values().next().value);void 0!==document.hidden&&document.removeEventListener("visibilitychange",e.handleVisibilityChange),t.container&&e.setContainer(null),n.delete()},void 0!==document.hidden&&document.addEventListener("visibilitychange",e.handleVisibilityChange,!1)}(e,t)}var ah={newInstance:Ht.newInstance(oh,"vtkRenderWindowInteractor"),extend:oh,handledEvents:eh,...jm};const{vtkErrorMacro:ih,VOID:sh}=Ht,lh={enabled:!0,priority:0,processEvents:!0,subscribedEvents:[]};function ch(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,lh,n),Ht.obj(e,t),Ht.event(e,t,"InteractionEvent"),Ht.event(e,t,"StartInteractionEvent"),Ht.event(e,t,"EndInteractionEvent"),Ht.get(e,t,["_interactor","enabled"]),Ht.setGet(e,t,["priority","processEvents"]),Ht.moveToProtected(e,t,["interactor"]),function(e,t){t.classHierarchy.push("vtkInteractorObserver");const n={...e};function r(){for(;t.subscribedEvents.length;)t.subscribedEvents.pop().unsubscribe()}function o(){ah.handledEvents.forEach((n=>{e[`handle${n}`]&&t.subscribedEvents.push(t._interactor[`on${n}`]((r=>t.processEvents?e[`handle${n}`](r):sh),t.priority))}))}e.setInteractor=n=>{n!==t._interactor&&(r(),t._interactor=n,n&&t.enabled&&o(),e.modified())},e.setEnabled=n=>{n!==t.enabled&&(r(),n&&(t._interactor?o():ih("\n          The interactor must be set before subscribing to events\n        ")),t.enabled=n,e.modified())},e.computeDisplayToWorld=(e,n,r,o)=>e?t._interactor.getView().displayToWorld(n,r,o,e):null,e.computeWorldToDisplay=(e,n,r,o)=>e?t._interactor.getView().worldToDisplay(n,r,o,e):null,e.setPriority=e=>{n.setPriority(e)&&t._interactor&&(r(),o())}}(e,t)}var uh={newInstance:Ht.newInstance(ch,"vtkInteractorObserver"),extend:ch,computeWorldToDisplay:function(e,t,n,r){return e.getRenderWindow().getViews()[0].worldToDisplay(t,n,r,e)},computeDisplayToWorld:function(e,t,n,r){return e.getRenderWindow().getViews()[0].displayToWorld(t,n,r,e)}},dh={States:{IS_START:0,IS_NONE:0,IS_ROTATE:1,IS_PAN:2,IS_SPIN:3,IS_DOLLY:4,IS_CAMERA_POSE:11,IS_WINDOW_LEVEL:1024,IS_SLICE:1025}};const{States:ph}=dh,fh={Rotate:ph.IS_ROTATE,Pan:ph.IS_PAN,Spin:ph.IS_SPIN,Dolly:ph.IS_DOLLY,CameraPose:ph.IS_CAMERA_POSE,WindowLevel:ph.IS_WINDOW_LEVEL,Slice:ph.IS_SLICE},gh={state:ph.IS_NONE,handleObservers:1,autoAdjustCameraClippingRange:1};function mh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,gh,n),uh.extend(e,t,n),Ht.setGet(e,t,["focusedRenderer"]),function(e,t){t.classHierarchy.push("vtkInteractorStyle"),Object.keys(fh).forEach((n=>{Ht.event(e,t,`Start${n}Event`),e[`start${n}`]=()=>{t.state===ph.IS_NONE&&(t.state=fh[n],t._interactor.requestAnimation(e),e.invokeStartInteractionEvent({type:"StartInteractionEvent"}),e[`invokeStart${n}Event`]({type:`Start${n}Event`}))},Ht.event(e,t,`End${n}Event`),e[`end${n}`]=()=>{t.state===fh[n]&&(t.state=ph.IS_NONE,t._interactor.cancelAnimation(e),e.invokeEndInteractionEvent({type:"EndInteractionEvent"}),e[`invokeEnd${n}Event`]({type:`End${n}Event`}),t._interactor.render())}})),t.getRenderer=e=>t.focusedRenderer||e.pokedRenderer,e.handleKeyPress=e=>{const n=t._interactor;let r=null;switch(e.key){case"r":case"R":t.getRenderer(e).resetCamera(),n.render();break;case"w":case"W":r=t.getRenderer(e).getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToWireframe&&t.setRepresentationToWireframe()})),n.render();break;case"s":case"S":r=t.getRenderer(e).getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToSurface&&t.setRepresentationToSurface()})),n.render();break;case"v":case"V":r=t.getRenderer(e).getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToPoints&&t.setRepresentationToPoints()})),n.render()}}}(e,t)}var hh={newInstance:Ht.newInstance(mh,"vtkInteractorStyle"),extend:mh,...dh};const{States:vh}=dh,Th={motionFactor:10,zoomFactor:10};function yh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Th,n),hh.extend(e,t,n),Ht.setGet(e,t,["motionFactor","zoomFactor"]),function(e,t){t.classHierarchy.push("vtkInteractorStyleTrackballCamera"),e.handleMouseMove=n=>{const r=n.position,o=t.getRenderer(n);switch(t.state){case vh.IS_ROTATE:e.handleMouseRotate(o,r),e.invokeInteractionEvent({type:"InteractionEvent"});break;case vh.IS_PAN:e.handleMousePan(o,r),e.invokeInteractionEvent({type:"InteractionEvent"});break;case vh.IS_DOLLY:e.handleMouseDolly(o,r),e.invokeInteractionEvent({type:"InteractionEvent"});break;case vh.IS_SPIN:e.handleMouseSpin(o,r),e.invokeInteractionEvent({type:"InteractionEvent"})}t.previousPosition=r},e.handleButton3D=n=>{!n||!n.pressed||n.device!==Wm.RightController||n.input!==Hm.Trigger&&n.input!==Hm.TrackPad?!n||n.pressed||n.device!==Wm.RightController||n.input!==Hm.Trigger&&n.input!==Hm.TrackPad||t.state!==vh.IS_CAMERA_POSE||e.endCameraPose():e.startCameraPose()},e.handleMove3D=n=>{t.state===vh.IS_CAMERA_POSE&&e.updateCameraPose(n)},e.updateCameraPose=e=>{const n=t.getRenderer(e).getActiveCamera(),r=n.getPhysicalTranslation(),o=.025*n.getPhysicalScale(),a=n.physicalOrientationToWorldDirection([e.orientation.x,e.orientation.y,e.orientation.z,e.orientation.w]);n.setPhysicalTranslation(r[0]+a[0]*o,r[1]+a[1]*o,r[2]+a[2]*o)},e.handleLeftButtonPress=n=>{const r=n.position;t.previousPosition=r,n.shiftKey?n.controlKey||n.altKey?e.startDolly():e.startPan():n.controlKey||n.altKey?e.startSpin():e.startRotate()},e.handleLeftButtonRelease=()=>{switch(t.state){case vh.IS_DOLLY:e.endDolly();break;case vh.IS_PAN:e.endPan();break;case vh.IS_SPIN:e.endSpin();break;case vh.IS_ROTATE:e.endRotate()}},e.handleStartMouseWheel=()=>{e.startDolly()},e.handleEndMouseWheel=()=>{e.endDolly()},e.handleStartPinch=n=>{t.previousScale=n.scale,e.startDolly()},e.handleEndPinch=()=>{e.endDolly()},e.handleStartRotate=n=>{t.previousRotation=n.rotation,e.startRotate()},e.handleEndRotate=()=>{e.endRotate()},e.handleStartPan=n=>{t.previousTranslation=n.translation,e.startPan()},e.handleEndPan=()=>{e.endPan()},e.handlePinch=n=>{e.dollyByFactor(t.getRenderer(n),n.scale/t.previousScale),t.previousScale=n.scale},e.handlePan=n=>{const r=t.getRenderer(n).getActiveCamera();let o=r.getFocalPoint();o=e.computeWorldToDisplay(t.getRenderer(n),o[0],o[1],o[2]);const a=o[2],i=n.translation,s=t.previousTranslation,l=e.computeDisplayToWorld(t.getRenderer(n),o[0]+i[0]-s[0],o[1]+i[1]-s[1],a),c=e.computeDisplayToWorld(t.getRenderer(n),o[0],o[1],a),u=[];u[0]=c[0]-l[0],u[1]=c[1]-l[1],u[2]=c[2]-l[2],o=r.getFocalPoint();const d=r.getPosition();r.setFocalPoint(u[0]+o[0],u[1]+o[1],u[2]+o[2]),r.setPosition(u[0]+d[0],u[1]+d[1],u[2]+d[2]),t._interactor.getLightFollowCamera()&&t.getRenderer(n).updateLightsGeometryToFollowCamera(),r.orthogonalizeViewUp(),t.previousTranslation=n.translation},e.handleRotate=e=>{const n=t.getRenderer(e).getActiveCamera();n.roll(e.rotation-t.previousRotation),n.orthogonalizeViewUp(),t.previousRotation=e.rotation},e.handleMouseRotate=(e,n)=>{if(!t.previousPosition)return;const r=t._interactor,o=n.x-t.previousPosition.x,a=n.y-t.previousPosition.y,i=r.getView().getViewportSize(e);let s=-.1,l=-.1;i[0]&&i[1]&&(s=-20/i[1],l=-20/i[0]);const c=o*l*t.motionFactor,u=a*s*t.motionFactor,d=e.getActiveCamera();Number.isNaN(c)||Number.isNaN(u)||(d.azimuth(c),d.elevation(u),d.orthogonalizeViewUp()),t.autoAdjustCameraClippingRange&&e.resetCameraClippingRange(),r.getLightFollowCamera()&&e.updateLightsGeometryToFollowCamera()},e.handleMouseSpin=(e,n)=>{if(!t.previousPosition)return;const r=t._interactor,o=e.getActiveCamera(),a=r.getView().getViewportCenter(e),i=bo(Math.atan2(t.previousPosition.y-a[1],t.previousPosition.x-a[0])),s=bo(Math.atan2(n.y-a[1],n.x-a[0]))-i;Number.isNaN(s)||(o.roll(s),o.orthogonalizeViewUp())},e.handleMousePan=(n,r)=>{if(!t.previousPosition)return;const o=n.getActiveCamera();let a=o.getFocalPoint();a=e.computeWorldToDisplay(n,a[0],a[1],a[2]);const i=a[2],s=e.computeDisplayToWorld(n,r.x,r.y,i),l=e.computeDisplayToWorld(n,t.previousPosition.x,t.previousPosition.y,i),c=[];c[0]=l[0]-s[0],c[1]=l[1]-s[1],c[2]=l[2]-s[2],a=o.getFocalPoint();const u=o.getPosition();o.setFocalPoint(c[0]+a[0],c[1]+a[1],c[2]+a[2]),o.setPosition(c[0]+u[0],c[1]+u[1],c[2]+u[2]),t._interactor.getLightFollowCamera()&&n.updateLightsGeometryToFollowCamera()},e.handleMouseDolly=(n,r)=>{if(!t.previousPosition)return;const o=r.y-t.previousPosition.y,a=t._interactor.getView().getViewportCenter(n),i=t.motionFactor*o/a[1];e.dollyByFactor(n,1.1**i)},e.handleMouseWheel=n=>{const r=1-n.spinY/t.zoomFactor;e.dollyByFactor(t.getRenderer(n),r)},e.dollyByFactor=(e,n)=>{if(Number.isNaN(n))return;const r=e.getActiveCamera();r.getParallelProjection()?r.setParallelScale(r.getParallelScale()/n):(r.dolly(n),t.autoAdjustCameraClippingRange&&e.resetCameraClippingRange()),t._interactor.getLightFollowCamera()&&e.updateLightsGeometryToFollowCamera()}}(e,t)}var bh={newInstance:Ht.newInstance(yh,"vtkInteractorStyleTrackballCamera"),extend:yh};function xh(e){return e}function Ch(e){return null===e||"null"===e?null:"true"===e||"false"!==e&&(void 0!==e&&"undefined"!==e?"["===e[0]&&"]"===e[e.length-1]?e.substring(1,e.length-1).split(",").map((e=>Ch(e.trim()))):""===e||Number.isNaN(Number(e))?e:Number(e):void 0)}var Sh=function(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:window.location.search;const n={},r=e?Ch:xh;return new URLSearchParams(t).forEach(((e,t)=>{t&&(n[t]=!e||r(e))})),n};const Ah={delegates:[],currentOperation:null,preDelegateOperations:[],postDelegateOperations:[],currentParent:null};function Ih(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ah,n),Ht.obj(e,t),Ht.get(e,t,["currentOperation"]),Ht.setGet(e,t,["delegates","_currentParent","preDelegateOperations","postDelegateOperations"]),Ht.moveToProtected(e,t,["currentParent"]),function(e,t){t.classHierarchy.push("vtkRenderPass"),e.getOperation=()=>t.currentOperation,e.setCurrentOperation=e=>{t.currentOperation=e,t.currentTraverseOperation=`traverse${Ht.capitalize(t.currentOperation)}`},e.getTraverseOperation=()=>t.currentTraverseOperation,e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;t.deleted||(t._currentParent=r,t.preDelegateOperations.forEach((t=>{e.setCurrentOperation(t),n.traverse(e)})),t.delegates.forEach((t=>{t.traverse(n,e)})),t.postDelegateOperations.forEach((t=>{e.setCurrentOperation(t),n.traverse(e)})))}}(e,t)}var wh={newInstance:Ht.newInstance(Ih,"vtkRenderPass"),extend:Ih};const{Representation:Oh}=ts,{vtkErrorMacro:Ph}=Ht;function Rh(e){const t=wu.substitute(e.Fragment,"//VTK::RenderPassFragmentShader::Impl","\n      float weight = gl_FragData[0].a * pow(max(1.1 - gl_FragCoord.z, 0.0), 2.0);\n      gl_FragData[0] = vec4(gl_FragData[0].rgb*weight, gl_FragData[0].a);\n      gl_FragData[1].r = weight;\n    ",!1);e.Fragment=t.result}const Mh={framebuffer:null,copyShader:null,tris:null};function Eh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Mh,n),wh.extend(e,t,n),t.VBOBuildTime={},Ht.obj(t.VBOBuildTime,{mtime:0}),t.tris=Du.newInstance(),Ht.get(e,t,["framebuffer"]),function(e,t){t.classHierarchy.push("vtkOpenGLOrderIndependentTranslucentPass"),e.createVertexBuffer=()=>{const e=new Float32Array([-1,-1,-1,1,-1,-1,-1,1,-1,1,1,-1]),n=new Float32Array([0,0,1,0,0,1,1,1]),r=new Uint16Array([4,0,1,3,2]),o=Ts.newInstance({numberOfComponents:3,values:e});o.setName("points");const a=Ts.newInstance({numberOfComponents:2,values:n});a.setName("tcoords");const i=Ts.newInstance({numberOfComponents:1,values:r});t.tris.getCABO().createVBO(i,"polys",Oh.SURFACE,{points:o,tcoords:a,cellOffset:0}),t.VBOBuildTime.modified()},e.createFramebuffer=e=>{const n=e.getSize(),r=e.getContext();t.framebuffer=Zd.newInstance(),t.framebuffer.setOpenGLRenderWindow(e),t.framebuffer.create(...n),t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.bind(),t.translucentRGBATexture=Ju.newInstance(),t.translucentRGBATexture.setInternalFormat(r.RGBA16F),t.translucentRGBATexture.setFormat(r.RGBA),t.translucentRGBATexture.setOpenGLDataType(r.HALF_FLOAT),t.translucentRGBATexture.setOpenGLRenderWindow(e),t.translucentRGBATexture.create2DFromRaw({width:n[0],height:n[1],numComps:4,dataType:"Float32Array",data:null}),t.translucentRTexture=Ju.newInstance(),t.translucentRTexture.setInternalFormat(r.R16F),t.translucentRTexture.setFormat(r.RED),t.translucentRTexture.setOpenGLDataType(r.HALF_FLOAT),t.translucentRTexture.setOpenGLRenderWindow(e),t.translucentRTexture.create2DFromRaw({width:n[0],height:n[1],numComps:1,dataType:"Float32Array",data:null}),t.translucentZTexture=Ju.newInstance(),t.translucentZTexture.setOpenGLRenderWindow(e),t.translucentZTexture.createDepthFromRaw({width:n[0],height:n[1],dataType:"Float32Array",data:null}),t.framebuffer.setColorBuffer(t.translucentRGBATexture,0),t.framebuffer.setColorBuffer(t.translucentRTexture,1),t.framebuffer.setDepthBuffer(t.translucentZTexture)},e.createCopyShader=e=>{t.copyShader=e.getShaderCache().readyShaderProgramArray(["//VTK::System::Dec","attribute vec4 vertexDC;","attribute vec2 tcoordTC;","varying vec2 tcoord;","void main() { tcoord = tcoordTC; gl_Position = vertexDC; }"].join("\n"),"//VTK::System::Dec\n\nin vec2 tcoord;\n\nuniform sampler2D translucentRTexture;\nuniform sampler2D translucentRGBATexture;\n\n// the output of this shader\n//VTK::Output::Dec\n\nvoid main()\n{\n  vec4 t1Color = texture(translucentRGBATexture, tcoord);\n  float t2Color = texture(translucentRTexture, tcoord).r;\n  gl_FragData[0] = vec4(t1Color.rgb/max(t2Color,0.01), 1.0 - t1Color.a);\n}\n","")},e.createVBO=n=>{const r=n.getContext();t.tris.setOpenGLRenderWindow(n),e.createVertexBuffer();const o=t.copyShader;t.tris.getCABO().bind(),t.copyVAO.addAttributeArray(o,t.tris.getCABO(),"vertexDC",t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),r.FLOAT,3,r.FALSE)||Ph("Error setting vertexDC in copy shader VAO."),t.copyVAO.addAttributeArray(o,t.tris.getCABO(),"tcoordTC",t.tris.getCABO().getTCoordOffset(),t.tris.getCABO().getStride(),r.FLOAT,2,r.FALSE)||Ph("Error setting vertexDC in copy shader VAO.")},e.traverse=(n,r,o)=>{if(t.deleted)return;const a=n.getSize(),i=n.getContext();if(t._supported=!1,r.getSelector()||!i||!n.getWebgl2()||!i.getExtension("EXT_color_buffer_half_float")&&!i.getExtension("EXT_color_buffer_float"))return e.setCurrentOperation("translucentPass"),void r.traverse(e);if(t._supported=!0,null===t.framebuffer)e.createFramebuffer(n);else{const r=t.framebuffer.getSize();null===r||r[0]!==a[0]||r[1]!==a[1]?(t.framebuffer.releaseGraphicsResources(),t.translucentRGBATexture.releaseGraphicsResources(n),t.translucentRTexture.releaseGraphicsResources(n),t.translucentZTexture.releaseGraphicsResources(n),e.createFramebuffer(n)):(t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.bind())}i.drawBuffers([i.COLOR_ATTACHMENT0]),i.clearBufferfv(i.COLOR,0,[0,0,0,0]),i.clearBufferfv(i.DEPTH,0,[1]),i.colorMask(!1,!1,!1,!1),o.getOpaqueActorCount()>0&&(o.setCurrentOperation("opaqueZBufferPass"),r.traverse(o)),i.colorMask(!0,!0,!0,!0),i.drawBuffers([i.COLOR_ATTACHMENT0,i.COLOR_ATTACHMENT1]),i.viewport(0,0,a[0],a[1]),i.scissor(0,0,a[0],a[1]),i.clearBufferfv(i.COLOR,0,[0,0,0,1]),i.clearBufferfv(i.COLOR,1,[0,0,0,0]),i.enable(i.DEPTH_TEST),i.enable(i.BLEND),i.blendFuncSeparate(i.ONE,i.ONE,i.ZERO,i.ONE_MINUS_SRC_ALPHA),e.setCurrentOperation("translucentPass"),r.traverse(e),i.drawBuffers([i.NONE]),t.framebuffer.restorePreviousBindingsAndBuffers(),null===t.copyShader?e.createCopyShader(n):n.getShaderCache().readyShaderProgram(t.copyShader),t.copyVAO||(t.copyVAO=Ru.newInstance(),t.copyVAO.setOpenGLRenderWindow(n)),t.copyVAO.bind(),t.VBOBuildTime.getMTime()<e.getMTime()&&e.createVBO(n),i.blendFuncSeparate(i.SRC_ALPHA,i.ONE_MINUS_SRC_ALPHA,i.ONE,i.ONE_MINUS_SRC_ALPHA),i.depthMask(!1),i.depthFunc(i.ALWAYS),i.viewport(0,0,a[0],a[1]),i.scissor(0,0,a[0],a[1]),t.translucentRGBATexture.activate(),t.copyShader.setUniformi("translucentRGBATexture",t.translucentRGBATexture.getTextureUnit()),t.translucentRTexture.activate(),t.copyShader.setUniformi("translucentRTexture",t.translucentRTexture.getTextureUnit()),i.drawArrays(i.TRIANGLES,0,t.tris.getCABO().getElementCount()),i.depthMask(!0),i.depthFunc(i.LEQUAL),t.translucentRGBATexture.deactivate(),t.translucentRTexture.deactivate();const s=r.getTiledSizeAndOrigin();i.scissor(s.lowerLeftU,s.lowerLeftV,s.usize,s.vsize),i.viewport(s.lowerLeftU,s.lowerLeftV,s.usize,s.vsize)},e.getShaderReplacement=()=>t._supported?Rh:null,e.releaseGraphicsResources=n=>{t.framebuffer&&(t.framebuffer.releaseGraphicsResources(n),t.framebuffer=null),t.translucentRGBATexture&&(t.translucentRGBATexture.releaseGraphicsResources(n),t.translucentRGBATexture=null),t.translucentRTexture&&(t.translucentRTexture.releaseGraphicsResources(n),t.translucentRTexture=null),t.translucentZTexture&&(t.translucentZTexture.releaseGraphicsResources(n),t.translucentZTexture=null),t.copyVAO&&(t.copyVAO.releaseGraphicsResources(n),t.copyVAO=null),t.copyShader&&(t.copyShader.releaseGraphicsResources(n),t.copyShader=null),t.tris&&(t.tris.releaseGraphicsResources(n),t.tris=null),e.modified()}}(e,t)}var Vh={newInstance:Ht.newInstance(Eh,"vtkOpenGLOrderIndependentTranslucentPass"),extend:Eh};const Dh={opaqueActorCount:0,translucentActorCount:0,volumeCount:0,overlayActorCount:0,framebuffer:null,depthRequested:!1};function Lh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Dh,n),wh.extend(e,t,n),Ht.get(e,t,["framebuffer","opaqueActorCount","translucentActorCount","volumeCount"]),function(e,t){t.classHierarchy.push("vtkForwardPass"),e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(t.deleted)return;t._currentParent=r,e.setCurrentOperation("buildPass"),n.traverse(e);const o=n.getRenderable().getNumberOfLayers(),a=n.getRenderable().getRenderersByReference();for(let r=0;r<o;r++)for(let o=0;o<a.length;o++){const i=a[o],s=n.getViewNodeFor(i);if(i.getDraw()&&i.getLayer()===r){if(t.opaqueActorCount=0,t.translucentActorCount=0,t.volumeCount=0,t.overlayActorCount=0,e.setCurrentOperation("queryPass"),s.traverse(e),(t.opaqueActorCount>0||t.translucentActorCount>0)&&t.volumeCount>0||t.depthRequested){const r=n.getFramebufferSize();null===t.framebuffer&&(t.framebuffer=Zd.newInstance()),t.framebuffer.setOpenGLRenderWindow(n),t.framebuffer.saveCurrentBindingsAndBuffers();const o=t.framebuffer.getSize();null!==o&&o[0]===r[0]&&o[1]===r[1]||(t.framebuffer.create(r[0],r[1]),t.framebuffer.populateFramebuffer()),t.framebuffer.bind(),e.setCurrentOperation("zBufferPass"),s.traverse(e),t.framebuffer.restorePreviousBindingsAndBuffers(),t.depthRequested=!1}e.setCurrentOperation("cameraPass"),s.traverse(e),t.opaqueActorCount>0&&(e.setCurrentOperation("opaquePass"),s.traverse(e)),t.translucentActorCount>0&&(t.translucentPass||(t.translucentPass=Vh.newInstance()),t.translucentPass.traverse(n,s,e)),t.volumeCount>0&&(e.setCurrentOperation("volumePass"),s.traverse(e)),t.overlayActorCount>0&&(e.setCurrentOperation("overlayPass"),s.traverse(e))}}},e.getZBufferTexture=()=>t.framebuffer?t.framebuffer.getColorTexture():null,e.requestDepth=()=>{t.depthRequested=!0},e.incrementOpaqueActorCount=()=>t.opaqueActorCount++,e.incrementTranslucentActorCount=()=>t.translucentActorCount++,e.incrementVolumeCount=()=>t.volumeCount++,e.incrementOverlayActorCount=()=>t.overlayActorCount++}(e,t)}var Bh={newInstance:Ht.newInstance(Lh,"vtkForwardPass"),extend:Lh},Nh=n(292),Fh=n.n(Nh);const _h=["lastShaderProgramBound","context","_openGLRenderWindow"],kh={lastShaderProgramBound:null,shaderPrograms:null,context:null};function Gh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kh,n),t.shaderPrograms={},Ht.obj(e,t),Ht.setGet(e,t,_h),Ht.moveToProtected(e,t,["openGLRenderWindow"]),function(e,t){t.classHierarchy.push("vtkShaderCache"),e.replaceShaderValues=(e,n,r)=>{let o=n;r.length>0&&(o=wu.substitute(o,"VSOut","GSOut").result);const a=t._openGLRenderWindow.getWebgl2();let i="\n",s="#version 100\n";a?s="#version 300 es\n#define attribute in\n#define textureCube texture\n#define texture2D texture\n#define textureCubeLod textureLod\n#define texture2DLod textureLod\n":(t.context.getExtension("OES_standard_derivatives"),t.context.getExtension("EXT_frag_depth")&&(i="#extension GL_EXT_frag_depth : enable\n"),t.context.getExtension("EXT_shader_texture_lod")&&(i+="#extension GL_EXT_shader_texture_lod : enable\n#define textureCubeLod textureCubeLodEXT\n#define texture2DLod texture2DLodEXT")),o=wu.substitute(o,"//VTK::System::Dec",[`${s}\n`,a?"":"#extension GL_OES_standard_derivatives : enable\n",i,"#ifdef GL_FRAGMENT_PRECISION_HIGH","precision highp float;","precision highp int;","#else","precision mediump float;","precision mediump int;","#endif"]).result;let l=wu.substitute(e,"//VTK::System::Dec",[`${s}\n`,"#ifdef GL_FRAGMENT_PRECISION_HIGH","precision highp float;","precision highp int;","#else","precision mediump float;","precision mediump int;","#endif"]).result;if(a){l=wu.substitute(l,"varying","out").result,o=wu.substitute(o,"varying","in").result;let e="",t=0;for(;o.includes(`gl_FragData[${t}]`);)o=wu.substitute(o,`gl_FragData\\[${t}\\]`,`fragOutput${t}`).result,e+=`layout(location = ${t}) out vec4 fragOutput${t};\n`,t++;o=wu.substitute(o,"//VTK::Output::Dec",e).result}return{VSSource:l,FSSource:o,GSSource:wu.substitute(r,"//VTK::System::Dec",s).result}},e.readyShaderProgramArray=(t,n,r)=>{const o=e.replaceShaderValues(t,n,r),a=e.getShaderProgram(o.VSSource,o.FSSource,o.GSSource);return e.readyShaderProgram(a)},e.readyShaderProgram=t=>t&&(t.getCompiled()||t.compileShader())&&e.bindShaderProgram(t)?t:null,e.getShaderProgram=(e,n,r)=>{const o=`${e}${n}${r}`,a=Fh().hash(o);if(!(a in t.shaderPrograms)){const o=wu.newInstance();return o.setContext(t.context),o.getVertexShader().setSource(e),o.getFragmentShader().setSource(n),r&&o.getGeometryShader().setSource(r),o.setMd5Hash(a),t.shaderPrograms[a]=o,o}return t.shaderPrograms[a]},e.releaseGraphicsResources=n=>{e.releaseCurrentShaderProgram(),Object.keys(t.shaderPrograms).map((e=>t.shaderPrograms[e])).forEach((e=>e.cleanup())),t.shaderPrograms={}},e.releaseCurrentShaderProgram=()=>{t.lastShaderProgramBound&&(t.lastShaderProgramBound.cleanup(),t.lastShaderProgramBound=null)},e.bindShaderProgram=e=>(t.lastShaderProgramBound===e||(t.lastShaderProgramBound&&t.lastShaderProgramBound.release(),e.bind(),t.lastShaderProgramBound=e),1)}(e,t)}var Uh={newInstance:Ht.newInstance(Gh,"vtkShaderCache"),extend:Gh};const{vtkErrorMacro:zh}=Ht,Wh={context:null,numberOfTextureUnits:0,textureUnits:0};function Hh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Wh,n),Ht.obj(e,t),t.textureUnits=[],Ht.get(e,t,["numberOfTextureUnits"]),Ht.setGet(e,t,["context"]),function(e,t){t.classHierarchy.push("vtkOpenGLTextureUnitManager"),e.deleteTable=()=>{for(let e=0;e<t.numberOfTextureUnits;++e)!0===t.textureUnits[e]&&zh("some texture units  were not properly released");t.textureUnits=[],t.numberOfTextureUnits=0},e.setContext=n=>{if(t.context!==n){if(0!==t.context&&e.deleteTable(),t.context=n,t.context){t.numberOfTextureUnits=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS);for(let e=0;e<t.numberOfTextureUnits;++e)t.textureUnits[e]=!1}e.modified()}},e.allocate=()=>{for(let n=0;n<t.numberOfTextureUnits;n++)if(!e.isAllocated(n))return t.textureUnits[n]=!0,n;return-1},e.allocateUnit=n=>e.isAllocated(n)?-1:(t.textureUnits[n]=!0,n),e.isAllocated=e=>t.textureUnits[e],e.free=e=>{t.textureUnits[e]=!1},e.freeAll=()=>{for(let e=0;e<t.numberOfTextureUnits;++e)t.textureUnits[e]=!1}}(e,t)}var jh={newInstance:Ht.newInstance(Hh,"vtkOpenGLTextureUnitManager"),extend:Hh};const Kh={size:void 0,selector:void 0};function $h(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kh,n),t.size||(t.size=[300,300]),Ht.getArray(e,t,["size"],2),Ht.get(e,t,["selector"]),Xt.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkRenderWindowViewNode"),e.getViewNodeFactory=()=>null,e.getAspectRatio=()=>t.size[0]/t.size[1],e.getAspectRatioForRenderer=e=>{const n=e.getViewportByReference();return t.size[0]*(n[2]-n[0])/((n[3]-n[1])*t.size[1])},e.isInViewport=(t,n,r)=>{const o=r.getViewportByReference(),a=e.getFramebufferSize();return o[0]*a[0]<=t&&o[2]*a[0]>=t&&o[1]*a[1]<=n&&o[3]*a[1]>=n},e.getViewportSize=t=>{const n=t.getViewportByReference(),r=e.getFramebufferSize();return[(n[2]-n[0])*r[0],(n[3]-n[1])*r[1]]},e.getViewportCenter=t=>{const n=e.getViewportSize(t);return[.5*n[0],.5*n[1]]},e.displayToNormalizedDisplay=(t,n,r)=>{const o=e.getFramebufferSize();return[t/o[0],n/o[1],r]},e.normalizedDisplayToDisplay=(t,n,r)=>{const o=e.getFramebufferSize();return[t*o[0],n*o[1],r]},e.worldToView=(e,t,n,r)=>r.worldToView(e,t,n),e.viewToWorld=(e,t,n,r)=>r.viewToWorld(e,t,n),e.worldToDisplay=(t,n,r,o)=>{const a=o.worldToView(t,n,r),i=e.getViewportSize(o),s=o.viewToProjection(a[0],a[1],a[2],i[0]/i[1]),l=o.projectionToNormalizedDisplay(s[0],s[1],s[2]);return e.normalizedDisplayToDisplay(l[0],l[1],l[2])},e.displayToWorld=(t,n,r,o)=>{const a=e.displayToNormalizedDisplay(t,n,r),i=o.normalizedDisplayToProjection(a[0],a[1],a[2]),s=e.getViewportSize(o),l=o.projectionToView(i[0],i[1],i[2],s[0]/s[1]);return o.viewToWorld(l[0],l[1],l[2])},e.normalizedDisplayToViewport=(t,n,r,o)=>{let a=o.getViewportByReference();a=e.normalizedDisplayToDisplay(a[0],a[1],0);const i=e.normalizedDisplayToDisplay(t,n,r);return[i[0]-a[0]-.5,i[1]-a[1]-.5,r]},e.viewportToNormalizedViewport=(t,n,r,o)=>{const a=e.getViewportSize(o);return a&&0!==a[0]&&0!==a[1]?[t/(a[0]-1),n/(a[1]-1),r]:[t,n,r]},e.normalizedViewportToViewport=(t,n,r,o)=>{const a=e.getViewportSize(o);return[t*(a[0]-1),n*(a[1]-1),r]},e.displayToLocalDisplay=(t,n,r)=>[t,e.getFramebufferSize()[1]-n-1,r],e.viewportToNormalizedDisplay=(t,n,r,o)=>{let a=o.getViewportByReference();a=e.normalizedDisplayToDisplay(a[0],a[1],0);const i=t+a[0]+.5,s=n+a[1]+.5;return e.displayToNormalizedDisplay(i,s,r)},e.getComputedDevicePixelRatio=()=>t.size[0]/e.getContainerSize()[0],e.getContainerSize=()=>{Ht.vtkErrorMacro("not implemented")},e.getPixelData=(e,t,n,r)=>{Ht.vtkErrorMacro("not implemented")},e.createSelector=()=>{Ht.vtkErrorMacro("not implemented")}}(e,t)}var qh={newInstance:Ht.newInstance($h,"vtkRenderWindowViewNode"),extend:$h};const{vtkDebugMacro:Xh,vtkErrorMacro:Yh}=Ht,Zh={position:"absolute",top:0,left:0,width:"100%",height:"100%"},Qh=["activateTexture","deactivateTexture","disableCullFace","enableCullFace","get3DContext","getActiveFramebuffer","getContext","getDefaultTextureByteSize","getDefaultTextureInternalFormat","getDefaultToWebgl2","getGLInformations","getGraphicsMemoryInfo","getGraphicsResourceForObject","getHardwareMaximumLineWidth","getPixelData","getShaderCache","getTextureUnitForTexture","getTextureUnitManager","getWebgl2","makeCurrent","releaseGraphicsResources","registerGraphicsResourceUser","unregisterGraphicsResourceUser","restoreContext","setActiveFramebuffer","setContext","setDefaultToWebgl2","setGraphicsResourceForObject"];function Jh(e,t,n){const r=e.createFramebuffer(),o=e.createTexture();e.bindTexture(e.TEXTURE_2D,o),e.texImage2D(e.TEXTURE_2D,0,t,2,2,0,t,n,null),e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,o,0);const a=e.checkFramebufferStatus(e.FRAMEBUFFER);return e.bindFramebuffer(e.FRAMEBUFFER,null),e.bindTexture(e.TEXTURE_2D,null),a===e.FRAMEBUFFER_COMPLETE}let ev=0;const tv=[];function nv(e){e.preventDefault()}function rv(e,t){let n;t.classHierarchy.push("vtkOpenGLRenderWindow"),e.getViewNodeFactory=()=>t.myFactory,t.canvas.addEventListener("webglcontextlost",nv,!1),t.canvas.addEventListener("webglcontextrestored",e.restoreContext,!1);const r=[0,0];let o;e.onModified((function(){t.renderable&&(t.size[0]===r[0]&&t.size[1]===r[1]||(r[0]=t.size[0],r[1]=t.size[1],t.canvas.setAttribute("width",t.size[0]),t.canvas.setAttribute("height",t.size[1]))),t.viewStream&&t.viewStream.setSize(t.size[0],t.size[1]),t.canvas.style.display=t.useOffScreen?"none":"block",t.el&&(t.el.style.cursor=t.cursorVisibility?t.cursor:"none"),t.containerSize=null})),e.buildPass=n=>{if(n){if(!t.renderable)return;e.prepareNodes(),e.addMissingNodes(t.renderable.getRenderersByReference()),e.addMissingNodes(t.renderable.getChildRenderWindowsByReference()),e.removeUnusedNodes(),e.initialize(),t.children.forEach((t=>{t.setOpenGLRenderWindow?.(e)}))}},e.initialize=()=>{if(!t.initialized){if(t.rootOpenGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t.rootOpenGLRenderWindow)t.context2D=e.get2DContext();else{t.context=e.get3DContext(),e.resizeFromChildRenderWindows(),t.context&&(ev++,tv.forEach((e=>e(ev)))),t.textureUnitManager=jh.newInstance(),t.textureUnitManager.setContext(t.context),t.shaderCache.setContext(t.context);const n=t.context;n.blendFuncSeparate(n.SRC_ALPHA,n.ONE_MINUS_SRC_ALPHA,n.ONE,n.ONE_MINUS_SRC_ALPHA),n.depthFunc(n.LEQUAL),n.enable(n.BLEND)}t.initialized=!0}},e.makeCurrent=()=>{t.context.makeCurrent()},e.setContainer=n=>{t.el&&t.el!==n&&(t.canvas.parentNode!==t.el&&Yh("Error: canvas parent node does not match container"),t.el.removeChild(t.canvas),t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)),t.el!==n&&(t.el=n,t.el&&(t.el.appendChild(t.canvas),t.useBackgroundImage&&t.el.appendChild(t.bgImage)),e.modified())},e.getContainer=()=>t.el,e.getContainerSize=()=>{if(!t.containerSize&&t.el){const{width:e,height:n}=t.el.getBoundingClientRect();t.containerSize=[e,n]}return t.containerSize||t.size},e.getFramebufferSize=()=>{const e=t.activeFramebuffer?.getSize();return e||t.size},e.getPixelData=(e,n,r,o)=>{const a=new Uint8Array((r-e+1)*(o-n+1)*4);return t.context.readPixels(e,n,r-e+1,o-n+1,t.context.RGBA,t.context.UNSIGNED_BYTE,a),a},e.get3DContext=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{preserveDrawingBuffer:!1,depth:!0,alpha:!0,powerPreference:"high-performance"},r=null;const o="undefined"!=typeof WebGL2RenderingContext;return t.webgl2=!1,t.defaultToWebgl2&&o&&(r=t.canvas.getContext("webgl2",e),r&&(t.webgl2=!0,Xh("using webgl2"))),r||(Xh("using webgl1"),r=t.canvas.getContext("webgl",e)||t.canvas.getContext("experimental-webgl",e)),new Proxy(r,(n||(n=function(){const e=new Map,t={apply(t,n,r){return e.has(r[0])?e.get(r[0]):t.apply(n,r)}},n=Object.create(null);return n.getParameter=(e,n,r,o)=>new Proxy(o.bind(e),t),n.depthMask=(t,n,r,o)=>{return new Proxy(o.bind(t),(a=t.DEPTH_WRITEMASK,{apply(t,n,r){return e.set(a,r[0]),t.apply(n,r)}}));var a},{get(e,t,r){if("__getUnderlyingContext"===t)return()=>e;let o=Reflect.get(e,t,e);o instanceof Function&&(o=o.bind(e));const a=n[t];return a?a(e,t,r,o):o}}}()),n))},e.get2DContext=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return t.canvas.getContext("2d",e)},e.restoreContext=()=>{const t=wh.newInstance();t.setCurrentOperation("Release"),t.traverse(e,null)},e.activateTexture=n=>{const r=t._textureResourceIds.get(n);if(void 0!==r)return void t.context.activeTexture(t.context.TEXTURE0+r);const o=e.getTextureUnitManager().allocate();o<0?Yh("Hardware does not support the number of textures defined."):(t._textureResourceIds.set(n,o),t.context.activeTexture(t.context.TEXTURE0+o))},e.deactivateTexture=n=>{const r=t._textureResourceIds.get(n);void 0!==r&&(e.getTextureUnitManager().free(r),t._textureResourceIds.delete(n))},e.getTextureUnitForTexture=e=>{const n=t._textureResourceIds.get(e);return void 0!==n?n:-1},e.getDefaultTextureByteSize=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(t.webgl2)switch(e){case is.CHAR:case is.SIGNED_CHAR:case is.UNSIGNED_CHAR:return 1;case n:case r:case is.UNSIGNED_SHORT:case is.SHORT:case is.VOID:return 2;default:return 4}return 1},e.getDefaultTextureInternalFormat=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(t.webgl2)switch(e){case is.UNSIGNED_CHAR:switch(n){case 1:return t.context.R8;case 2:return t.context.RG8;case 3:return t.context.RGB8;default:return t.context.RGBA8}case r&&!o&&is.UNSIGNED_SHORT:switch(n){case 1:return r.R16_EXT;case 2:return r.RG16_EXT;case 3:return r.RGB16_EXT;default:return r.RGBA16_EXT}case r&&!o&&is.SHORT:switch(n){case 1:return r.R16_SNORM_EXT;case 2:return r.RG16_SNORM_EXT;case 3:return r.RGB16_SNORM_EXT;default:return r.RGBA16_SNORM_EXT}default:switch(n){case 1:return o?t.context.R16F:t.context.R32F;case 2:return o?t.context.RG16F:t.context.RG32F;case 3:return o?t.context.RGB16F:t.context.RGB32F;default:return o?t.context.RGBA16F:t.context.RGBA32F}}switch(n){case 1:return t.context.LUMINANCE;case 2:return t.context.LUMINANCE_ALPHA;case 3:return t.context.RGB;default:return t.context.RGBA}},e.setBackgroundImage=e=>{t.bgImage.src=e.src},e.setUseBackgroundImage=e=>{t.useBackgroundImage=e,t.useBackgroundImage&&!t.el.contains(t.bgImage)?t.el.appendChild(t.bgImage):!t.useBackgroundImage&&t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)},e.captureNextImage=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"image/png",{resetCamera:r=!1,size:o=null,scale:a=1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(t.deleted)return null;t.imageFormat=n;const i=t.notifyStartCaptureImage;return t.notifyStartCaptureImage=!0,t._screenshot={size:o||1!==a?o||t.size.map((e=>e*a)):null},new Promise(((n,o)=>{const a=e.onImageReady((o=>{if(null===t._screenshot.size)t.notifyStartCaptureImage=i,a.unsubscribe(),t._screenshot.placeHolder&&(t.size=t._screenshot.originalSize,e.modified(),t._screenshot.cameras&&t._screenshot.cameras.forEach((e=>{let{restoreParamsFn:t,arg:n}=e;return t(n)})),e.traverseAllPasses(),t.el.removeChild(t._screenshot.placeHolder),t._screenshot.placeHolder.remove(),t._screenshot=null),n(o);else{const n=document.createElement("img");if(n.style=Zh,n.src=o,t._screenshot.placeHolder=t.el.appendChild(n),t.canvas.style.display="none",t._screenshot.originalSize=t.size,t.size=t._screenshot.size,t.rootOpenGLRenderWindow?.resizeFromChildRenderWindows(),t._screenshot.size=null,e.modified(),r){const e=!0!==r;t._screenshot.cameras=t.renderable.getRenderers().map((t=>{const n=t.getActiveCamera(),o=n.get("focalPoint","position","parallelScale");return{resetCameraArgs:e?{renderer:t}:void 0,resetCameraFn:e?r:t.resetCamera,restoreParamsFn:n.set,arg:JSON.parse(JSON.stringify(o))}})),t._screenshot.cameras.forEach((e=>{let{resetCameraFn:t,resetCameraArgs:n}=e;return t(n)}))}e.traverseAllPasses()}}))}))},e.getHardwareMaximumLineWidth=()=>{if(null!=o)return o;const t=e.get3DContext(),n=t.getParameter(t.ALIASED_LINE_WIDTH_RANGE);return o=n[1],n[1]},e.getGLInformations=()=>{if(t._glInformation)return t._glInformation;const n=e.get3DContext(),r=n.getExtension("OES_texture_float"),o=n.getExtension("OES_texture_half_float"),a=n.getExtension("WEBGL_debug_renderer_info"),i=n.getExtension("WEBGL_draw_buffers"),s=n.getExtension("EXT_texture_filter_anisotropic")||n.getExtension("WEBKIT_EXT_texture_filter_anisotropic"),l=[["Max Vertex Attributes","MAX_VERTEX_ATTRIBS",n.getParameter(n.MAX_VERTEX_ATTRIBS)],["Max Varying Vectors","MAX_VARYING_VECTORS",n.getParameter(n.MAX_VARYING_VECTORS)],["Max Vertex Uniform Vectors","MAX_VERTEX_UNIFORM_VECTORS",n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS)],["Max Fragment Uniform Vectors","MAX_FRAGMENT_UNIFORM_VECTORS",n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS)],["Max Fragment Texture Image Units","MAX_TEXTURE_IMAGE_UNITS",n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)],["Max Vertex Texture Image Units","MAX_VERTEX_TEXTURE_IMAGE_UNITS",n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS)],["Max Combined Texture Image Units","MAX_COMBINED_TEXTURE_IMAGE_UNITS",n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS)],["Max 2D Texture Size","MAX_TEXTURE_SIZE",n.getParameter(n.MAX_TEXTURE_SIZE)],["Max Cube Texture Size","MAX_CUBE_MAP_TEXTURE_SIZE",n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE)],["Max Texture Anisotropy","MAX_TEXTURE_MAX_ANISOTROPY_EXT",s&&n.getParameter(s.MAX_TEXTURE_MAX_ANISOTROPY_EXT)],["Point Size Range","ALIASED_POINT_SIZE_RANGE",n.getParameter(n.ALIASED_POINT_SIZE_RANGE).join(" - ")],["Line Width Range","ALIASED_LINE_WIDTH_RANGE",n.getParameter(n.ALIASED_LINE_WIDTH_RANGE).join(" - ")],["Max Viewport Dimensions","MAX_VIEWPORT_DIMS",n.getParameter(n.MAX_VIEWPORT_DIMS).join(" - ")],["Max Renderbuffer Size","MAX_RENDERBUFFER_SIZE",n.getParameter(n.MAX_RENDERBUFFER_SIZE)],["Framebuffer Red Bits","RED_BITS",n.getParameter(n.RED_BITS)],["Framebuffer Green Bits","GREEN_BITS",n.getParameter(n.GREEN_BITS)],["Framebuffer Blue Bits","BLUE_BITS",n.getParameter(n.BLUE_BITS)],["Framebuffer Alpha Bits","ALPHA_BITS",n.getParameter(n.ALPHA_BITS)],["Framebuffer Depth Bits","DEPTH_BITS",n.getParameter(n.DEPTH_BITS)],["Framebuffer Stencil Bits","STENCIL_BITS",n.getParameter(n.STENCIL_BITS)],["Framebuffer Subpixel Bits","SUBPIXEL_BITS",n.getParameter(n.SUBPIXEL_BITS)],["MSAA Samples","SAMPLES",n.getParameter(n.SAMPLES)],["MSAA Sample Buffers","SAMPLE_BUFFERS",n.getParameter(n.SAMPLE_BUFFERS)],["Supported Formats for UByte Render Targets     ","UNSIGNED_BYTE RENDER TARGET FORMATS",[r&&Jh(n,n.RGBA,n.UNSIGNED_BYTE)?"RGBA":"",r&&Jh(n,n.RGB,n.UNSIGNED_BYTE)?"RGB":"",r&&Jh(n,n.LUMINANCE,n.UNSIGNED_BYTE)?"LUMINANCE":"",r&&Jh(n,n.ALPHA,n.UNSIGNED_BYTE)?"ALPHA":"",r&&Jh(n,n.LUMINANCE_ALPHA,n.UNSIGNED_BYTE)?"LUMINANCE_ALPHA":""].join(" ")],["Supported Formats for Half Float Render Targets","HALF FLOAT RENDER TARGET FORMATS",[o&&Jh(n,n.RGBA,o.HALF_FLOAT_OES)?"RGBA":"",o&&Jh(n,n.RGB,o.HALF_FLOAT_OES)?"RGB":"",o&&Jh(n,n.LUMINANCE,o.HALF_FLOAT_OES)?"LUMINANCE":"",o&&Jh(n,n.ALPHA,o.HALF_FLOAT_OES)?"ALPHA":"",o&&Jh(n,n.LUMINANCE_ALPHA,o.HALF_FLOAT_OES)?"LUMINANCE_ALPHA":""].join(" ")],["Supported Formats for Full Float Render Targets","FLOAT RENDER TARGET FORMATS",[r&&Jh(n,n.RGBA,n.FLOAT)?"RGBA":"",r&&Jh(n,n.RGB,n.FLOAT)?"RGB":"",r&&Jh(n,n.LUMINANCE,n.FLOAT)?"LUMINANCE":"",r&&Jh(n,n.ALPHA,n.FLOAT)?"ALPHA":"",r&&Jh(n,n.LUMINANCE_ALPHA,n.FLOAT)?"LUMINANCE_ALPHA":""].join(" ")],["Max Multiple Render Targets Buffers","MAX_DRAW_BUFFERS_WEBGL",i?n.getParameter(i.MAX_DRAW_BUFFERS_WEBGL):0],["High Float Precision in Vertex Shader","HIGH_FLOAT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).rangeMax,"</sup>)"].join("")],["Medium Float Precision in Vertex Shader","MEDIUM_FLOAT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).rangeMax,"</sup>)"].join("")],["Low Float Precision in Vertex Shader","LOW_FLOAT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).rangeMax,"</sup>)"].join("")],["High Float Precision in Fragment Shader","HIGH_FLOAT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).rangeMax,"</sup>)"].join("")],["Medium Float Precision in Fragment Shader","MEDIUM_FLOAT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).rangeMax,"</sup>)"].join("")],["Low Float Precision in Fragment Shader","LOW_FLOAT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).rangeMax,"</sup>)"].join("")],["High Int Precision in Vertex Shader","HIGH_INT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).rangeMax,"</sup>)"].join("")],["Medium Int Precision in Vertex Shader","MEDIUM_INT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).rangeMax,"</sup>)"].join("")],["Low Int Precision in Vertex Shader","LOW_INT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).rangeMax,"</sup>)"].join("")],["High Int Precision in Fragment Shader","HIGH_INT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).rangeMax,"</sup>)"].join("")],["Medium Int Precision in Fragment Shader","MEDIUM_INT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).rangeMax,"</sup>)"].join("")],["Low Int Precision in Fragment Shader","LOW_INT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).rangeMax,"</sup>)"].join("")],["Supported Extensions","EXTENSIONS",n.getSupportedExtensions().join("<br/>\t\t\t\t\t    ")],["WebGL Renderer","RENDERER",n.getParameter(n.RENDERER)],["WebGL Vendor","VENDOR",n.getParameter(n.VENDOR)],["WebGL Version","VERSION",n.getParameter(n.VERSION)],["Shading Language Version","SHADING_LANGUAGE_VERSION",n.getParameter(n.SHADING_LANGUAGE_VERSION)],["Unmasked Renderer","UNMASKED_RENDERER",a&&n.getParameter(a.UNMASKED_RENDERER_WEBGL)],["Unmasked Vendor","UNMASKED_VENDOR",a&&n.getParameter(a.UNMASKED_VENDOR_WEBGL)],["WebGL Version","WEBGL_VERSION",t.webgl2?2:1]],c={};for(;l.length;){const[e,t,n]=l.pop();t&&(c[t]={label:e,value:n})}return t._glInformation=c,c},e.traverseAllPasses=()=>{if(t.renderPasses)for(let n=0;n<t.renderPasses.length;++n)t.renderPasses[n].traverse(e,null);e.copyParentContent(),t.notifyStartCaptureImage&&function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.imageFormat;const r=document.createElement("canvas"),o=r.getContext("2d");r.width=t.canvas.width,r.height=t.canvas.height,o.drawImage(t.canvas,0,0);const a=t.canvas.getBoundingClientRect();t.renderable.getRenderers().forEach((e=>{e.getViewProps().forEach((e=>{if(e.getContainer){const t=e.getContainer().getElementsByTagName("canvas");for(let e=0;e<t.length;e++){const n=t[e],r=n.getBoundingClientRect(),i=r.x-a.x,s=r.y-a.y;o.drawImage(n,i,s)}}}))}));const i=r.toDataURL(n);r.remove(),e.invokeImageReady(i)}();const n=t.renderable.getChildRenderWindowsByReference();for(let t=0;t<n.length;++t)e.getViewNodeFor(n[t])?.traverseAllPasses()},e.copyParentContent=()=>{const e=t.rootOpenGLRenderWindow;if(!e||!t.context2D||t.children.some((e=>!!e.getSelector?.())))return;const n=e.getCanvas(),r=t.canvas;t.context2D.drawImage(n,0,n.height-r.height,r.width,r.height,0,0,r.width,r.height)},e.resizeFromChildRenderWindows=()=>{const n=t.renderable.getChildRenderWindowsByReference();if(n.length>0){const t=[0,0];for(let r=0;r<n.length;++r){const o=e.getViewNodeFor(n[r])?.getSize();o&&(t[0]=o[0]>t[0]?o[0]:t[0],t[1]=o[1]>t[1]?o[1]:t[1])}e.setSize(...t)}},e.disableCullFace=()=>{t.cullFaceEnabled&&(t.context.disable(t.context.CULL_FACE),t.cullFaceEnabled=!1)},e.enableCullFace=()=>{t.cullFaceEnabled||(t.context.enable(t.context.CULL_FACE),t.cullFaceEnabled=!0)},e.setViewStream=n=>t.viewStream!==n&&(t.subscription&&(t.subscription.unsubscribe(),t.subscription=null),t.viewStream=n,t.viewStream&&(t.renderable.getRenderers()[0].getBackgroundByReference()[3]=0,e.setUseBackgroundImage(!0),t.subscription=t.viewStream.onImageReady((t=>e.setBackgroundImage(t.image))),t.viewStream.setSize(t.size[0],t.size[1]),t.viewStream.invalidateCache(),t.viewStream.render(),e.modified()),!0),e.createSelector=()=>{const t=gp.newInstance();return t.setOpenGLRenderWindow(e),t},e.delete=Ht.chain((()=>{t.context&&(ev--,tv.forEach((e=>e(ev)))),e.setContainer(),e.setViewStream()}),(function(){t.canvas.removeEventListener("webglcontextlost",nv),t.canvas.removeEventListener("webglcontextrestored",e.restoreContext)}),e.delete),e.setActiveFramebuffer=e=>{t.activeFramebuffer=e};const a=e.setSize;e.setSize=(t,n)=>{const r=a(t,n);return r&&e.invokeWindowResizeEvent({width:t,height:n}),r},e.registerGraphicsResourceUser=(n,r)=>{t._graphicsResources.has(n)||e.setGraphicsResourceForObject(n,null,null);const o=t._graphicsResources.get(n);o?.users.add(r)},e.unregisterGraphicsResourceUser=(n,r)=>{const o=t._graphicsResources.get(n);o&&(o.users.delete(r),o.users.size||(o.oglObject?.releaseGraphicsResources(e),t._graphicsResources.delete(n)))},e.getGraphicsResourceForObject=e=>t._graphicsResources.get(e),e.setGraphicsResourceForObject=(n,r,o)=>{if(!n)return;const a=t._graphicsResources.get(n);a?.oglObject?.releaseGraphicsResources(e),t._graphicsResources.set(n,{coreObject:n,oglObject:r,hash:o,users:a?.users??new Set})},e.getGraphicsMemoryInfo=()=>{let e=0;return t._graphicsResources.forEach((t=>{let{oglObject:n}=t;e+=n.getAllocatedGPUMemoryInBytes()})),e},e.releaseGraphicsResources=()=>{null!==t.shaderCache&&t.shaderCache.releaseGraphicsResources(e),t._graphicsResources.forEach((t=>{let{oglObject:n}=t;n.releaseGraphicsResources(e)})),t._graphicsResources.clear(),null!==t.textureUnitManager&&t.textureUnitManager.freeAll(),t.renderable.getRenderersByReference().forEach((t=>{const n=e.getViewNodeFor(t);n?.releaseGraphicsResources()}))};const i={...e};Qh.forEach((n=>{e[n]=function(){return t.rootOpenGLRenderWindow?t.rootOpenGLRenderWindow[n](...arguments):i[n](...arguments)}}))}const ov={cullFaceEnabled:!1,shaderCache:null,initialized:!1,context:null,context2D:null,canvas:null,cursorVisibility:!0,cursor:"pointer",textureUnitManager:null,textureResourceIds:null,containerSize:null,renderPasses:[],notifyStartCaptureImage:!1,webgl2:!1,defaultToWebgl2:!0,activeFramebuffer:null,imageFormat:"image/png",useOffScreen:!1,useBackgroundImage:!1};const av=Ht.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ov,n),qh.extend(e,t,n),t.canvas||(t.canvas=document.createElement("canvas"),t.canvas.style.width="100%"),t.selector||(t.selector=gp.newInstance(),t.selector.setOpenGLRenderWindow(e)),t.bgImage=new Image,t.bgImage.style.position="absolute",t.bgImage.style.left="0",t.bgImage.style.top="0",t.bgImage.style.width="100%",t.bgImage.style.height="100%",t.bgImage.style.zIndex="-1",t._textureResourceIds=new Map,t._graphicsResources=new Map,t._glInformation=null,t.myFactory=rn.newInstance(),t.shaderCache=Uh.newInstance(),t.shaderCache.setOpenGLRenderWindow(e),t.renderPasses[0]=Bh.newInstance(),Ht.get(e,t,["shaderCache","textureUnitManager","webgl2","useBackgroundImage","activeFramebuffer","rootOpenGLRenderWindow"]),Ht.setGet(e,t,["initialized","context","context2D","canvas","renderPasses","notifyStartCaptureImage","defaultToWebgl2","cursor","useOffScreen"]),Ht.setGetArray(e,t,["size"],2),Ht.event(e,t,"imageReady"),Ht.event(e,t,"windowResizeEvent"),rv(e,t)}),"vtkOpenGLRenderWindow");_m("WebGL",av),en("vtkRenderWindow",av);const iv={device:null,handle:null};function sv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,iv,n),Ht.obj(e,t),Ht.get(e,t,["lastCameraMTime"]),Ht.setGet(e,t,["device","handle"]),function(e,t){t.classHierarchy.push("vtkWebGPUShaderModule"),e.initialize=(e,n)=>{t.device=e,t.handle=t.device.getHandle().createShaderModule({code:n.getCode()})}}(e,t)}var lv={newInstance:Ht.newInstance(sv,"vtkWebGPUShaderModule"),extend:sv};const cv={shaderModules:null,device:null,window:null};function uv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,cv,n),t._shaderModules=new Map,Ht.obj(e,t),Ht.setGet(e,t,["device","window"]),function(e,t){t.classHierarchy.push("vtkWebGPUShaderCache"),e.getShaderModule=e=>{const n=e.getType(),r=e.getHash(),o=t._shaderModules.keys();for(let e=0;e<o.length;e++){const a=o[e];if(a.getHash()===r&&a.getType()===n)return t._shaderModules.get(a)}const a=lv.newInstance();return a.initialize(t.device,e),t._shaderModules.set(e,a),a}}(e,t)}var dv={newInstance:Ht.newInstance(uv,"vtkWebGPUShaderCache"),extend:uv,substitute:function(e,t,n){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const o=Array.isArray(n)?n.join("\n"):n;let a=!1;-1!==e.search(t)&&(a=!0);let i="";r&&(i="g");const s=new RegExp(t,i);return{replace:a,result:e.replace(s,o)}}};const pv={device:null,handle:null,label:null};function fv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,pv,n),Ht.obj(e,t),t.bindables=[],t.bindGroupTime={},Ht.obj(t.bindGroupTime,{mtime:0}),Ht.get(e,t,["bindGroupTime","handle","sizeInBytes","usage"]),Ht.setGet(e,t,["label","device","arrayInformation"]),function(e,t){t.classHierarchy.push("vtkWebGPUBindGroup"),e.setBindables=n=>{if(t.bindables.length===n.length){let e=!0;for(let r=0;r<t.bindables.length;r++)t.bindables[r]!==n[r]&&(e=!1);if(e)return}t.bindables=n,e.modified()},e.getBindGroupLayout=e=>{const n=[];for(let e=0;e<t.bindables.length;e++){const r=t.bindables[e].getBindGroupLayoutEntry();r.binding=e,n.push(r)}return e.getBindGroupLayout({entries:n})},e.getBindGroup=n=>{let r=e.getMTime();for(let e=0;e<t.bindables.length;e++){const n=t.bindables[e].getBindGroupTime().getMTime();r=n>r?n:r}if(r<t.bindGroupTime.getMTime())return t.bindGroup;const o=[];for(let e=0;e<t.bindables.length;e++){const n=t.bindables[e].getBindGroupEntry();n.binding=e,o.push(n)}return t.bindGroup=n.getHandle().createBindGroup({layout:e.getBindGroupLayout(n),entries:o,label:t.label}),t.bindGroupTime.modified(),t.bindGroup},e.getShaderCode=e=>{const n=[],r=e.getBindGroupLayoutCount(t.label);for(let e=0;e<t.bindables.length;e++)n.push(t.bindables[e].getShaderCode(e,r));return n.join("\n")}}(e,t)}var gv={newInstance:Ht.newInstance(fv),extend:fv};const mv={handle:null,layouts:null,renderEncoder:null,shaderDescriptions:null,vertexState:null,topology:null,pipelineDescription:null};function hv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,mv,n),vt(e,t),t.layouts=[],t.shaderDescriptions=[],yt(e,t,["handle","pipelineDescription"]),St(e,t,["device","renderEncoder","topology","vertexState"]),function(e,t){t.classHierarchy.push("vtkWebGPUPipeline"),e.getShaderDescriptions=()=>t.shaderDescriptions,e.initialize=(e,n)=>{t.pipelineDescription=t.renderEncoder.getPipelineSettings(),t.pipelineDescription.primitive.topology=t.topology,t.pipelineDescription.vertex=t.vertexState,t.pipelineDescription.label=n;const r=[];for(let e=0;e<t.layouts.length;e++)r.push(t.layouts[e].layout);t.pipelineLayout=e.getHandle().createPipelineLayout({bindGroupLayouts:r}),t.pipelineDescription.layout=t.pipelineLayout;for(let n=0;n<t.shaderDescriptions.length;n++){const r=t.shaderDescriptions[n],o=e.getShaderModule(r);"vertex"===r.getType()&&(t.pipelineDescription.vertex.module=o.getHandle(),t.pipelineDescription.vertex.entryPoint="main"),"fragment"===r.getType()&&(t.pipelineDescription.fragment.module=o.getHandle(),t.pipelineDescription.fragment.entryPoint="main")}t.handle=e.getHandle().createRenderPipeline(t.pipelineDescription)},e.getShaderDescription=e=>{for(let n=0;n<t.shaderDescriptions.length;n++)if(t.shaderDescriptions[n].getType()===e)return t.shaderDescriptions[n];return null},e.addBindGroupLayout=e=>{e&&t.layouts.push({layout:e.getBindGroupLayout(t.device),label:e.getLabel()})},e.getBindGroupLayout=e=>t.layouts[e].layout,e.getBindGroupLayoutCount=e=>{for(let n=0;n<t.layouts.length;n++)if(t.layouts[n].label===e)return n;return 0},e.bindVertexInput=(e,t)=>{t.bindBuffers(e)}}(e,t)}var vv={newInstance:Et(hv,"vtkWebGPUPipeline"),extend:hv};const Tv={type:null,hash:null,code:null,outputNames:null,outputTypes:null};function yv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Tv,n),t.outputNames=[],t.outputTypes=[],t.outputInterpolations=[],t.builtinOutputNames=[],t.builtinOutputTypes=[],t.builtinInputNames=[],t.builtinInputTypes=[],Ht.obj(e,t),Ht.setGet(e,t,["type","hash","code"]),Ht.getArray(e,t,["outputTypes","outputNames","outputInterpolations"]),function(e,t){t.classHierarchy.push("vtkWebGPUShaderDescription"),e.hasOutput=e=>t.outputNames.includes(e),e.addOutput=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0;t.outputTypes.push(e),t.outputNames.push(n),t.outputInterpolations.push(r)},e.addBuiltinOutput=(e,n)=>{t.builtinOutputTypes.push(e),t.builtinOutputNames.push(n)},e.addBuiltinInput=(e,n)=>{t.builtinInputTypes.push(e),t.builtinInputNames.push(n)},e.replaceShaderCode=(e,n)=>{const r=[];let o=[];if(n&&r.push(n.getShaderCode()),e||t.builtinInputNames.length){const n=[];if(n.push(`struct ${t.type}Input\n{`),e){const t=e.getOutputNamesByReference(),r=e.getOutputTypesByReference(),o=e.getOutputInterpolationsByReference();for(let e=0;e<t.length;e++)void 0!==o[e]?n.push(`  @location(${e}) @interpolate(${o[e]}) ${t[e]} : ${r[e]},`):n.push(`  @location(${e}) ${t[e]} : ${r[e]},`)}for(let e=0;e<t.builtinInputNames.length;e++)n.push(`  ${t.builtinInputNames[e]} : ${t.builtinInputTypes[e]},`);n.length>1&&(n.push("};"),o=n,r[r.length-1]+=",",r.push(`input: ${t.type}Input`))}if(r.length&&(t.code=dv.substitute(t.code,"//VTK::IOStructs::Input",r).result),t.outputNames.length+t.builtinOutputNames.length){const e=[`struct ${t.type}Output\n{`];for(let n=0;n<t.outputNames.length;n++)void 0!==t.outputInterpolations[n]?e.push(`  @location(${n}) @interpolate(${t.outputInterpolations[n]}) ${t.outputNames[n]} : ${t.outputTypes[n]},`):e.push(`  @location(${n}) ${t.outputNames[n]} : ${t.outputTypes[n]},`);for(let n=0;n<t.builtinOutputNames.length;n++)e.push(`  ${t.builtinOutputNames[n]} : ${t.builtinOutputTypes[n]},`);e.push("};"),o=o.concat(e),t.code=dv.substitute(t.code,"//VTK::IOStructs::Output",[`-> ${t.type}Output`]).result}t.code=dv.substitute(t.code,"//VTK::IOStructs::Dec",o).result}}(e,t)}var bv={newInstance:Ht.newInstance(yv,"vtkWebGPUShaderDescription"),extend:yv};const xv={r8unorm:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:"float"},r8snorm:{numComponents:1,nativeType:Int8Array,stride:1,elementSize:1,sampleType:"float"},r8uint:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:"uint"},r8sint:{numComponents:1,nativeType:Int8Array,stride:1,elementSize:1,sampleType:"sint"},r16uint:{numComponents:1,nativeType:Uint16Array,stride:2,elementSize:2,sampleType:"uint"},r16sint:{numComponents:1,nativeType:Int16Array,stride:2,elementSize:2,sampleType:"sint"},r16float:{numComponents:1,nativeType:Float32Array,stride:2,elementSize:2,sampleType:"float"},rg8unorm:{numComponents:2,nativeType:Uint8Array,stride:2,elementSize:1,sampleType:"float"},rg8snorm:{numComponents:2,nativeType:Int8Array,stride:2,elementSize:1,sampleType:"float"},rg8uint:{numComponents:2,nativeType:Uint8Array,stride:2,elementSize:1,sampleType:"uint"},rg8sint:{numComponents:2,nativeType:Int8Array,stride:2,elementSize:1,sampleType:"sint"},r32uint:{numComponents:1,nativeType:Uint32Array,stride:4,elementSize:4,sampleType:"uint"},r32sint:{numComponents:1,nativeType:Int32Array,stride:4,elementSize:4,sampleType:"sint"},r32float:{numComponents:1,nativeType:Float32Array,stride:4,elementSize:4,sampleType:"unfilterable-float"},rg16uint:{numComponents:2,nativeType:Uint16Array,stride:4,elementSize:2,sampleType:"uint"},rg16sint:{numComponents:2,nativeType:Int16Array,stride:4,elementSize:2,sampleType:"sint"},rg16float:{numComponents:2,nativeType:Float32Array,stride:4,elementSize:2,sampleType:"float"},rgba8unorm:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"float"},"rgba8unorm-srgb":{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"float"},rgba8snorm:{numComponents:4,nativeType:Int8Array,stride:4,elementSize:1,sampleType:"float"},rgba8uint:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"uint"},rgba8sint:{numComponents:4,nativeType:Int8Array,stride:4,elementSize:1,sampleType:"sint"},bgra8unorm:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"float"},"bgra8unorm-srgb":{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"float"},rgb9e5ufloat:{numComponents:4,nativeType:Uint32Array,stride:4,sampleType:"float"},rgb10a2unorm:{numComponents:4,nativeType:Uint32Array,stride:4,sampleType:"float"},rg11b10ufloat:{numComponents:4,nativeType:Float32Array,stride:4,sampleType:"float"},rg32uint:{numComponents:2,nativeType:Uint32Array,stride:8,elementSize:4,sampleType:"uint"},rg32sint:{numComponents:2,nativeType:Int32Array,stride:8,elementSize:4,sampleType:"sint"},rg32float:{numComponents:2,nativeType:Float32Array,stride:8,elementSize:4,sampleType:"unfilterable-float"},rgba16uint:{numComponents:4,nativeType:Uint16Array,stride:8,elementSize:2,sampleType:"uint"},rgba16sint:{numComponents:4,nativeType:Int16Array,stride:8,elementSize:2,sampleType:"sint"},rgba16float:{numComponents:4,nativeType:Float32Array,stride:8,elementSize:2,sampleType:"float"},rgba32uint:{numComponents:4,nativeType:Uint32Array,stride:16,elementSize:4,sampleType:"uint"},rgba32sint:{numComponents:4,nativeType:Int32Array,stride:16,elementSize:4,sampleType:"sint"},rgba32float:{numComponents:4,nativeType:Float32Array,stride:16,elementSize:4,sampleType:"unfilterable-float"},stencil8:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:"uint"},depth16unorm:{numComponents:1,nativeType:Uint16Array,stride:2,elementSize:2,sampleType:"depth"},depth24plus:{numComponents:1,nativeType:Uint32Array,stride:4,elementSize:3,sampleType:"depth"},"depth24plus-stencil8":{numComponents:2,nativeType:Uint32Array,stride:4,sampleType:"mixed"},depth32float:{numComponents:1,nativeType:Float32Array,stride:4,elementSize:4,sampleType:"depth"}};var Cv=function(e){return!e||e.length<6?0:e in xv==1?xv[e]:(tt(`unknown format ${e}`),null)},Sv=function(e){if(!e||e.length<5)return 0;let t=1;"x"===e[e.length-2]&&(t=Number(e[e.length-1]));const n=1===t?e.length-1:e.length-3,r=Number(e[n]);return Number.isNaN(r)?(tt(`unknown format ${e}`),0):t*(5-r/2)},Av=function(e){if(!e||e.length<5)return 0;let t;if("f"===e[0])t="Float";else if("s"===e[0])t="Int";else{if("u"!==e[0])return void tt(`unknown format ${e}`);t="Uint"}const n=e.split("x")[0],r=Number(n[n.length-1]);if(!Number.isNaN(r))return t+=8*(5-r/2),t+="Array",t;tt(`unknown format ${e}`)},Iv=function(e){let t;if("f"===e[0]||"n"===e[1])t="f32";else if("s"===e[0]&&"i"===e[1])t="i32";else{if("u"!==e[0]||"i"!==e[1])return void tt(`unknown format ${e}`);t="u32"}let n=1;return"x"===e[e.length-2]&&(n=Number(e[e.length-1])),4===n?`vec4<${t}>`:3===n?`vec3<${t}>`:2===n?`vec2<${t}>`:t},wv=function(e){if(!e)return 0;let t=1;return"vec"===e.substring(0,3)?t=Number(e[3]):"mat"===e.substring(0,3)&&(t=e[3]*e[5]),4*t},Ov=function(e){if(e)return e.includes("f32")?"Float32Array":e.includes("i32")?"Int32Array":e.includes("u32")?"Uint32Array":void tt(`unknown format ${e}`)};function Pv(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;++n)if(!t.includes(e[n]))return!1;return!0}const Rv={inputs:null,bindingDescriptions:!1,attributeDescriptions:null,indexBuffer:null};function Mv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Rv,n),vt(e,t),t.bindingDescriptions=[],t.attributeDescriptions=[],t.inputs=[],St(e,t,["created","device","handle","indexBuffer"]),function(e,t){t.classHierarchy.push("vtkWebGPUVertexInput"),e.addBuffer=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"vertex",o=n;Array.isArray(o)||(o=[o]);for(let n=0;n<t.inputs.length;n++)if(Pv(t.inputs[n].names,o)){if(t.inputs[n].buffer===e)return;return void(t.inputs[n].buffer=e)}t.inputs.push({buffer:e,stepMode:r,names:o}),t.inputs=t.inputs.sort(((e,t)=>e.names[0]<t.names[0]?-1:e.names[0]>t.names[0]?1:0))},e.removeBufferIfPresent=e=>{for(let n=0;n<t.inputs.length;n++)t.inputs[n].names.includes(e)&&t.inputs.splice(n,1)},e.getBuffer=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return t.inputs[n].buffer;return null},e.hasAttribute=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return!0;return!1},e.getAttributeTime=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return t.inputs[n].buffer.getSourceTime();return 0},e.getShaderCode=()=>{let e="",n=0;for(let r=0;r<t.inputs.length;r++)for(let o=0;o<t.inputs[r].names.length;o++){const a=t.inputs[r].buffer.getArrayInformation()[o],i=Iv(a.format);n>0&&(e+=",\n"),e=`${e}  @location(${n}) ${t.inputs[r].names[o]} : ${i}`,n++}return e},e.getVertexInputInformation=()=>{const e={};if(t.inputs.length){const n=[];let r=0;for(let e=0;e<t.inputs.length;e++){const o=t.inputs[e].buffer,a={arrayStride:o.getStrideInBytes(),stepMode:t.inputs[e].stepMode,attributes:[]},i=o.getArrayInformation();for(let n=0;n<t.inputs[e].names.length;n++)a.attributes.push({shaderLocation:r,offset:i[n].offset,format:i[n].format}),r++;n.push(a)}e.buffers=n}return e},e.bindBuffers=e=>{for(let n=0;n<t.inputs.length;n++)e.setVertexBuffer(n,t.inputs[n].buffer.getHandle());t.indexBuffer&&e.setIndexBuffer(t.indexBuffer.getHandle(),t.indexBuffer.getArrayInformation()[0].format)},e.getReady=()=>{},e.releaseGraphicsResources=()=>{t.created&&(t.inputs=[],t.bindingDescriptions=[],t.attributeDescriptions=[])}}(e,t)}var Ev={newInstance:Et(Mv,"vtkWebGPUVertexInput"),extend:Mv};const Vv={additionalBindables:void 0,bindGroup:null,device:null,fragmentShaderTemplate:null,numberOfInstances:1,numberOfVertices:0,pipelineHash:null,shaderReplacements:null,SSBO:null,textureViews:null,topology:"triangle-list",UBO:null,vertexShaderTemplate:null,WebGPURenderer:null};function Dv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Vv,n),Xt.extend(e,t,n),t.textureViews=[],t.vertexInput=Ev.newInstance(),t.bindGroup=gv.newInstance({label:"mapperBG"}),t.additionalBindables=[],t.fragmentShaderTemplate=t.fragmentShaderTemplate||"\n//VTK::Renderer::Dec\n\n//VTK::Color::Dec\n\n//VTK::Normal::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Select::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : fragmentOutput;\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::Light::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Select::Impl\n\n  // var computedColor:vec4<f32> = vec4<f32>(1.0,0.5,0.5,1.0);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n",t.vertexShaderTemplate=t.vertexShaderTemplate||"\n//VTK::Renderer::Dec\n\n//VTK::Color::Dec\n\n//VTK::Normal::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Select::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@vertex\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : vertexOutput;\n\n  // var vertex: vec4<f32> = vertexBC;\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Select::Impl\n\n  //VTK::Position::Impl\n\n  return output;\n}\n",t.shaderReplacements=new Map,Ht.get(e,t,["pipeline","vertexInput"]),Ht.setGet(e,t,["additionalBindables","device","fragmentShaderTemplate","interpolate","numberOfInstances","numberOfVertices","pipelineHash","shaderReplacements","SSBO","textureViews","topology","UBO","vertexShaderTemplate","WebGPURenderer"]),function(e,t){t.classHierarchy.push("vtkWebGPUSimpleMapper"),e.generateShaderDescriptions=(n,r,o)=>{const a=bv.newInstance({type:"vertex",hash:n,code:t.vertexShaderTemplate}),i=bv.newInstance({type:"fragment",hash:n,code:t.fragmentShaderTemplate}),s=r.getShaderDescriptions();s.push(a),s.push(i);const l=t.vertexShaderTemplate+t.fragmentShaderTemplate,c=new RegExp("//VTK::[^:]*::","g"),u=l.match(c).filter(((e,t,n)=>n.indexOf(e)===t)),d=u.map((e=>`replaceShader${e.substring(7,e.length-2)}`));for(let e=0;e<d.length;e++){const a=d[e];"replaceShaderIOStructs"!==a&&t.shaderReplacements.has(a)&&t.shaderReplacements.get(a)(n,r,o)}e.replaceShaderIOStructs(n,r,o)},e.replaceShaderIOStructs=(e,t,n)=>{const r=t.getShaderDescription("vertex");r.replaceShaderCode(null,n),t.getShaderDescription("fragment").replaceShaderCode(r)},e.replaceShaderRenderEncoder=(e,n,r)=>{t.renderEncoder.replaceShaderCode(n)},t.shaderReplacements.set("replaceShaderRenderEncoder",e.replaceShaderRenderEncoder),e.replaceShaderRenderer=(e,n,r)=>{if(!t.WebGPURenderer)return;const o=t.WebGPURenderer.getBindGroup().getShaderCode(n),a=n.getShaderDescription("vertex");let i=a.getCode();i=dv.substitute(i,"//VTK::Renderer::Dec",[o]).result,a.setCode(i);const s=n.getShaderDescription("fragment");i=s.getCode(),i=dv.substitute(i,"//VTK::Renderer::Dec",[o]).result,s.setCode(i)},t.shaderReplacements.set("replaceShaderRenderer",e.replaceShaderRenderer),e.replaceShaderMapper=(e,n,r)=>{const o=t.bindGroup.getShaderCode(n),a=n.getShaderDescription("vertex");let i=a.getCode();i=dv.substitute(i,"//VTK::Mapper::Dec",[o]).result,a.setCode(i);const s=n.getShaderDescription("fragment");s.addBuiltinInput("bool","@builtin(front_facing) frontFacing"),i=s.getCode(),i=dv.substitute(i,"//VTK::Mapper::Dec",[o]).result,s.setCode(i)},t.shaderReplacements.set("replaceShaderMapper",e.replaceShaderMapper),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription("vertex");r.addBuiltinOutput("vec4<f32>","@builtin(position) Position");let o=r.getCode();o=dv.substitute(o,"//VTK::Position::Impl",["    output.Position = rendererUBO.SCPCMatrix*vertexBC;"]).result,r.setCode(o)},t.shaderReplacements.set("replaceShaderPosition",e.replaceShaderPosition),e.replaceShaderTCoord=(e,t,n)=>{t.getShaderDescription("vertex").addOutput("vec2<f32>","tcoordVS")},t.shaderReplacements.set("replaceShaderTCoord",e.replaceShaderTCoord),e.addTextureView=e=>{t.textureViews.includes(e)||t.textureViews.push(e)},e.prepareToDraw=n=>{t.renderEncoder=n,e.updateInput(),e.updateBuffers(),e.updateBindings(),e.updatePipeline()},e.updateInput=()=>{},e.updateBuffers=()=>{},e.updateBindings=()=>{t.bindGroup.setBindables(e.getBindables())},e.computePipelineHash=()=>{},e.registerDrawCallback=n=>{n.registerDrawCallback(t.pipeline,e.draw)},e.prepareAndDraw=n=>{e.prepareToDraw(n),n.setPipeline(t.pipeline),e.draw(n)},e.draw=e=>{const n=e.getBoundPipeline();e.activateBindGroup(t.bindGroup),t.WebGPURenderer&&t.WebGPURenderer.bindUBO(e),n.bindVertexInput(e,t.vertexInput);const r=t.vertexInput.getIndexBuffer();r?e.drawIndexed(r.getIndexCount(),t.numberOfInstances,0,0,0):e.draw(t.numberOfVertices,t.numberOfInstances,0,0)},e.getBindables=()=>{const e=[...t.additionalBindables];t.UBO&&e.push(t.UBO),t.SSBO&&e.push(t.SSBO);for(let n=0;n<t.textureViews.length;n++){e.push(t.textureViews[n]);const r=t.textureViews[n].getSampler();r&&e.push(r)}return e},e.updatePipeline=()=>{e.computePipelineHash(),t.pipeline=t.device.getPipeline(t.pipelineHash),t.pipeline||(t.pipeline=vv.newInstance(),t.pipeline.setDevice(t.device),t.WebGPURenderer&&t.pipeline.addBindGroupLayout(t.WebGPURenderer.getBindGroup()),t.pipeline.addBindGroupLayout(t.bindGroup),e.generateShaderDescriptions(t.pipelineHash,t.pipeline,t.vertexInput),t.pipeline.setTopology(t.topology),t.pipeline.setRenderEncoder(t.renderEncoder),t.pipeline.setVertexState(t.vertexInput.getVertexInputInformation()),t.device.createPipeline(t.pipelineHash,t.pipeline))}}(e,t)}var Lv={newInstance:Ht.newInstance(Dv,"vtkWebGPUSimpleMapper"),extend:Dv};const Bv={};function Nv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Bv,n),Lv.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkWebGPUFullScreenQuad"),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription("vertex");r.addBuiltinOutput("vec4<f32>","@builtin(position) Position"),r.addOutput("vec4<f32>","vertexVC");let o=r.getCode();o=dv.substitute(o,"//VTK::Position::Impl",["output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);","output.Position = vec4<f32>(vertexBC, 1.0);","output.vertexVC = vec4<f32>(vertexBC, 1);"]).result,r.setCode(o)},t.shaderReplacements.set("replaceShaderPosition",e.replaceShaderPosition),e.updateBuffers=()=>{const e=t.device.getBufferManager().getFullScreenQuadBuffer();t.vertexInput.addBuffer(e,["vertexBC"]),t.numberOfVertices=6}}(e,t)}var Fv={newInstance:Ht.newInstance(Nv,"vtkWebGPUFullScreenQuad"),extend:Nv};const _v=["setBindGroup","setIndexBuffer","setVertexBuffer","draw","drawIndexed"],kv={description:null,handle:null,boundPipeline:null,pipelineHash:null,pipelineSettings:null,replaceShaderCodeFunction:null,depthTextureView:null,label:null};function Gv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kv,n),vt(e,t),t.description={colorAttachments:[{view:void 0,loadOp:"load",storeOp:"store"}],depthStencilAttachment:{view:void 0,depthLoadOp:"clear",depthClearValue:0,depthStoreOp:"store"}},t.replaceShaderCodeFunction=e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor");let n=t.getCode();n=dv.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor = computedColor;"]).result,t.setCode(n)},t.pipelineSettings={primitive:{cullMode:"none"},depthStencil:{depthWriteEnabled:!0,depthCompare:"greater-equal",format:"depth32float"},fragment:{targets:[{format:"rgba16float",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]}},t.colorTextureViews=[],yt(e,t,["boundPipeline","colorTextureViews"]),St(e,t,["depthTextureView","description","handle","label","pipelineHash","pipelineSettings","replaceShaderCodeFunction"]),function(e,t){t.classHierarchy.push("vtkWebGPURenderEncoder"),e.begin=e=>{t.drawCallbacks=[],t.handle=e.beginRenderPass(t.description),t.label&&t.handle.pushDebugGroup(t.label)},e.end=()=>{for(let n=0;n<t.drawCallbacks.length;n++){const r=t.drawCallbacks[n],o=r.pipeline;e.setPipeline(o);for(let t=0;t<r.callbacks.length;t++)r.callbacks[t](e)}t.label&&t.handle.popDebugGroup(),t.handle.end(),t.boundPipeline=null},e.setPipeline=e=>{if(t.boundPipeline===e)return;t.handle.setPipeline(e.getHandle());const n=e.getPipelineDescription();if(t.colorTextureViews.length!==n.fragment.targets.length)console.log(`mismatched attachment counts on pipeline ${n.fragment.targets.length} while encoder has ${t.colorTextureViews.length}`),console.trace();else for(let e=0;e<t.colorTextureViews.length;e++){const r=t.colorTextureViews[e].getTexture()?.getFormat();r&&r!==n.fragment.targets[e].format&&(console.log(`mismatched attachments for attachment ${e} on pipeline ${n.fragment.targets[e].format} while encoder has ${r}`),console.trace())}if(!t.depthTextureView!=!("depthStencil"in n))console.log("mismatched depth attachments"),console.trace();else if(t.depthTextureView){const e=t.depthTextureView.getTexture()?.getFormat();e&&e!==n.depthStencil.format&&(console.log(`mismatched depth attachments on pipeline ${n.depthStencil.format} while encoder has ${e}`),console.trace())}t.boundPipeline=e},e.replaceShaderCode=e=>{t.replaceShaderCodeFunction(e)},e.setColorTextureView=(e,n)=>{t.colorTextureViews[e]!==n&&(t.colorTextureViews[e]=n)},e.activateBindGroup=e=>{const n=t.boundPipeline.getDevice(),r=t.boundPipeline.getBindGroupLayoutCount(e.getLabel());t.handle.setBindGroup(r,e.getBindGroup(n));const o=n.getBindGroupLayoutDescription(e.getBindGroupLayout(n)),a=n.getBindGroupLayoutDescription(t.boundPipeline.getBindGroupLayout(r));o!==a&&(console.log(`renderEncoder ${t.pipelineHash} mismatched bind group layouts bind group has\n${o}\n versus pipeline\n${a}\n`),console.trace())},e.attachTextureViews=()=>{for(let e=0;e<t.colorTextureViews.length;e++)t.description.colorAttachments[e]?t.description.colorAttachments[e].view=t.colorTextureViews[e].getHandle():t.description.colorAttachments[e]={view:t.colorTextureViews[e].getHandle()};t.depthTextureView&&(t.description.depthStencilAttachment.view=t.depthTextureView.getHandle())},e.registerDrawCallback=(e,n)=>{for(let r=0;r<t.drawCallbacks.length;r++)if(t.drawCallbacks[r].pipeline===e)return void t.drawCallbacks[r].callbacks.push(n);t.drawCallbacks.push({pipeline:e,callbacks:[n]})};for(let n=0;n<_v.length;n++)e[_v[n]]=function(){return t.handle[_v[n]](...arguments)}}(e,t)}var Uv={newInstance:Et(Gv,"vtkWebGPURenderEncoder"),extend:Gv};const zv={device:null,handle:null,label:null,options:null};function Wv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,zv,n),Ht.obj(e,t),t.options={},t.bindGroupLayoutEntry={visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,sampler:{}},t.bindGroupTime={},Ht.obj(t.bindGroupTime,{mtime:0}),Ht.get(e,t,["bindGroupTime","handle","options"]),Ht.setGet(e,t,["bindGroupLayoutEntry","device","label"]),function(e,t){t.classHierarchy.push("vtkWebGPUSampler"),e.create=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};t.device=e,t.options.addressModeU=n.addressModeU?n.addressModeU:"clamp-to-edge",t.options.addressModeV=n.addressModeV?n.addressModeV:"clamp-to-edge",t.options.addressModeW=n.addressModeW?n.addressModeW:"clamp-to-edge",t.options.magFilter=n.magFilter?n.magFilter:"nearest",t.options.minFilter=n.minFilter?n.minFilter:"nearest",t.options.mipmapFilter=n.mipmapFilter?n.mipmapFilter:"nearest",t.options.label=t.label,t.handle=t.device.getHandle().createSampler(t.options),t.bindGroupTime.modified()},e.getShaderCode=(e,n)=>`@binding(${e}) @group(${n}) var ${t.label}: sampler;`,e.getBindGroupEntry=()=>({resource:t.handle})}(e,t)}var Hv={newInstance:Ht.newInstance(Wv),extend:Wv};const jv={texture:null,handle:null,sampler:null,label:null};function Kv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,jv,n),Ht.obj(e,t),t.bindGroupLayoutEntry={visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,texture:{sampleType:"float",viewDimension:"2d"}},t.bindGroupTime={},Ht.obj(t.bindGroupTime,{mtime:0}),Ht.get(e,t,["bindGroupTime","texture"]),Ht.setGet(e,t,["bindGroupLayoutEntry","label","sampler"]),function(e,t){t.classHierarchy.push("vtkWebGPUTextureView"),e.create=(e,n)=>{t.texture=e,t.options=n,t.options.dimension=t.options.dimension||"2d",t.options.label=t.label,t.textureHandle=e.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupLayoutEntry.texture.viewDimension=t.options.dimension;const r=Cv(t.texture.getFormat());t.bindGroupLayoutEntry.texture.sampleType=r.sampleType},e.createFromTextureHandle=(e,n)=>{t.texture=null,t.options=n,t.options.dimension=t.options.dimension||"2d",t.options.label=t.label,t.textureHandle=e,t.handle=t.textureHandle.createView(t.options),t.bindGroupLayoutEntry.texture.viewDimension=t.options.dimension;const r=Cv(n.format);t.bindGroupLayoutEntry.texture.sampleType=r.sampleType,t.bindGroupTime.modified()},e.getBindGroupEntry=()=>({resource:e.getHandle()}),e.getShaderCode=(e,n)=>{let r="f32";"sint"===t.bindGroupLayoutEntry.texture.sampleType?r="i32":"uint"===t.bindGroupLayoutEntry.texture.sampleType&&(r="u32");let o=`@binding(${e}) @group(${n}) var ${t.label}: texture_${t.options.dimension}<${r}>;`;return"depth"===t.bindGroupLayoutEntry.texture.sampleType&&(o=`@binding(${e}) @group(${n}) var ${t.label}: texture_depth_${t.options.dimension};`),o},e.addSampler=(n,r)=>{const o=Hv.newInstance({label:`${t.label}Sampler`});o.create(n,r),e.setSampler(o)},e.getBindGroupTime=()=>(t.texture&&t.texture.getHandle()!==t.textureHandle&&(t.textureHandle=t.texture.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupTime.modified()),t.bindGroupTime),e.getHandle=()=>(t.texture&&t.texture.getHandle()!==t.textureHandle&&(t.textureHandle=t.texture.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupTime.modified()),t.handle)}(e,t)}var $v={newInstance:Ht.newInstance(Kv),extend:Kv};const qv={device:null,handle:null,buffer:null,ready:!1,label:null};function Xv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,qv,n),Ht.obj(e,t),Ht.get(e,t,["handle","ready","width","height","depth","format","usage"]),Ht.setGet(e,t,["device","label"]),function(e,t){t.classHierarchy.push("vtkWebGPUTexture"),e.create=(e,n)=>{t.device=e,t.width=n.width,t.height=n.height,t.depth=n.depth?n.depth:1;const r=1===t.depth?"2d":"3d";t.format=n.format?n.format:"rgba8unorm",t.mipLevel=n.mipLevel?n.mipLevel:0,t.usage=n.usage?n.usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label,dimension:r,mipLevelCount:t.mipLevel+1})},e.assignFromHandle=(e,n,r)=>{t.device=e,t.handle=n,t.width=r.width,t.height=r.height,t.depth=r.depth?r.depth:1,t.format=r.format?r.format:"rgba8unorm",t.usage=r.usage?r.usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST},e.writeImageData=n=>{let r=[];const o=r=>{t.device.getHandle().queue.copyExternalImageToTexture({source:r,flipY:n.flip},{texture:t.handle,premultipliedAlpha:!0,mipLevel:0,origin:{x:0,y:0,z:0}},[r.width,r.height,t.depth]),3!==e.getDimensionality()&&t.mipLevel>0&&zc.generateMipmaps(t.device.getHandle(),t.handle,t.mipLevel+1),t.ready=!0};if(n.canvas)return void o(n.canvas);if(n.imageBitmap)return n.width=n.imageBitmap.width,n.height=n.imageBitmap.height,n.depth=1,n.format="rgba8unorm",n.flip=!0,void o(n.imageBitmap);if(n.jsImageData)return n.width=n.jsImageData.width,n.height=n.jsImageData.height,n.depth=1,n.format="rgba8unorm",n.flip=!0,void o(n.jsImageData);if(n.image)return n.width=n.image.width,n.height=n.image.height,n.depth=1,n.format="rgba8unorm",n.flip=!0,void o(n.image);const a=Cv(t.format);let i=t.width*a.stride;n.nativeArray&&(r=n.nativeArray);const s=3===e.getDimensionality(),l=((e,t,n)=>{const r=2===a.elementSize&&"float"===a.sampleType,o=e.BYTES_PER_ELEMENT,i=e.length/(t*n)*o;if(!r&&i%256==0)return[e,i];const s=i/o,l=a.elementSize,c=256*Math.floor((s*l+255)/256),u=c/l,d=Ht.newTypedArray(r?"Uint16Array":e.constructor.name,u*t*n),p=t*n;if(r)for(let t=0;t<p;t++){const n=t*s,r=t*u;for(let t=0;t<s;t++)d[r+t]=ku.toHalf(e[n+t])}else if(u===s)d.set(e);else for(let t=0;t<p;t++)d.set(e.subarray(t*s,(t+1)*s),t*u);return[d,c]})(r,t.height,s?t.depth:1);i=l[1];const c=l[0];t.device.getHandle().queue.writeTexture({texture:t.handle,mipLevel:0,origin:{x:0,y:0,z:0}},c,{offset:0,bytesPerRow:i,rowsPerImage:t.height},{width:t.width,height:t.height,depthOrArrayLayers:s?t.depth:1}),!s&&t.mipLevel>0&&zc.generateMipmaps(t.device.getHandle(),t.handle,t.mipLevel+1),t.ready=!0},e.getScale=()=>{const e=Cv(t.format);return 2===e.elementSize&&"float"===e.sampleType?1:255},e.getNumberOfComponents=()=>Cv(t.format).numComponents,e.getDimensionality=()=>{let e=0;return t.width>1&&e++,t.height>1&&e++,t.depth>1&&e++,e},e.resizeToMatch=e=>{e.getWidth()===t.width&&e.getHeight()===t.height&&e.getDepth()===t.depth||(t.width=e.getWidth(),t.height=e.getHeight(),t.depth=e.getDepth(),t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label}))},e.resize=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;e===t.width&&n===t.height&&r===t.depth||(t.width=e,t.height=n,t.depth=r,t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label}))},e.createView=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};r.dimension||(r.dimension=1===t.depth?"2d":"3d");const o=$v.newInstance({label:n});return o.create(e,r),o}}(e,t)}var Yv={newInstance:Ht.newInstance(Xv),extend:Xv};const Zv={renderEncoder:null,colorTexture:null,depthTexture:null};function Qv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Zv,n),wh.extend(e,t,n),Ht.get(e,t,["colorTexture","depthTexture"]),function(e,t){t.classHierarchy.push("vtkWebGPUOpaquePass"),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r;const o=r.getDevice();if(t.renderEncoder)t.colorTexture.resize(r.getCanvas().width,r.getCanvas().height),t.depthTexture.resize(r.getCanvas().width,r.getCanvas().height);else{e.createRenderEncoder(),t.colorTexture=Yv.newInstance({label:"opaquePassColor"}),t.colorTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:"rgba16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC});const n=t.colorTexture.createView("opaquePassColorTexture");t.renderEncoder.setColorTextureView(0,n),t.depthFormat="depth32float",t.depthTexture=Yv.newInstance({label:"opaquePassDepth"}),t.depthTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:t.depthFormat,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC});const a=t.depthTexture.createView("opaquePassDepthTexture");t.renderEncoder.setDepthTextureView(a)}t.renderEncoder.attachTextureViews(),e.setCurrentOperation("opaquePass"),n.setRenderEncoder(t.renderEncoder),n.traverse(e)},e.getColorTextureView=()=>t.renderEncoder.getColorTextureViews()[0],e.getDepthTextureView=()=>t.renderEncoder.getDepthTextureView(),e.createRenderEncoder=()=>{t.renderEncoder=Uv.newInstance({label:"OpaquePass"}),t.renderEncoder.setPipelineHash("op")}}(e,t)}var Jv={newInstance:Ht.newInstance(Qv,"vtkWebGPUOpaquePass"),extend:Qv};const eT={colorTextureView:null,depthTextureView:null};function tT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,eT,n),wh.extend(e,t,n),Ht.setGet(e,t,["colorTextureView","depthTextureView"]),function(e,t){t.classHierarchy.push("vtkWebGPUOrderIndependentTranslucentPass"),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r;const o=r.getDevice();if(t.translucentRenderEncoder)t.translucentColorTexture.resizeToMatch(t.colorTextureView.getTexture()),t.translucentAccumulateTexture.resizeToMatch(t.colorTextureView.getTexture());else{e.createRenderEncoder(),e.createFinalEncoder(),t.translucentColorTexture=Yv.newInstance({label:"translucentPassColor"}),t.translucentColorTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:"rgba16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const n=t.translucentColorTexture.createView("oitpColorTexture");t.translucentRenderEncoder.setColorTextureView(0,n),t.translucentAccumulateTexture=Yv.newInstance({label:"translucentPassAccumulate"}),t.translucentAccumulateTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:"r16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const a=t.translucentAccumulateTexture.createView("oitpAccumTexture");t.translucentRenderEncoder.setColorTextureView(1,a),t.fullScreenQuad=Fv.newInstance(),t.fullScreenQuad.setDevice(r.getDevice()),t.fullScreenQuad.setPipelineHash("oitpfsq"),t.fullScreenQuad.setTextureViews(t.translucentRenderEncoder.getColorTextureViews()),t.fullScreenQuad.setFragmentShaderTemplate("\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var tcoord: vec2<i32> = vec2<i32>(i32(input.fragPos.x), i32(input.fragPos.y));\n  var reveal: f32 = textureLoad(oitpAccumTexture, tcoord, 0).r;\n  if (reveal == 1.0) { discard; }\n  var tcolor: vec4<f32> = textureLoad(oitpColorTexture, tcoord, 0);\n  var total: f32 = max(tcolor.a, 0.01);\n  var computedColor: vec4<f32> = vec4<f32>(tcolor.r/total, tcolor.g/total, tcolor.b/total, 1.0 - reveal);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n")}t.translucentRenderEncoder.setDepthTextureView(t.depthTextureView),t.translucentRenderEncoder.attachTextureViews(),e.setCurrentOperation("translucentPass"),n.setRenderEncoder(t.translucentRenderEncoder),n.traverse(e),e.finalPass(r,n)},e.finalPass=(e,n)=>{t.translucentFinalEncoder.setColorTextureView(0,t.colorTextureView),t.translucentFinalEncoder.attachTextureViews(),t.translucentFinalEncoder.begin(e.getCommandEncoder()),n.scissorAndViewport(t.translucentFinalEncoder),t.fullScreenQuad.prepareAndDraw(t.translucentFinalEncoder),t.translucentFinalEncoder.end()},e.getTextures=()=>[t.translucentColorTexture,t.translucentAccumulateTexture],e.createRenderEncoder=()=>{t.translucentRenderEncoder=Uv.newInstance({label:"translucentRender"});const e=t.translucentRenderEncoder.getDescription();e.colorAttachments=[{view:void 0,clearValue:[0,0,0,0],loadOp:"clear",storeOp:"store"},{view:void 0,clearValue:[1,0,0,0],loadOp:"clear",storeOp:"store"}],e.depthStencilAttachment={view:void 0,depthLoadOp:"load",depthStoreOp:"store"},t.translucentRenderEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor"),t.addOutput("f32","outAccum"),t.addBuiltinInput("vec4<f32>","@builtin(position) fragPos");let n=t.getCode();n=dv.substitute(n,"//VTK::RenderEncoder::Impl",["var w: f32 = computedColor.a * pow(0.1 + input.fragPos.z, 2.0);","output.outColor = vec4<f32>(computedColor.rgb*w, w);","output.outAccum = computedColor.a;"]).result,t.setCode(n)})),t.translucentRenderEncoder.setPipelineHash("oitpr"),t.translucentRenderEncoder.setPipelineSettings({primitive:{cullMode:"none"},depthStencil:{depthWriteEnabled:!1,depthCompare:"greater",format:"depth32float"},fragment:{targets:[{format:"rgba16float",blend:{color:{srcFactor:"one",dstFactor:"one"},alpha:{srcFactor:"one",dstFactor:"one"}}},{format:"r16float",blend:{color:{srcFactor:"zero",dstFactor:"one-minus-src"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})},e.createFinalEncoder=()=>{t.translucentFinalEncoder=Uv.newInstance({label:"translucentFinal"}),t.translucentFinalEncoder.setDescription({colorAttachments:[{view:null,loadOp:"load",storeOp:"store"}]}),t.translucentFinalEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor"),t.addBuiltinInput("vec4<f32>","@builtin(position) fragPos");let n=t.getCode();n=dv.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor = vec4<f32>(computedColor.rgb, computedColor.a);"]).result,t.setCode(n)})),t.translucentFinalEncoder.setPipelineHash("oitpf"),t.translucentFinalEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"rgba16float",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})}}(e,t)}var nT={newInstance:Ht.newInstance(tT,"vtkWebGPUOrderIndependentTranslucentPass"),extend:tT},rT={BufferUsage:{Verts:0,Lines:1,Triangles:2,Strips:3,LinesFromStrips:4,LinesFromTriangles:5,Points:6,UniformArray:7,PointArray:8,NormalsFromPoints:9,Texture:10,RawVertex:11,Storage:12,Index:13},PrimitiveTypes:{Start:0,Points:0,Lines:1,Triangles:2,TriangleStrips:3,TriangleEdges:4,TriangleStripEdges:5,End:6}};const oT=["getMappedRange","mapAsync","unmap"];const aT={device:null,handle:null,sizeInBytes:0,strideInBytes:0,arrayInformation:null,usage:null,label:null,sourceTime:null};function iT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,aT,n),Ht.obj(e,t),Ht.get(e,t,["handle","sizeInBytes","usage"]),Ht.setGet(e,t,["strideInBytes","device","arrayInformation","label","sourceTime"]),function(e,t){t.classHierarchy.push("vtkWebGPUBuffer"),e.create=(e,n)=>{t.handle=t.device.getHandle().createBuffer({size:e,usage:n,label:t.label}),t.sizeInBytes=e,t.usage=n},e.write=e=>{!function(e,t,n,r){const o=r.byteLength,a=e.createBuffer({size:o,usage:GPUBufferUsage.COPY_SRC,mappedAtCreation:!0}),i=a.getMappedRange(0,o);new Uint8Array(i).set(new Uint8Array(r)),a.unmap();const s=e.createCommandEncoder();s.copyBufferToBuffer(a,0,t,0,o);const l=s.finish();e.queue.submit([l]),a.destroy()}(t.device.getHandle(),t.handle,0,e.buffer)},e.createAndWrite=(e,n)=>{const r=4*Math.ceil(e.byteLength/4);t.handle=t.device.getHandle().createBuffer({size:r,usage:n,mappedAtCreation:!0,label:t.label}),t.sizeInBytes=r,t.usage=n,new Uint8Array(t.handle.getMappedRange()).set(new Uint8Array(e.buffer)),t.handle.unmap()};for(let n=0;n<oT.length;n++)e[oT[n]]=function(){return t.handle[oT[n]](...arguments)}}(e,t)}var sT={newInstance:Ht.newInstance(iT),extend:iT,...rT};const{Representation:lT}=ts,{PrimitiveTypes:cT}=rT;class uT{constructor(){this.keys=new Uint32Array(10),this.values=new Uint32Array(10),this.count=0}clear(){this.count=0}has(e){for(let t=0;t<this.count;t++)if(this.keys[t]===e)return!0}get(e){for(let t=0;t<this.count;t++)if(this.keys[t]===e)return this.values[t]}set(e,t){this.count<9&&(this.keys[this.count]=e,this.values[this.count++]=t)}}function dT(e,t,n){let r=e.pointIdToFlatId[t];return r<0&&(r=e.flatId,e.pointIdToFlatId[t]=r,e.flatIdToPointId[e.flatId]=t,e.flatIdToCellId[e.flatId]=n,e.flatId++),r}function pT(e,t,n){const r=e.length;for(let o=0;o<r;o++){let a=e[o];if(n.cellProvokedMap.has(a)){n.ibo[n.iboId++]=n.cellProvokedMap.get(a);for(let i=o+1;i<o+r;i++){a=e[i%r];const o=dT(n,a,t);n.ibo[n.iboId++]=o}return}}for(let o=0;o<r;o++){let a=e[o];if(!n.provokedPointIds[a]){let i=dT(n,a,t);n.provokedPointIds[a]=1,n.cellProvokedMap.set(a,i),n.flatIdToCellId[i]=t,n.ibo[n.iboId++]=i;for(let s=o+1;s<o+r;s++)a=e[s%r],i=dT(n,a,t),n.ibo[n.iboId++]=i;return}}let o=e[0],a=n.flatId;n.cellProvokedMap.set(o,a),n.flatIdToPointId[n.flatId]=o,n.flatIdToCellId[n.flatId]=t,n.flatId++,n.ibo[n.iboId++]=a;for(let i=1;i<r;i++)o=e[i],a=dT(n,o,t),n.ibo[n.iboId++]=a}function fT(e,t,n){const r=e.length;n.iboSize+=r;for(let t=0;t<r;t++){const r=e[t];if(n.cellProvokedMap.has(r))return}for(let t=0;t<r;t++){const r=e[t];if(!n.provokedPointIds[r])return n.provokedPointIds[r]=1,void n.cellProvokedMap.set(r,1)}n.cellProvokedMap.set(e[0],1),n.extraPoints++}let gT;const mT=new Uint32Array(1),hT=new Uint32Array(2),vT=new Uint32Array(3),TT={anythingToPoints(e,t,n,r,o){for(let a=0;a<e;++a)mT[0]=t[n+a],gT(mT,r,o)},linesToWireframe(e,t,n,r,o){for(let a=0;a<e-1;++a)hT[0]=t[n+a],hT[1]=t[n+a+1],gT(hT,r,o)},polysToWireframe(e,t,n,r,o){if(e>2)for(let a=0;a<e;++a)hT[0]=t[n+a],hT[1]=t[n+(a+1)%e],gT(hT,r,o)},stripsToWireframe(e,t,n,r,o){if(e>2){for(let a=0;a<e-1;++a)hT[0]=t[n+a],hT[1]=t[n+a+1],gT(hT,r,o);for(let a=0;a<e-2;a++)hT[0]=t[n+a],hT[1]=t[n+a+2],gT(hT,r,o)}},polysToSurface(e,t,n,r,o){for(let a=0;a<e-2;a++)vT[0]=t[n],vT[1]=t[n+a+1],vT[2]=t[n+a+2],gT(vT,r,o)},stripsToSurface(e,t,n,r,o){for(let a=0;a<e-2;a++)vT[0]=t[n+a],vT[1]=t[n+a+1+a%2],vT[2]=t[n+a+1+(a+1)%2],gT(vT,r,o)}};const yT={flatIdToPointId:null,flatIdToCellId:null,flatSize:0,indexCount:0};function bT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,yT,n),sT.extend(e,t,n),Ht.setGet(e,t,["flatIdToPointId","flatIdToCellId","flatSize","indexCount"]),function(e,t){t.classHierarchy.push("vtkWebGPUIndexBuffer"),e.buildIndexBuffer=e=>{const n=e.cells,r=e.primitiveType,o=e.representation,a=e.cellOffset,i=n.getData(),s=i.length,l=function(e){switch(e){case cT.Points:return"points";case cT.Lines:return"lines";case cT.Triangles:case cT.TriangleEdges:return"polys";case cT.TriangleStripEdges:case cT.TriangleStrips:return"strips";default:return""}}(r),c=e.numberOfPoints,u={provokedPointIds:new Uint8Array(c),extraPoints:0,iboSize:0,flatId:0,iboId:0,cellProvokedMap:new uT};let d=null;d=o===lT.POINTS||r===cT.Points?TT.anythingToPoints:o===lT.WIREFRAME||r===cT.Lines?TT[`${l}ToWireframe`]:TT[`${l}ToSurface`],gT=fT;let p=a||0;for(let e=0;e<s;)u.cellProvokedMap.clear(),d(i[e],i,e+1,p,u),e+=i[e]+1,p++;u.flatIdToPointId=c<=65535?new Uint16Array(c+u.extraPoints):new Uint32Array(c+u.extraPoints),c+u.extraPoints<36863?u.pointIdToFlatId=new Int16Array(c):u.pointIdToFlatId=new Int32Array(c),c+u.extraPoints<=65535?(u.ibo=new Uint16Array(u.iboSize),e.format="uint16"):(u.ibo=new Uint32Array(u.iboSize),e.format="uint32"),u.flatIdToCellId=p<=65535?new Uint16Array(c+u.extraPoints):new Uint32Array(c+u.extraPoints),u.pointIdToFlatId.fill(-1),u.provokedPointIds.fill(0),gT=pT,p=a||0;for(let e=0;e<s;)u.cellProvokedMap.clear(),d(i[e],i,e+1,p,u),e+=i[e]+1,p++;delete u.provokedPointIds,delete u.pointIdToFlatId,e.nativeArray=u.ibo,t.flatIdToPointId=u.flatIdToPointId,t.flatIdToCellId=u.flatIdToCellId,t.flatSize=u.flatId,t.indexCount=u.iboId}}(e,t)}var xT={newInstance:Ht.newInstance(bT),extend:bT,...rT};const{BufferUsage:CT}=rT,{vtkErrorMacro:ST}=jt,{VtkDataTypes:AT}=Ts;function IT(e,t,n,r,o){const a={},i=e.getFlatSize();if(!i)return a;let s=[0,0,0,0];o.shift&&(o.shift.length?s=o.shift:s.fill(o.shift));let l=[1,1,1,1];o.scale&&(o.scale.length?l=o.scale:l.fill(o.scale));const c=!!Object.prototype.hasOwnProperty.call(o,"packExtra")&&o.packExtra;let u,d=0;const p=it(r,i*(n+(c?1:0)));let f=e.getFlatIdToPointId();o.cellData&&(f=e.getFlatIdToCellId()),1===n?u=function(e){p[d++]=l[0]*t[e]+s[0]}:2===n?u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1]}:3!==n||c?3===n&&c?u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2],p[d++]=1*l[3]+s[3]}:4===n&&(u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2],p[d++]=l[3]*t[e+3]+s[3]}):u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2]};for(let e=0;e<i;e++)u(n*f[e]);return a.nativeArray=p,a}function wT(e,t,n,r){const o=[];return Fo([e[3*r]-e[3*n],e[3*r+1]-e[3*n+1],e[3*r+2]-e[3*n+2]],[e[3*t]-e[3*n],e[3*t+1]-e[3*n+1],e[3*t+2]-e[3*n+2]],o),ko(o),o}const OT={device:null,fullScreenQuadBuffer:null};function PT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,OT,n),vt(e,t),St(e,t,["device"]),function(e,t){function n(e){let n,r;if(e.dataArray&&!e.nativeArray&&(e.nativeArray=e.dataArray.getData()),e.usage===CT.Index&&(n=xT.newInstance({label:e.label}),n.setDevice(t.device),r=GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST,n.buildIndexBuffer(e),n.createAndWrite(e.nativeArray,r),n.setArrayInformation([{format:e.format}])),n||(n=sT.newInstance({label:e.label}),n.setDevice(t.device)),e.usage===CT.UniformArray&&(r=GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,n.createAndWrite(e.nativeArray,r)),e.usage===CT.Storage&&(r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,n.createAndWrite(e.nativeArray,r)),e.usage===CT.Texture&&(r=GPUBufferUsage.COPY_SRC,n.createAndWrite(e.nativeArray,r)),e.usage===CT.PointArray){r=GPUBufferUsage.VERTEX;const t=Av(e.format),o=IT(e.indexBuffer,e.dataArray.getData(),e.dataArray.getNumberOfComponents(),t,{packExtra:e.packExtra,shift:e.shift,scale:e.scale,cellData:e.cellData,cellOffset:e.cellOffset});n.createAndWrite(o.nativeArray,r),n.setStrideInBytes(Sv(e.format)),n.setArrayInformation([{offset:0,format:e.format,interpolation:e.cellData?"flat":"perspective"}])}if(e.usage===CT.NormalsFromPoints){r=GPUBufferUsage.VERTEX;const t=Av(e.format),o=function(e,t){const n=t.getData(),r=e.getData();if(!r||!n)return null;const o=new Int8Array(4*e.getNumberOfCells()),a=r.length;let i=0;for(let e=0;e<a;){const t=wT(n,r[e+1],r[e+2],r[e+3]);o[i++]=127*t[0],o[i++]=127*t[1],o[i++]=127*t[2],o[i++]=127,e+=r[e]+1}return o}(e.cells,e.dataArray),a=IT(e.indexBuffer,o,4,t,{cellData:!0});n.createAndWrite(a.nativeArray,r),n.setStrideInBytes(Sv(e.format)),n.setArrayInformation([{offset:0,format:e.format,interpolation:"flat"}])}return e.usage===CT.RawVertex&&(r=GPUBufferUsage.VERTEX,n.createAndWrite(e.nativeArray,r),n.setStrideInBytes(Sv(e.format)),n.setArrayInformation([{offset:0,format:e.format}])),n.setSourceTime(e.time),n}t.classHierarchy.push("vtkWebGPUBufferManager"),e.hasBuffer=e=>t.device.hasCachedObject(e),e.getBuffer=e=>e.hash?t.device.getCachedObject(e.hash,n,e):n(e),e.getBufferForPointArray=(t,n)=>{const r=function(e){let t;switch(e.getDataType()){case AT.UNSIGNED_CHAR:t="uint8";break;case AT.FLOAT:t="float32";break;case AT.UNSIGNED_INT:t="uint32";break;case AT.INT:t="sint32";break;case AT.DOUBLE:t="float32";break;case AT.UNSIGNED_SHORT:t="uint16";break;case AT.SHORT:t="sin16";break;default:t="float32"}switch(e.getNumberOfComponents()){case 2:t+="x2";break;case 3:t.includes("32")||ST(`unsupported x3 type for ${t}`),t+="x3";break;case 4:t+="x4"}return t}(t),o={hash:`${t.getMTime()}I${n.getMTime()}${r}`,usage:CT.PointArray,format:r,dataArray:t,indexBuffer:n};return e.getBuffer(o)},e.getFullScreenQuadBuffer=()=>{if(t.fullScreenQuadBuffer)return t.fullScreenQuadBuffer;t.fullScreenQuadBuffer=sT.newInstance(),t.fullScreenQuadBuffer.setDevice(t.device);const e=new Float32Array([-1,-1,0,1,-1,0,1,1,0,-1,-1,0,1,1,0,-1,1,0]);return t.fullScreenQuadBuffer.createAndWrite(e,GPUBufferUsage.VERTEX),t.fullScreenQuadBuffer.setStrideInBytes(12),t.fullScreenQuadBuffer.setArrayInformation([{offset:0,format:"float32x3"}]),t.fullScreenQuadBuffer}}(e,t)}var RT={newInstance:Et(PT),extend:PT,...rT};const{BufferUsage:MT}=RT,{vtkErrorMacro:ET}=Ht,VT={bufferEntries:null,bufferEntryNames:null,sizeInBytes:0,label:null,bindGroupLayoutEntry:null,bindGroupEntry:null};function DT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,VT,n),Ht.obj(e,t),t._bufferEntryNames=new Map,t.bufferEntries=[],t.bindGroupLayoutEntry=t.bindGroupLayoutEntry||{buffer:{type:"uniform"}},t.sendTime={},Ht.obj(t.sendTime,{mtime:0}),t.bindGroupTime={},Ht.obj(t.bindGroupTime,{mtime:0}),t.sendDirty=!0,t.sortDirty=!0,Ht.get(e,t,["binding","bindGroupTime"]),Ht.setGet(e,t,["bindGroupLayoutEntry","device","label","sizeInBytes"]),function(e,t){t.classHierarchy.push("vtkWebGPUUniformBuffer"),e.addEntry=(e,n)=>{t._bufferEntryNames.has(e)?ET(`entry named ${e} already exists`):(t.sortDirty=!0,t._bufferEntryNames.set(e,t.bufferEntries.length),t.bufferEntries.push({name:e,type:n,sizeInBytes:wv(n),offset:-1,nativeType:Ov(n),packed:!1}))},e.sortBufferEntries=()=>{if(!t.sortDirty)return;let e=0;const n=[];let r=4;for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];n.sizeInBytes%16==0&&(r=Math.max(16,r)),n.sizeInBytes%8==0&&(r=Math.max(8,r))}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];!1===o.packed&&o.sizeInBytes%16==0&&(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!1===o.packed&&12===o.sizeInBytes)for(let r=0;r<t.bufferEntries.length;r++){const a=t.bufferEntries[r];if(!1===a.packed&&4===a.sizeInBytes){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,a.packed=!0,a.offset=e,n.push(a),e+=a.sizeInBytes;break}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!o.packed&&o.sizeInBytes%8==0)for(let a=r+1;a<t.bufferEntries.length;a++){const r=t.bufferEntries[a];if(!r.packed&&r.sizeInBytes%8==0){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,r.packed=!0,r.offset=e,n.push(r),e+=r.sizeInBytes;break}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!o.packed&&o.sizeInBytes%8==0){let r=!1;for(let a=0;!r&&a<t.bufferEntries.length;a++){const i=t.bufferEntries[a];if(!i.packed&&4===i.sizeInBytes)for(let s=a+1;s<t.bufferEntries.length;s++){const a=t.bufferEntries[s];if(!a.packed&&4===a.sizeInBytes){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,i.packed=!0,i.offset=e,n.push(i),e+=i.sizeInBytes,a.packed=!0,a.offset=e,n.push(a),e+=a.sizeInBytes,r=!0;break}}}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];!o.packed&&o.sizeInBytes>4&&(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];o.packed||(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}t.bufferEntries=n,t._bufferEntryNames.clear();for(let e=0;e<t.bufferEntries.length;e++)t._bufferEntryNames.set(t.bufferEntries[e].name,e);t.sizeInBytes=e,t.sizeInBytes=r*Math.ceil(t.sizeInBytes/r),t.sortDirty=!1},e.sendIfNeeded=e=>{if(!t.UBO){const n={nativeArray:t.Float32Array,usage:MT.UniformArray,label:t.label};t.UBO=e.getBufferManager().getBuffer(n),t.bindGroupTime.modified(),t.sendDirty=!1}t.sendDirty&&(e.getHandle().queue.writeBuffer(t.UBO.getHandle(),0,t.arrayBuffer,0,t.sizeInBytes),t.sendDirty=!1),t.sendTime.modified()},e.createView=e=>{e in t==0&&(t.arrayBuffer||(t.arrayBuffer=new ArrayBuffer(t.sizeInBytes)),t[e]=Ht.newTypedArray(e,t.arrayBuffer))},e.setValue=(n,r)=>{e.sortBufferEntries();const o=t._bufferEntryNames.get(n);if(void 0===o)return void ET(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];a.lastValue!==r&&(i[a.offset/i.BYTES_PER_ELEMENT]=r,t.sendDirty=!0),a.lastValue=r},e.setArray=(n,r)=>{e.sortBufferEntries();const o=t._bufferEntryNames.get(n);if(void 0===o)return void ET(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];let s=!1;for(let e=0;e<r.length;e++)a.lastValue&&a.lastValue[e]===r[e]||(i[a.offset/i.BYTES_PER_ELEMENT+e]=r[e],s=!0);s&&(t.sendDirty=!0,a.lastValue=[...r])},e.getBindGroupEntry=()=>({resource:{buffer:t.UBO.getHandle()}}),e.getSendTime=()=>t.sendTime.getMTime(),e.getShaderCode=(n,r)=>{e.sortBufferEntries();const o=[`struct ${t.label}Struct\n{`];for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];o.push(`  ${n.name}: ${n.type},`)}return o.push(`};\n@binding(${n}) @group(${r}) var<uniform> ${t.label}: ${t.label}Struct;`),o.join("\n")}}(e,t)}var LT={newInstance:Ht.newInstance(DT,"vtkWebGPUUniformBuffer"),extend:DT};const{BufferUsage:BT}=RT,{vtkErrorMacro:NT}=Ht,FT={bufferEntries:null,bufferEntryNames:null,sizeInBytes:0,label:null,numberOfInstances:1};function _T(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,FT,n),Ht.obj(e,t),t._bufferEntryNames=new Map,t.bufferEntries=[],t._sendTime={},Ht.obj(t._sendTime,{mtime:0}),t.bindGroupTime={},Ht.obj(t.bindGroupTime,{mtime:0}),t.bindGroupLayoutEntry=t.bindGroupLayoutEntry||{buffer:{type:"read-only-storage"}},Ht.get(e,t,["bindGroupTime"]),Ht.setGet(e,t,["device","bindGroupLayoutEntry","label","numberOfInstances","sizeInBytes"]),function(e,t){t.classHierarchy.push("vtkWebGPUStorageBuffer"),e.addEntry=(e,n)=>{if(t._bufferEntryNames.has(e))return void NT(`entry named ${e} already exists`);t._bufferEntryNames.set(e,t.bufferEntries.length);const r=wv(n);t.bufferEntries.push({name:e,type:n,sizeInBytes:r,offset:t.sizeInBytes,nativeType:Ov(n)}),t.sizeInBytes+=r},e.send=e=>{if(!t._buffer){const n={nativeArray:t.Float32Array,usage:BT.Storage,label:t.label};return t._buffer=e.getBufferManager().getBuffer(n),t.bindGroupTime.modified(),void t._sendTime.modified()}e.getHandle().queue.writeBuffer(t._buffer.getHandle(),0,t.arrayBuffer,0,t.sizeInBytes*t.numberOfInstances),t._sendTime.modified()},e.createView=e=>{e in t==0&&(t.arrayBuffer||(t.arrayBuffer=new ArrayBuffer(t.sizeInBytes*t.numberOfInstances)),t[e]=Ht.newTypedArray(e,t.arrayBuffer))},e.setValue=(n,r,o)=>{const a=t._bufferEntryNames.get(n);if(void 0===a)return void NT(`entry named ${n} not found in UBO`);const i=t.bufferEntries[a];e.createView(i.nativeType);const s=t[i.nativeType];s[(i.offset+r*t.sizeInBytes)/s.BYTES_PER_ELEMENT]=o},e.setArray=(n,r,o)=>{const a=t._bufferEntryNames.get(n);if(void 0===a)return void NT(`entry named ${n} not found in UBO`);const i=t.bufferEntries[a];e.createView(i.nativeType);const s=t[i.nativeType],l=(i.offset+r*t.sizeInBytes)/s.BYTES_PER_ELEMENT;for(let e=0;e<o.length;e++)s[l+e]=o[e]},e.setAllInstancesFromArray=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void NT(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType],s=r.length/t.numberOfInstances;for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<s;t++)i[n+t]=r[e*s+t]}},e.setAllInstancesFromArrayColorToFloat=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void NT(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType],s=r.length/t.numberOfInstances;for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<s;t++)i[n+t]=r[e*s+t]/255}},e.setAllInstancesFromArray3x3To4x4=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void NT(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<3;t++)for(let o=0;o<3;o++)i[n+4*t+o]=r[9*e+3*t+o]}},e.getSendTime=()=>t._sendTime.getMTime(),e.getShaderCode=(e,n)=>{const r=[`struct ${t.label}StructEntry\n{`];for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];r.push(`  ${n.name}: ${n.type},`)}return r.push(`\n};\nstruct ${t.label}Struct\n{\n  values: array<${t.label}StructEntry>,\n};\n@binding(${e}) @group(${n}) var<storage, read> ${t.label}: ${t.label}Struct;\n`),r.join("\n")},e.getBindGroupEntry=()=>({resource:{buffer:t._buffer.getHandle()}}),e.clearData=()=>{t.numberOfInstances=0,t.sizeInBytes=0,t.bufferEntries=[],t._bufferEntryNames=new Map,t._buffer=null,delete t.arrayBuffer,delete t.Float32Array}}(e,t)}var kT={newInstance:Ht.newInstance(_T,"vtkWebGPUStorageBuffer"),extend:_T};const GT=new Float64Array(16),UT=new Float64Array(16),zT={volumes:null,rowLength:1024,lastVolumeLength:0};function WT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,zT,n),Fv.extend(e,t,n),t.fragmentShaderTemplate="\n//VTK::Renderer::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Volume::TraverseDec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\nfn getTextureValue(vTex: texture_3d<f32>, tpos: vec4<f32>) -> f32\n{\n  // todo multicomponent support\n  return textureSampleLevel(vTex, clampSampler, tpos.xyz, 0.0).r;\n}\n\nfn getGradient(vTex: texture_3d<f32>, tpos: vec4<f32>, vNum: i32, scalar: f32) -> vec4<f32>\n{\n  var result: vec4<f32>;\n\n  var tstep: vec4<f32> = volumeSSBO.values[vNum].tstep;\n  result.x = getTextureValue(vTex, tpos + vec4<f32>(tstep.x, 0.0, 0.0, 1.0)) - scalar;\n  result.y = getTextureValue(vTex, tpos + vec4<f32>(0.0, tstep.y, 0.0, 1.0)) - scalar;\n  result.z = getTextureValue(vTex, tpos + vec4<f32>(0.0, 0.0, tstep.z, 1.0)) - scalar;\n  result.w = 0.0;\n\n  // divide by spacing as that is our delta\n  result = result / volumeSSBO.values[vNum].spacing;\n  // now we have a gradient in unit tcoords\n\n  var grad: f32 = length(result.xyz);\n  if (grad > 0.0)\n  {\n    // rotate to View Coords, needed for lighting and shading\n    var nMat: mat4x4<f32> = rendererUBO.SCVCMatrix * volumeSSBO.values[vNum].planeNormals;\n    result = nMat * result;\n    result = result / length(result);\n  }\n\n  // store gradient magnitude in .w\n  result.w = grad;\n\n  return result;\n}\n\nfn processVolume(vTex: texture_3d<f32>, vNum: i32, cNum: i32, posSC: vec4<f32>, tfunRows: f32) -> vec4<f32>\n{\n  var outColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n\n  // convert to tcoords and reject if outside the volume\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*posSC;\n  if (tpos.x < 0.0 || tpos.y < 0.0 || tpos.z < 0.0 ||\n      tpos.x > 1.0 || tpos.y > 1.0 || tpos.z > 1.0) { return outColor; }\n\n  var scalar: f32 = getTextureValue(vTex, tpos);\n\n  var coord: vec2<f32> =\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\n\n  var gofactor: f32 = 1.0;\n  var normal: vec4<f32> = vec4<f32>(0.0,0.0,0.0,0.0);\n  if (componentSSBO.values[cNum].gomin <  1.0 || volumeSSBO.values[vNum].shade[0] > 0.0)\n  {\n    normal = getGradient(vTex, tpos, vNum, scalar);\n    if (componentSSBO.values[cNum].gomin <  1.0)\n    {\n      gofactor = clamp(normal.a*componentSSBO.values[cNum].goScale + componentSSBO.values[cNum].goShift,\n      componentSSBO.values[cNum].gomin, componentSSBO.values[cNum].gomax);\n    }\n  }\n\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\n\n  if (volumeSSBO.values[vNum].shade[0] > 0.0)\n  {\n    color = color*abs(normal.z);\n  }\n\n  outColor = vec4<f32>(color.rgb, gofactor * opacity);\n\n  return outColor;\n}\n\n// adjust the start and end point of a raycast such that it intersects the unit cube.\n// This function is used to take a raycast starting point and step vector\n// and numSteps and return the startijng and ending steps for intersecting the\n// unit cube. Recall for a 3D texture, the unit cube is the range of texture coordsinates\n// that have valid values. So this funtion can be used to take a ray in texture coordinates\n// and bound it to intersecting the texture.\n//\nfn adjustBounds(tpos: vec4<f32>, tstep: vec4<f32>, numSteps: f32) -> vec2<f32>\n{\n  var result: vec2<f32> = vec2<f32>(0.0, numSteps);\n  var tpos2: vec4<f32> = tpos + tstep*numSteps;\n\n  // move tpos to the start of the volume\n  var adjust: f32 =\n    min(\n      max(tpos.x/tstep.x, (tpos.x - 1.0)/tstep.x),\n      min(\n        max((tpos.y - 1.0)/tstep.y, tpos.y/tstep.y),\n        max((tpos.z - 1.0)/tstep.z, tpos.z/tstep.z)));\n  if (adjust < 0.0)\n  {\n    result.x = result.x - adjust;\n  }\n\n  // adjust length to the end\n  adjust =\n    max(\n      min(tpos2.x/tstep.x, (tpos2.x - 1.0)/tstep.x),\n      max(\n        min((tpos2.y - 1.0)/tstep.y, tpos2.y/tstep.y),\n        min((tpos2.z - 1.0)/tstep.z, tpos2.z/tstep.z)));\n  if (adjust > 0.0)\n  {\n    result.y = result.y - adjust;\n  }\n\n  return result;\n}\n\nfn getSimpleColor(scalar: f32, vNum: i32, cNum: i32) -> vec4<f32>\n{\n  // how many rows (tfuns) do we have in our tfunTexture\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\n\n  var coord: vec2<f32> =\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\n  return vec4<f32>(color.rgb, opacity);\n}\n\nfn traverseMax(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var maxVal: f32 = -1.0e37;\n  loop\n  {\n    var scalar: f32 = getTextureValue(vTex, tpos);\n    if (scalar > maxVal)\n    {\n      maxVal = scalar;\n    }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(maxVal, vNum, cNum);\n}\n\nfn traverseMin(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var minVal: f32 = 1.0e37;\n  loop\n  {\n    var scalar: f32 = getTextureValue(vTex, tpos);\n    if (scalar < minVal)\n    {\n      minVal = scalar;\n    }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(minVal, vNum, cNum);\n}\n\nfn traverseAverage(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var avgVal: f32 = 0.0;\n  var sampleCount: f32 = 0.0;\n  loop\n  {\n    var sample: f32 = getTextureValue(vTex, tpos);\n    // right now leave filtering off until WebGL changes get merged\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\n    // {\n      avgVal = avgVal + sample;\n      sampleCount = sampleCount + 1.0;\n    // }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  if (sampleCount <= 0.0)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(avgVal/sampleCount, vNum, cNum);\n}\n\nfn traverseAdditive(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var sumVal: f32 = 0.0;\n  loop\n  {\n    var sample: f32 = getTextureValue(vTex, tpos);\n    // right now leave filtering off until WebGL changes get merged\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\n    // {\n      sumVal = sumVal + sample;\n    // }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(sumVal, vNum, cNum);\n}\n\nfn composite(rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>) -> vec4<f32>\n{\n  // initial ray position is at the beginning\n  var rayPosSC: vec4<f32> = minPosSC;\n\n  // how many rows (tfuns) do we have in our tfunTexture\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\n\n  var curDist: f32 = 0.0;\n  var computedColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n  var sampleColor: vec4<f32>;\n//VTK::Volume::TraverseCalls\n\n  loop\n  {\n    // for each volume, sample and accumulate color\n//VTK::Volume::CompositeCalls\n\n    // increment position\n    curDist = curDist + mapperUBO.SampleDistance;\n    rayPosSC = rayPosSC + rayStepSC;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayLengthSC) { break; }\n    if (computedColor.a > 0.98) { break; }\n  }\n  return computedColor;\n}\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var rayMax: f32 = textureSampleLevel(maxTexture, clampSampler, input.tcoordVS, 0.0).r;\n  var rayMin: f32 = textureSampleLevel(minTexture, clampSampler, input.tcoordVS, 0.0).r;\n\n  // discard empty rays\n  if (rayMax <= rayMin) { discard; }\n  else\n  {\n    // compute start and end ray positions in view coordinates\n    var minPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMax, 1.0);\n    minPosSC = minPosSC * (1.0 / minPosSC.w);\n    var maxPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMin, 1.0);\n    maxPosSC = maxPosSC * (1.0 / maxPosSC.w);\n\n    var rayLengthSC: f32 = distance(minPosSC.xyz, maxPosSC.xyz);\n    var rayStepSC: vec4<f32> = (maxPosSC - minPosSC)*(mapperUBO.SampleDistance/rayLengthSC);\n    rayStepSC.w = 0.0;\n\n    var computedColor: vec4<f32>;\n\n//VTK::Volume::Loop\n\n//VTK::RenderEncoder::Impl\n  }\n\n  return output;\n}\n",t.UBO=LT.newInstance({label:"mapperUBO"}),t.UBO.addEntry("SampleDistance","f32"),t.SSBO=kT.newInstance({label:"volumeSSBO"}),t.componentSSBO=kT.newInstance({label:"componentSSBO"}),t.lutBuildTime={},Ht.obj(t.lutBuildTime,{mtime:0}),function(e,t){t.classHierarchy.push("vtkWebGPUVolumePassFSQ"),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription("vertex");r.addBuiltinOutput("vec4<f32>","@builtin(position) Position");let o=r.getCode();o=dv.substitute(o,"//VTK::Position::Impl",["output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);","output.Position = vec4<f32>(vertexBC, 1.0);"]).result,r.setCode(o),t.getShaderDescription("fragment").addBuiltinInput("vec4<f32>","@builtin(position) fragPos")},t.shaderReplacements.set("replaceShaderPosition",e.replaceShaderPosition),e.replaceShaderVolume=(e,n,r)=>{const o=n.getShaderDescription("fragment");let a=o.getCode();const i=[],s=[];for(let e=0;e<t.volumes.length;e++)t.volumes[e].getRenderable().getMapper().getBlendMode()===wf.COMPOSITE_BLEND?(i.push(`    sampleColor = processVolume(volTexture${e}, ${e}, ${t.rowStarts[e]}, rayPosSC, tfunRows);`),i.push("    computedColor = vec4<f32>(\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);")):(s.push(`  sampleColor = traverseVals[${e}];`),s.push("  computedColor = vec4<f32>(\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);"));a=dv.substitute(a,"//VTK::Volume::CompositeCalls",i).result,a=dv.substitute(a,"//VTK::Volume::TraverseCalls",s).result,a=dv.substitute(a,"//VTK::Volume::TraverseDec",[`var<private> traverseVals: array<vec4<f32>,${t.volumes.length}>;`]).result;let l=!1;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getBlendMode();n===wf.COMPOSITE_BLEND?l=!0:n===wf.MAXIMUM_INTENSITY_BLEND?a=dv.substitute(a,"//VTK::Volume::Loop",[`    traverseMax(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,"//VTK::Volume::Loop"]).result:n===wf.MINIMUM_INTENSITY_BLEND?a=dv.substitute(a,"//VTK::Volume::Loop",[`    traverseMin(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,"//VTK::Volume::Loop"]).result:n===wf.AVERAGE_INTENSITY_BLEND?a=dv.substitute(a,"//VTK::Volume::Loop",[`    traverseAverage(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,"//VTK::Volume::Loop"]).result:n===wf.ADDITIVE_INTENSITY_BLEND&&(a=dv.substitute(a,"//VTK::Volume::Loop",[`    traverseAdditive(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,"//VTK::Volume::Loop"]).result)}l&&(a=dv.substitute(a,"//VTK::Volume::Loop",["    computedColor = composite(rayLengthSC, minPosSC, rayStepSC);"]).result),o.setCode(a)},t.shaderReplacements.set("replaceShaderVolume",e.replaceShaderVolume),e.updateLUTImage=n=>{let r=e.getMTime();for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),o=n.getMapper().getInputData();r=Math.max(r,n.getMTime(),o.getMTime())}if(r<t.lutBuildTime.getMTime())return;t.numRows=0,t.rowStarts=[];for(let e=0;e<t.volumes.length;e++){t.rowStarts.push(t.numRows);const n=t.volumes[e].getRenderable(),r=n.getMapper(),o=n.getProperty(),a=r.getInputData(),i=(a.getPointData()&&a.getPointData().getScalars()).getNumberOfComponents(),s=o.getIndependentComponents()?i:1;t.numRows+=s}const o=new Uint8ClampedArray(2*t.numRows*t.rowLength*4),a=new Float32Array(2*t.numRows*t.rowLength);let i=0;const s=new Float32Array(3*t.rowLength),l=t.rowLength;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),c=n.getProperty(),u=r.getInputData(),d=(u.getPointData()&&u.getPointData().getScalars()).getNumberOfComponents(),p=c.getIndependentComponents()?d:1;for(let e=0;e<p;++e){const n=c.getRGBTransferFunction(e),r=n.getRange();n.getTable(r[0],r[1],l,s,1);let u=i*l*4;for(let e=0;e<l;++e){o[u+4*e]=255*s[3*e],o[u+4*e+1]=255*s[3*e+1],o[u+4*e+2]=255*s[3*e+2],o[u+4*e+3]=255;for(let t=0;t<4;t++)o[u+4*(l+e)+t]=o[u+4*e+t]}const d=c.getScalarOpacity(e),p=t.sampleDist/c.getScalarOpacityUnitDistance(e),f=d.getRange();d.getTable(f[0],f[1],l,s,1),u=i*l;for(let e=0;e<l;++e)a[u+e]=1-(1-s[e])**p,a[u+e+l]=a[u+e];i+=2}}{const e={nativeArray:o,width:t.rowLength,height:2*t.numRows,depth:1,format:"rgba8unorm"},r=n.getTextureManager().getTexture(e).createView("tfunTexture");t.textureViews[2]=r}{const e={nativeArray:a,width:t.rowLength,height:2*t.numRows,depth:1,format:"r16float"},r=n.getTextureManager().getTexture(e).createView("ofunTexture");t.textureViews[3]=r}t.lutBuildTime.modified()},e.updateSSBO=n=>{let r=Math.max(e.getMTime(),t.WebGPURenderer.getStabilizedTime());for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),o=n.getMapper(),a=o.getInputData();r=Math.max(r,n.getMTime(),a.getMTime(),o.getMTime())}if(r<t.SSBO.getSendTime())return;const o=t.WebGPURenderer.getStabilizedCenterByReference();t.SSBO.clearData(),t.SSBO.setNumberOfInstances(t.volumes.length);const a=new Float64Array(16*t.volumes.length),i=new Float64Array(16*t.volumes.length),s=new Float64Array(4*t.volumes.length),l=new Float64Array(4*t.volumes.length),c=new Float64Array(4*t.volumes.length),u=new Float64Array(4*t.volumes.length);for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper().getInputData();g(GT),b(GT,GT,o);const d=n.getMatrix();m(UT,d),h(UT,UT),y(GT,UT,GT);const p=r.getWorldToIndex();y(GT,p,GT);const f=r.getDimensions();g(UT),x(UT,UT,[1/f[0],1/f[1],1/f[2]]),y(GT,UT,GT);for(let t=0;t<16;t++)a[16*e+t]=GT[t];h(GT,GT);for(let t=0;t<4;t++)i[16*e+4*t]=GT[4*t],i[16*e+4*t+1]=GT[4*t+1],i[16*e+4*t+2]=GT[4*t+2],i[16*e+4*t+3]=0;s[4*e]=1/f[0],s[4*e+1]=1/f[1],s[4*e+2]=1/f[2],s[4*e+3]=1,l[4*e]=n.getProperty().getShade()?1:0;const v=r.getSpacing();c[4*e]=v[0],c[4*e+1]=v[1],c[4*e+2]=v[2],c[4*e+3]=1;const T=t.textureViews[e+4].getTexture().getScale(),C=n.getProperty().getIpScalarRange();u[4*e]=C[0]/T,u[4*e+1]=C[1]/T,u[4*e+2]=n.getProperty().getFilterMode()}t.SSBO.addEntry("SCTCMatrix","mat4x4<f32>"),t.SSBO.addEntry("planeNormals","mat4x4<f32>"),t.SSBO.addEntry("shade","vec4<f32>"),t.SSBO.addEntry("tstep","vec4<f32>"),t.SSBO.addEntry("spacing","vec4<f32>"),t.SSBO.addEntry("ipScalarRange","vec4<f32>"),t.SSBO.setAllInstancesFromArray("SCTCMatrix",a),t.SSBO.setAllInstancesFromArray("planeNormals",i),t.SSBO.setAllInstancesFromArray("shade",l),t.SSBO.setAllInstancesFromArray("tstep",s),t.SSBO.setAllInstancesFromArray("spacing",c),t.SSBO.setAllInstancesFromArray("ipScalarRange",u),t.SSBO.send(n),t.componentSSBO.clearData(),t.componentSSBO.setNumberOfInstances(t.numRows);const d=new Float64Array(t.numRows),p=new Float64Array(t.numRows),f=new Float64Array(t.numRows),v=new Float64Array(t.numRows),T=new Float64Array(t.numRows),C=new Float64Array(t.numRows),S=new Float64Array(t.numRows),A=new Float64Array(t.numRows);let I=0;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),o=n.getProperty(),a=r.getInputData(),i=(a.getPointData()&&a.getPointData().getScalars()).getNumberOfComponents(),s=o.getIndependentComponents(),l=t.textureViews[e+4].getTexture().getFormat(),c=Cv(l),u={scale:[255],offset:[0]};2===c.elementSize&&"float"===c.sampleType&&(u.scale[0]=1);for(let e=0;e<i;e++){const t=s?e:0,n=u.scale[e],r=o.getScalarOpacity(t).getRange(),a=n/(r[1]-r[0]),i=(u.offset[e]-r[0])/(r[1]-r[0]);v[I]=i,f[I]=a;const l=o.getRGBTransferFunction(t).getRange();if(p[I]=(u.offset[e]-l[0])/(l[1]-l[0]),d[I]=n/(l[1]-l[0]),o.getUseGradientOpacity(t)){const e=o.getGradientOpacityMinimumOpacity(t),r=o.getGradientOpacityMaximumOpacity(t);T[I]=e,C[I]=r;const a=[o.getGradientOpacityMinimumValue(t),o.getGradientOpacityMaximumValue(t)];A[I]=n*(r-e)/(a[1]-a[0]),S[I]=-a[0]*(r-e)/(a[1]-a[0])+e}else T[I]=1,C[I]=1,A[I]=0,S[I]=1;I++}}t.componentSSBO.addEntry("cScale","f32"),t.componentSSBO.addEntry("cShift","f32"),t.componentSSBO.addEntry("oScale","f32"),t.componentSSBO.addEntry("oShift","f32"),t.componentSSBO.addEntry("goShift","f32"),t.componentSSBO.addEntry("goScale","f32"),t.componentSSBO.addEntry("gomin","f32"),t.componentSSBO.addEntry("gomax","f32"),t.componentSSBO.setAllInstancesFromArray("cScale",d),t.componentSSBO.setAllInstancesFromArray("cShift",p),t.componentSSBO.setAllInstancesFromArray("oScale",f),t.componentSSBO.setAllInstancesFromArray("oShift",v),t.componentSSBO.setAllInstancesFromArray("goScale",A),t.componentSSBO.setAllInstancesFromArray("goShift",S),t.componentSSBO.setAllInstancesFromArray("gomin",T),t.componentSSBO.setAllInstancesFromArray("gomax",C),t.componentSSBO.send(n)};const n=e.updateBuffers;e.updateBuffers=()=>{n();let r=t.volumes[0].getRenderable().getMapper().getSampleDistance();for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getSampleDistance();n<r&&(r=n)}t.sampleDist!==r&&(t.sampleDist=r,t.UBO.setValue("SampleDistance",r),t.UBO.sendIfNeeded(t.device));for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getInputData(),r=t.device.getTextureManager().getTextureForImageData(n);if(!t.textureViews[e+4]||t.textureViews[e+4].getTexture()!==r){const n=r.createView(`volTexture${e}`);t.textureViews[e+4]=n}}if(t.volumes.length<t.lastVolumeLength)for(let e=t.volumes.length;e<t.lastVolumeLength;e++)t.textureViews.pop();t.lastVolumeLength=t.volumes.length,e.updateLUTImage(t.device),e.updateSSBO(t.device),t.clampSampler||(t.clampSampler=Hv.newInstance({label:"clampSampler"}),t.clampSampler.create(t.device,{minFilter:"linear",magFilter:"linear"}))},e.computePipelineHash=()=>{t.pipelineHash="volfsq";for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getBlendMode();t.pipelineHash+=`${n}`}},e.setVolumes=n=>{if(!t.volumes||t.volumes.length!==n.length)return t.volumes=[...n],void e.modified();for(let r=0;r<n.length;r++)if(n[r]!==t.volumes[r])return t.volumes=[...n],void e.modified()};const r=e.getBindables;e.getBindables=()=>{const e=r();return e.push(t.componentSSBO),e.push(t.clampSampler),e}}(e,t)}var HT={newInstance:Ht.newInstance(WT,"vtkWebGPUVolumePassFSQ"),extend:WT};const{Representation:jT}=ts,{BufferUsage:KT,PrimitiveTypes:$T}=RT,qT=[[0,4,6],[0,6,2],[1,3,7],[1,7,5],[0,5,4],[0,1,5],[2,6,7],[2,7,3],[0,3,1],[0,2,3],[4,5,7],[4,7,6]],XT={colorTextureView:null,depthTextureView:null,volumes:null};function YT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,XT,n),wh.extend(e,t,n),t._mapper=Lv.newInstance(),t._mapper.setFragmentShaderTemplate("\n//VTK::Renderer::Dec\n\n//VTK::Select::Dec\n\n//VTK::VolumePass::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : fragmentOutput;\n\n  //VTK::Select::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::VolumePass::Impl\n\n  // use the maximum (closest) of the current value and the zbuffer\n  // the blend func will then take the min to find the farthest stop value\n  var stopval: f32 = max(input.fragPos.z, textureLoad(opaquePassDepthTexture, vec2<i32>(i32(input.fragPos.x), i32(input.fragPos.y)), 0));\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n"),t._mapper.getShaderReplacements().set("replaceShaderVolumePass",((e,t,n)=>{t.getShaderDescription("fragment").addBuiltinInput("vec4<f32>","@builtin(position) fragPos")})),t._boundsPoly=kc.newInstance(),t._lastMTimes=[],Ht.setGet(e,t,["colorTextureView","depthTextureView"]),function(e,t){t.classHierarchy.push("vtkWebGPUVolumePass"),e.initialize=n=>{t._clearEncoder||e.createClearEncoder(n),t._mergeEncoder||e.createMergeEncoder(n),t._copyEncoder||e.createCopyEncoder(n),t._depthRangeEncoder||e.createDepthRangeEncoder(n),t.fullScreenQuad||(t.fullScreenQuad=HT.newInstance(),t.fullScreenQuad.setDevice(n.getDevice()),t.fullScreenQuad.setTextureViews([...t._depthRangeEncoder.getColorTextureViews()])),t._volumeCopyQuad||(t._volumeCopyQuad=Fv.newInstance(),t._volumeCopyQuad.setPipelineHash("volpassfsq"),t._volumeCopyQuad.setDevice(n.getDevice()),t._volumeCopyQuad.setFragmentShaderTemplate("\n//VTK::Renderer::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var computedColor: vec4<f32> = textureSample(volumePassColorTexture,\n    volumePassColorTextureSampler, mapperUBO.tscale*input.tcoordVS);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n"),t._copyUBO=LT.newInstance({label:"mapperUBO"}),t._copyUBO.addEntry("tscale","vec2<f32>"),t._volumeCopyQuad.setUBO(t._copyUBO),t._volumeCopyQuad.setTextureViews([t._colorTextureView]))},e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r,e.initialize(r),e.computeTiming(r),e.renderDepthBounds(n,r),t._firstGroup=!0;const o=r.getDevice(),a=o.getHandle().limits.maxSampledTexturesPerShaderStage-4;if(t.volumes.length>a){const o=n.getRenderable().getActiveCamera().getPosition(),i=[];for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getBounds(),r=[.5*(n[1]+n[0]),.5*(n[3]+n[2]),.5*(n[5]+n[4])];i[e]=Uo(r,o)}const s=[...Array(t.volumes.length).keys()];s.sort(((e,t)=>i[t]-i[e]));let l=[],c=s.length%a;for(let o=0;o<s.length;o++)l.push(t.volumes[s[o]]),l.length>=c&&(e.rayCastPass(r,n,l),l=[],c=a,t._firstGroup=!1)}else e.rayCastPass(r,n,t.volumes);if(t._volumeCopyQuad.setWebGPURenderer(n),t._useSmallViewport){const e=t._colorTextureView.getTexture().getWidth(),n=t._colorTextureView.getTexture().getHeight();t._copyUBO.setArray("tscale",[t._smallViewportWidth/e,t._smallViewportHeight/n])}else t._copyUBO.setArray("tscale",[1,1]);t._copyUBO.sendIfNeeded(o),t._copyEncoder.setColorTextureView(0,t.colorTextureView),t._copyEncoder.attachTextureViews(),t._copyEncoder.begin(r.getCommandEncoder()),n.scissorAndViewport(t._copyEncoder),t._volumeCopyQuad.prepareAndDraw(t._copyEncoder),t._copyEncoder.end()},e.delete=Ht.chain((()=>{t._animationRateSubscription&&(t._animationRateSubscription.unsubscribe(),t._animationRateSubscription=null)}),e.delete),e.computeTiming=e=>{const n=e.getRenderable().getInteractor();if(null==t._lastScale){const e=t.volumes[0].getRenderable().getMapper();t._lastScale=e.getInitialInteractionScale()||1}t._useSmallViewport=!1,n.isAnimating()&&t._lastScale>1.5&&(t._useSmallViewport=!0),t._colorTexture.resize(e.getCanvas().width,e.getCanvas().height),t._animationRateSubscription||(t._animationRateSubscription=n.onAnimationFrameRateUpdate((()=>{const e=t.volumes[0].getRenderable().getMapper();if(e.getAutoAdjustSampleDistances()){const e=n.getRecentAnimationFrameRate(),r=t._lastScale*n.getDesiredUpdateRate()/e;t._lastScale=r,t._lastScale>400&&(t._lastScale=400)}else t._lastScale=e.getImageSampleDistance()*e.getImageSampleDistance();t._lastScale<1.5&&(t._lastScale=1.5)})))},e.rayCastPass=(e,n,r)=>{const o=t._firstGroup?t._clearEncoder:t._mergeEncoder;o.attachTextureViews(),o.begin(e.getCommandEncoder());let a=t._colorTextureView.getTexture().getWidth(),i=t._colorTextureView.getTexture().getHeight();if(t._useSmallViewport){const n=e.getCanvas(),r=1/Math.sqrt(t._lastScale);t._smallViewportWidth=Math.ceil(r*n.width),t._smallViewportHeight=Math.ceil(r*n.height),a=t._smallViewportWidth,i=t._smallViewportHeight}o.getHandle().setViewport(0,0,a,i,0,1),o.getHandle().setScissorRect(0,0,a,i),t.fullScreenQuad.setWebGPURenderer(n),t.fullScreenQuad.setVolumes(r),t.fullScreenQuad.prepareAndDraw(o),o.end()},e.renderDepthBounds=(n,r)=>{e.updateDepthPolyData(n);const o=t._boundsPoly,a=o.getPoints(),i=o.getPolys();let s={hash:`vp${i.getMTime()}`,usage:KT.Index,cells:i,numberOfPoints:a.getNumberOfPoints(),primitiveType:$T.Triangles,representation:jT.SURFACE};const l=r.getDevice().getBufferManager().getBuffer(s);t._mapper.getVertexInput().setIndexBuffer(l),s={usage:KT.PointArray,format:"float32x4",hash:`vp${a.getMTime()}${i.getMTime()}`,dataArray:a,indexBuffer:l,packExtra:!0};const c=r.getDevice().getBufferManager().getBuffer(s);t._mapper.getVertexInput().addBuffer(c,["vertexBC"]),t._mapper.setNumberOfVertices(c.getSizeInBytes()/c.getStrideInBytes()),e.drawDepthRange(n,r)},e.updateDepthPolyData=e=>{let n=!1;for(let e=0;e<t.volumes.length;e++){const r=t.volumes[e].getMTime();t._lastMTimes[e]&&r===t._lastMTimes[e]||(n=!0,t._lastMTimes[e]=r)}const r=e.getStabilizedTime();if((t._lastMTimes.length<=t.volumes.length||r!==t._lastMTimes[t.volumes.length])&&(n=!0,t._lastMTimes[t.volumes.length]=r),!n)return;const o=e.getStabilizedCenterByReference(),a=8*t.volumes.length,i=new Float64Array(3*a),s=12*t.volumes.length,l=new Uint16Array(4*s);for(let e=0;e<t.volumes.length;e++){t.volumes[e].getBoundingCubePoints(i,24*e);let n=12*e*4;const r=8*e;for(let e=0;e<12;e++)l[n++]=3,l[n++]=r+qT[e][0],l[n++]=r+qT[e][1],l[n++]=r+qT[e][2]}for(let e=0;e<i.length;e+=3)i[e]-=o[0],i[e+1]-=o[1],i[e+2]-=o[2];t._boundsPoly.getPoints().setData(i,3),t._boundsPoly.getPoints().modified(),t._boundsPoly.getPolys().setData(l,1),t._boundsPoly.getPolys().modified(),t._boundsPoly.modified()},e.drawDepthRange=(n,r)=>{t._depthRangeTexture.resizeToMatch(t.colorTextureView.getTexture()),t._depthRangeTexture2.resizeToMatch(t.colorTextureView.getTexture()),t._depthRangeEncoder.attachTextureViews(),e.setCurrentOperation("volumeDepthRangePass"),n.setRenderEncoder(t._depthRangeEncoder),n.volumeDepthRangePass(!0),t._mapper.setWebGPURenderer(n),t._mapper.prepareToDraw(t._depthRangeEncoder),t._mapper.registerDrawCallback(t._depthRangeEncoder),n.volumeDepthRangePass(!1)},e.createDepthRangeEncoder=e=>{const n=e.getDevice();t._depthRangeEncoder=Uv.newInstance({label:"VolumePass DepthRange"}),t._depthRangeEncoder.setPipelineHash("volr"),t._depthRangeEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor1"),t.addOutput("vec4<f32>","outColor2");let n=t.getCode();n=dv.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor1 = vec4<f32>(input.fragPos.z, 0.0, 0.0, 0.0);","output.outColor2 = vec4<f32>(stopval, 0.0, 0.0, 0.0);"]).result,t.setCode(n)})),t._depthRangeEncoder.setDescription({colorAttachments:[{view:null,clearValue:[0,0,0,0],loadOp:"clear",storeOp:"store"},{view:null,clearValue:[1,1,1,1],loadOp:"clear",storeOp:"store"}]}),t._depthRangeEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"r16float",blend:{color:{srcFactor:"one",dstFactor:"one",operation:"max"},alpha:{srcFactor:"one",dstFactor:"one",operation:"max"}}},{format:"r16float",blend:{color:{srcFactor:"one",dstFactor:"one",operation:"min"},alpha:{srcFactor:"one",dstFactor:"one",operation:"min"}}}]}}),t._depthRangeTexture=Yv.newInstance({label:"volumePassMaxDepth"}),t._depthRangeTexture.create(n,{width:e.getCanvas().width,height:e.getCanvas().height,format:"r16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const r=t._depthRangeTexture.createView("maxTexture");t._depthRangeEncoder.setColorTextureView(0,r),t._depthRangeTexture2=Yv.newInstance({label:"volumePassDepthMin"}),t._depthRangeTexture2.create(n,{width:e.getCanvas().width,height:e.getCanvas().height,format:"r16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const o=t._depthRangeTexture2.createView("minTexture");t._depthRangeEncoder.setColorTextureView(1,o),t._mapper.setDevice(e.getDevice()),t._mapper.setTextureViews([t.depthTextureView])},e.createClearEncoder=e=>{t._colorTexture=Yv.newInstance({label:"volumePassColor"}),t._colorTexture.create(e.getDevice(),{width:e.getCanvas().width,height:e.getCanvas().height,format:"bgra8unorm",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC}),t._colorTextureView=t._colorTexture.createView("volumePassColorTexture"),t._colorTextureView.addSampler(e.getDevice(),{minFilter:"linear",magFilter:"linear"}),t._clearEncoder=Uv.newInstance({label:"VolumePass Clear"}),t._clearEncoder.setColorTextureView(0,t._colorTextureView),t._clearEncoder.setDescription({colorAttachments:[{view:null,clearValue:[0,0,0,0],loadOp:"clear",storeOp:"store"}]}),t._clearEncoder.setPipelineHash("volpf"),t._clearEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"bgra8unorm",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})},e.createCopyEncoder=e=>{t._copyEncoder=Uv.newInstance({label:"volumePassCopy"}),t._copyEncoder.setDescription({colorAttachments:[{view:null,loadOp:"load",storeOp:"store"}]}),t._copyEncoder.setPipelineHash("volcopypf"),t._copyEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"rgba16float",blend:{color:{srcFactor:"one",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})},e.createMergeEncoder=e=>{t._mergeEncoder=Uv.newInstance({label:"volumePassMerge"}),t._mergeEncoder.setColorTextureView(0,t._colorTextureView),t._mergeEncoder.setDescription({colorAttachments:[{view:null,loadOp:"load",storeOp:"store"}]}),t._mergeEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor");let n=t.getCode();n=dv.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor = vec4<f32>(computedColor.rgb, computedColor.a);"]).result,t.setCode(n)})),t._mergeEncoder.setPipelineHash("volpf"),t._mergeEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"bgra8unorm",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})},e.setVolumes=n=>{if(!t.volumes||t.volumes.length!==n.length)return t.volumes=[...n],void e.modified();for(let r=0;r<n.length;r++)if(n[r]!==t.volumes[r])return t.volumes=[...n],void e.modified()}}(e,t)}var ZT={newInstance:Ht.newInstance(YT,"vtkWebGPUVolumePass"),extend:YT};const QT={opaqueActorCount:0,translucentActorCount:0,volumes:null,opaqueRenderEncoder:null,translucentPass:null,volumePass:null};function JT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,QT,n),wh.extend(e,t,n),Ht.setGet(e,t,["opaquePass","translucentPass","volumePass"]),function(e,t){t.classHierarchy.push("vtkForwardPass"),e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(t.deleted)return;t._currentParent=r,e.setCurrentOperation("buildPass"),n.traverse(e),t.opaquePass||(t.opaquePass=Jv.newInstance());const o=n.getRenderable().getNumberOfLayers(),a=n.getChildren();for(let r=0;r<o;r++)for(let o=0;o<a.length;o++){const i=a[o],s=n.getRenderable().getRenderers()[o];s.getDraw()&&s.getLayer()===r&&(t.opaqueActorCount=0,t.translucentActorCount=0,t.volumes=[],e.setCurrentOperation("queryPass"),i.traverse(e),e.setCurrentOperation("cameraPass"),i.traverse(e),t.opaquePass.traverse(i,n),t.translucentActorCount>0&&(t.translucentPass||(t.translucentPass=nT.newInstance()),t.translucentPass.setColorTextureView(t.opaquePass.getColorTextureView()),t.translucentPass.setDepthTextureView(t.opaquePass.getDepthTextureView()),t.translucentPass.traverse(i,n)),t.volumes.length>0&&(t.volumePass||(t.volumePass=ZT.newInstance()),t.volumePass.setColorTextureView(t.opaquePass.getColorTextureView()),t.volumePass.setDepthTextureView(t.opaquePass.getDepthTextureView()),t.volumePass.setVolumes(t.volumes),t.volumePass.traverse(i,n)),e.finalPass(n,i))}},e.finalPass=(n,r)=>{t._finalBlitEncoder||e.createFinalBlitEncoder(n),t._finalBlitOutputTextureView.createFromTextureHandle(n.getCurrentTexture(),{depth:1,format:n.getPresentationFormat()}),t._finalBlitEncoder.attachTextureViews(),t._finalBlitEncoder.begin(n.getCommandEncoder()),r.scissorAndViewport(t._finalBlitEncoder),t._fullScreenQuad.prepareAndDraw(t._finalBlitEncoder),t._finalBlitEncoder.end()},e.createFinalBlitEncoder=e=>{t._finalBlitEncoder=Uv.newInstance({label:"forwardPassBlit"}),t._finalBlitEncoder.setDescription({colorAttachments:[{view:null,loadOp:"load",storeOp:"store"}]}),t._finalBlitEncoder.setPipelineHash("fpf"),t._finalBlitEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:e.getPresentationFormat(),blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]}}),t._fsqSampler=Hv.newInstance({label:"finalPassSampler"}),t._fsqSampler.create(e.getDevice(),{minFilter:"linear",magFilter:"linear"}),t._fullScreenQuad=Fv.newInstance(),t._fullScreenQuad.setDevice(e.getDevice()),t._fullScreenQuad.setPipelineHash("fpfsq"),t._fullScreenQuad.setTextureViews([t.opaquePass.getColorTextureView()]),t._fullScreenQuad.setAdditionalBindables([t._fsqSampler]),t._fullScreenQuad.setFragmentShaderTemplate("\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var computedColor: vec4<f32> = clamp(textureSampleLevel(opaquePassColorTexture, finalPassSampler, input.tcoordVS, 0.0),vec4<f32>(0.0),vec4<f32>(1.0));\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n"),t._finalBlitOutputTextureView=$v.newInstance(),t._finalBlitEncoder.setColorTextureView(0,t._finalBlitOutputTextureView)},e.incrementOpaqueActorCount=()=>t.opaqueActorCount++,e.incrementTranslucentActorCount=()=>t.translucentActorCount++,e.addVolume=e=>{t.volumes.push(e)}}(e,t)}var ey={newInstance:Ht.newInstance(JT,"vtkForwardPass"),extend:JT};const{VtkDataTypes:ty}=Ts,ny={handle:null,device:null};function ry(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ny,n),Ht.obj(e,t),Ht.setGet(e,t,["device"]),function(e,t){function n(e){if(e.imageData){e.dataArray=e.imageData.getPointData().getScalars(),e.time=e.dataArray.getMTime(),e.nativeArray=e.dataArray.getData();const t=e.imageData.getDimensions();switch(e.width=t[0],e.height=t[1],e.depth=t[2],e.dataArray.getNumberOfComponents()){case 1:e.format="r";break;case 2:e.format="rg";break;default:e.format="rgba"}switch(e.dataArray.getDataType()){case ty.UNSIGNED_CHAR:e.format+="8unorm";break;case ty.FLOAT:case ty.UNSIGNED_INT:case ty.INT:case ty.DOUBLE:case ty.UNSIGNED_SHORT:case ty.SHORT:default:e.format+="16float"}}e.image&&(e.width=e.image.width,e.height=e.image.height,e.depth=1,e.format="rgba8unorm",e.flip=!0,e.usage=GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT),e.jsImageData&&(e.width=e.jsImageData.width,e.height=e.jsImageData.height,e.depth=1,e.format="rgba8unorm",e.flip=!0,e.nativeArray=e.jsImageData.data,e.usage=GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT),e.imageBitmap&&(e.width=e.imageBitmap.width,e.height=e.imageBitmap.height,e.depth=1,e.format="rgba8unorm",e.flip=!0,e.usage=GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT),e.canvas&&(e.width=e.canvas.width,e.height=e.canvas.height,e.depth=1,e.format="rgba8unorm",e.flip=!0,e.usage=GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT)}function r(e){const n=Yv.newInstance({label:e.label});return n.create(t.device,{width:e.width,height:e.height,depth:e.depth,format:e.format,usage:e.usage,mipLevel:e.mipLevel}),(e.nativeArray||e.image||e.canvas||e.imageBitmap)&&n.writeImageData(e),n}t.classHierarchy.push("vtkWebGPUTextureManager"),e.getTexture=e=>e.hash?t.device.getCachedObject(e.hash,r,e):r(e),e.getTextureForImageData=e=>{const r={time:e.getMTime()};return r.imageData=e,n(r),r.hash=r.time+r.format+r.mipLevel,t.device.getTextureManager().getTexture(r)},e.getTextureForVTKTexture=function(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0;const o={time:e.getMTime(),label:r};return e.getInputData()?o.imageData=e.getInputData():e.getImage()?o.image=e.getImage():e.getJsImageData()?o.jsImageData=e.getJsImageData():e.getImageBitmap()?o.imageBitmap=e.getImageBitmap():e.getCanvas()&&(o.canvas=e.getCanvas()),n(o),o.mipLevel=e.getMipLevel(),o.hash=o.time+o.format+o.mipLevel,t.device.getTextureManager().getTexture(o)}}(e,t)}var oy={newInstance:Ht.newInstance(ry),extend:ry};class ay extends Map{constructor(){super(),this.registry=new FinalizationRegistry((e=>{const t=super.get(e);t&&t.deref&&void 0===t.deref()&&super.delete(e)}))}getValue(e){const t=super.get(e);if(t){const n=t.deref();if(void 0!==n)return n;super.delete(e)}}setValue(e,t){let n;return t&&"object"==typeof t&&(n=new WeakRef(t),this.registry.register(t,e),super.set(e,n)),n}}const iy={handle:null,pipelines:null,shaderCache:null,bindGroupLayouts:null,bufferManager:null,textureManager:null};function sy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,iy,n),vt(e,t),St(e,t,["handle"]),yt(e,t,["bufferManager","shaderCache","textureManager"]),t.objectCache=new ay,t.shaderCache=dv.newInstance(),t.shaderCache.setDevice(e),t.bindGroupLayouts=[],t.bufferManager=RT.newInstance(),t.bufferManager.setDevice(e),t.textureManager=oy.newInstance(),t.textureManager.setDevice(e),t.pipelines={},function(e,t){t.classHierarchy.push("vtkWebGPUDevice"),e.initialize=e=>{t.handle=e},e.createCommandEncoder=()=>t.handle.createCommandEncoder(),e.submitCommandEncoder=e=>{t.handle.queue.submit([e.finish()])},e.getShaderModule=e=>t.shaderCache.getShaderModule(e),e.getBindGroupLayout=e=>{if(!e.entries)return null;for(let t=0;t<e.entries.length;t++){const n=e.entries[t];n.binding=n.binding||0,n.visibility=n.visibility||GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT}const n=JSON.stringify(e);for(let e=0;e<t.bindGroupLayouts.length;e++)if(t.bindGroupLayouts[e].sval===n)return t.bindGroupLayouts[e].layout;const r=t.handle.createBindGroupLayout(e);return t.bindGroupLayouts.push({sval:n,layout:r}),r},e.getBindGroupLayoutDescription=e=>{for(let n=0;n<t.bindGroupLayouts.length;n++)if(t.bindGroupLayouts[n].layout===e)return t.bindGroupLayouts[n].sval;return vtkErrorMacro("layout not found"),console.trace(),null},e.getPipeline=e=>e in t.pipelines?t.pipelines[e]:null,e.createPipeline=(n,r)=>{r.initialize(e,n),t.pipelines[n]=r},e.onSubmittedWorkDone=()=>t.handle.queue.onSubmittedWorkDone(),e.hasCachedObject=e=>t.objectCache.getValue(e),e.getCachedObject=function(e,n){if(!e)return vtkErrorMacro("attempt to cache an object without a hash"),null;const r=t.objectCache.getValue(e);if(r)return r;for(var o=arguments.length,a=new Array(o>2?o-2:0),i=2;i<o;i++)a[i-2]=arguments[i];const s=n(...a);return t.objectCache.setValue(e,s),s}}(e,t)}var ly={newInstance:Et(sy,"vtkWebGPUDevice"),extend:sy};const cy={selectionRenderEncoder:null,colorTexture:null,depthTexture:null};function uy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,cy,n),wh.extend(e,t,n),Ht.get(e,t,["colorTexture","depthTexture"]),function(e,t){t.classHierarchy.push("vtkWebGPUHardwareSelectionPass"),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=null,e.setCurrentOperation("buildPass"),n.traverse(e);const o=n.getDevice();if(t.selectionRenderEncoder)t.colorTexture.resize(n.getCanvas().width,n.getCanvas().height),t.depthTexture.resizeToMatch(t.colorTexture);else{e.createRenderEncoder(),t.colorTexture=Yv.newInstance({label:"hardwareSelectorColor"}),t.colorTexture.create(o,{width:n.getCanvas().width,height:n.getCanvas().height,format:"rgba32uint",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC});const r=t.colorTexture.createView("hardwareSelectColorTexture");t.selectionRenderEncoder.setColorTextureView(0,r),t.depthTexture=Yv.newInstance({label:"hardwareSelectorDepth"}),t.depthTexture.create(o,{width:n.getCanvas().width,height:n.getCanvas().height,format:"depth32float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC});const a=t.depthTexture.createView("hardwareSelectDepthTexture");t.selectionRenderEncoder.setDepthTextureView(a)}t.selectionRenderEncoder.attachTextureViews(),r.setRenderEncoder(t.selectionRenderEncoder),e.setCurrentOperation("cameraPass"),r.traverse(e),e.setCurrentOperation("opaquePass"),r.traverse(e)},e.createRenderEncoder=()=>{t.selectionRenderEncoder=Uv.newInstance({label:"HardwareSelectionPass"}),t.selectionRenderEncoder.setPipelineHash("sel"),t.selectionRenderEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<u32>","outColor");let n=t.getCode();n=dv.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor = vec4<u32>(mapperUBO.PropID, compositeID, 0u, 0u);"]).result,t.setCode(n)})),t.selectionRenderEncoder.getDescription().colorAttachments[0].clearValue=[0,0,0,0],t.selectionRenderEncoder.setPipelineSettings({primitive:{cullMode:"none"},depthStencil:{depthWriteEnabled:!0,depthCompare:"greater",format:"depth32float"},fragment:{targets:[{format:"rgba32uint",blend:void 0}]}})}}(e,t)}var dy={newInstance:Ht.newInstance(uy,"vtkWebGPUHardwareSelectionPass"),extend:uy};const{SelectionContent:py,SelectionField:fy}=ep,{FieldAssociations:gy}=_s,{vtkErrorMacro:my}=Ht;function hy(e){return`${e.propID} ${e.compositeID}`}function vy(e,t,n,r){const o=4*((n.height-t-1)*n.colorBufferWidth+e)+r;return n.colorValues[o]}function Ty(e,t,n,r){const o=n<0?0:n;if(0===o){if(r[0]=t[0],r[1]=t[1],t[0]<0||t[0]>=e.width||t[1]<0||t[1]>=e.height)return null;const n=vy(t[0],t[1],e,0);if(n<=0)return null;const o={};o.propID=n;let a=vy(t[0],t[1],e,1);if((a<0||a>16777215)&&(a=0),o.compositeID=a,e.captureZValues){const n=(e.height-t[1]-1)*e.zbufferBufferWidth+t[0];o.zValue=e.depthValues[n],o.zValue=e.webGPURenderer.convertToOpenGLDepth(o.zValue),o.displayPosition=t}return o}const a=[t[0],t[1]],i=[0,0];let s=Ty(e,t,0,r);if(s)return s;for(let t=1;t<o;++t){for(let n=a[1]>t?a[1]-t:0;n<=a[1]+t;++n){if(i[1]=n,a[0]>=t&&(i[0]=a[0]-t,s=Ty(e,i,0,r),s))return s;if(i[0]=a[0]+t,s=Ty(e,i,0,r),s)return s}for(let n=a[0]>=t?a[0]-(t-1):0;n<=a[0]+(t-1);++n){if(i[0]=n,a[1]>=t&&(i[1]=a[1]-t,s=Ty(e,i,0,r),s))return s;if(i[1]=a[1]+t,s=Ty(e,i,0,r),s)return s}}return r[0]=t[0],r[1]=t[1],null}const yy={};function by(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,yy,n),qd.extend(e,t,n),t._selectionPass=dy.newInstance(),Ht.setGet(e,t,["_WebGPURenderWindow"]),Ht.moveToProtected(e,t,["WebGPURenderWindow"]),function(e,t){t.classHierarchy.push("vtkWebGPUHardwareSelector"),e.endSelection=()=>{t.WebGPURenderer.setSelector(null)},e.getSourceDataAsync=async e=>{if(!e||!t._WebGPURenderWindow)return my("Renderer and view must be set before calling Select."),!1;t._WebGPURenderWindow.getRenderable().preRender(),t._WebGPURenderWindow.getInitialized()||(t._WebGPURenderWindow.initialize(),await new Promise((e=>{t._WebGPURenderWindow.onInitialized(e)})));const n=t._WebGPURenderWindow.getViewNodeFor(e);if(!n)return!1;const r=n.getSuppressClear();n.setSuppressClear(!0),t._selectionPass.traverse(t._WebGPURenderWindow,n),n.setSuppressClear(r);const o=t._WebGPURenderWindow.getDevice(),a=t._selectionPass.getColorTexture(),i=t._selectionPass.getDepthTexture(),s={area:[0,0,a.getWidth()-1,a.getHeight()-1],captureZValues:t.captureZValues,fieldAssociation:t.fieldAssociation,renderer:e,webGPURenderer:n,webGPURenderWindow:t._WebGPURenderWindow,width:a.getWidth(),height:a.getHeight()};s.colorBufferWidth=16*Math.floor((s.width+15)/16),s.colorBufferSizeInBytes=s.colorBufferWidth*s.height*4*4;const l=sT.newInstance({label:"hardwareSelectColorBuffer"});l.setDevice(o),l.create(s.colorBufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);const c=t._WebGPURenderWindow.getCommandEncoder();let u;c.copyTextureToBuffer({texture:a.getHandle()},{buffer:l.getHandle(),bytesPerRow:16*s.colorBufferWidth,rowsPerImage:s.height},{width:s.width,height:s.height,depthOrArrayLayers:1}),t.captureZValues&&(s.zbufferBufferWidth=64*Math.floor((s.width+63)/64),u=sT.newInstance({label:"hardwareSelectDepthBuffer"}),u.setDevice(o),s.zbufferSizeInBytes=s.height*s.zbufferBufferWidth*4,u.create(s.zbufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST),c.copyTextureToBuffer({texture:i.getHandle(),aspect:"depth-only"},{buffer:u.getHandle(),bytesPerRow:4*s.zbufferBufferWidth,rowsPerImage:s.height},{width:s.width,height:s.height,depthOrArrayLayers:1})),o.submitCommandEncoder(c);const d=l.mapAsync(GPUMapMode.READ);if(t.captureZValues){const e=u.mapAsync(GPUMapMode.READ);await Promise.all([d,e]),s.depthValues=new Float32Array(u.getMappedRange().slice()),u.unmap()}else await d;return s.colorValues=new Uint32Array(l.getMappedRange().slice()),l.unmap(),s.generateSelection=(e,t,n,r)=>function(e,t,n,r,o){const a=Math.floor(t),i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=new Map,u=[0,0];for(let t=i;t<=l;t++)for(let n=a;n<=s;n++){const r=Ty(e,[n,t],0,u);if(r){const t=hy(r);if(c.has(t)){const n=c.get(t);n.pixelCount++,e.captureZValues&&r.zValue<n.info.zValue&&(n.info=r),-1===n.attributeIDs.indexOf(r.attributeID)&&n.attributeIDs.push(r.attributeID)}else c.set(t,{info:r,pixelCount:1,attributeIDs:[r.attributeID]})}}return function(e,t,n){const r=[];let o=0;return t.forEach(((t,a)=>{const i=ep.newInstance();switch(i.setContentType(py.INDICES),e){case gy.FIELD_ASSOCIATION_CELLS:i.setFieldType(fy.CELL);break;case gy.FIELD_ASSOCIATION_POINTS:i.setFieldType(fy.POINT);break;default:my("Unknown field association")}i.getProperties().propID=t.info.propID;const s=n.webGPURenderer.getPropFromID(t.info.propID);i.getProperties().prop=s.getRenderable(),i.getProperties().compositeID=t.info.compositeID,i.getProperties().pixelCount=t.pixelCount,n.captureZValues&&(i.getProperties().displayPosition=[t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue],i.getProperties().worldPosition=n.webGPURenderWindow.displayToWorld(t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue,n.renderer)),i.setSelectionList(t.attributeIDs),r[o]=i,o++})),r}(e.fieldAssociation,c,e)}(s,e,t,n,r),s}}(e,t)}var xy={newInstance:Ht.newInstance(by,"vtkWebGPUHardwareSelector"),extend:by};const Cy=Object.create(null),Sy={};function Ay(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Sy,n),t.overrides=Cy,Qt.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkWebGPUViewNodeFactory")}(0,t)}var Iy={newInstance:Ht.newInstance(Ay,"vtkWebGPUViewNodeFactory"),extend:Ay};const{vtkErrorMacro:wy}=Ht,Oy={position:"absolute",top:0,left:0,width:"100%",height:"100%"};const Py={initialized:!1,context:null,adapter:null,device:null,canvas:null,cursorVisibility:!0,cursor:"pointer",containerSize:null,renderPasses:[],notifyStartCaptureImage:!1,imageFormat:"image/png",useOffScreen:!1,useBackgroundImage:!1,nextPropID:1,xrSupported:!1,presentationFormat:null};const Ry=Ht.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Py,n),t.canvas=document.createElement("canvas"),t.canvas.style.width="100%",t.bgImage=new Image,t.bgImage.style.position="absolute",t.bgImage.style.left="0",t.bgImage.style.top="0",t.bgImage.style.width="100%",t.bgImage.style.height="100%",t.bgImage.style.zIndex="-1",qh.extend(e,t,n),t.myFactory=Iy.newInstance(),t.renderPasses[0]=ey.newInstance(),t.selector||(t.selector=xy.newInstance(),t.selector.setWebGPURenderWindow(e)),Ht.event(e,t,"imageReady"),Ht.event(e,t,"initialized"),Ht.get(e,t,["commandEncoder","device","presentationFormat","useBackgroundImage","xrSupported"]),Ht.setGet(e,t,["initialized","context","canvas","device","renderPasses","notifyStartCaptureImage","cursor","useOffScreen"]),Ht.setGetArray(e,t,["size"],2),Ht.event(e,t,"windowResizeEvent"),function(e,t){t.classHierarchy.push("vtkWebGPURenderWindow"),e.getViewNodeFactory=()=>t.myFactory;const n=[0,0];e.onModified((function(){t.renderable&&(t.size[0]===n[0]&&t.size[1]===n[1]||(n[0]=t.size[0],n[1]=t.size[1],t.canvas.setAttribute("width",t.size[0]),t.canvas.setAttribute("height",t.size[1]),e.recreateSwapChain())),t.viewStream&&t.viewStream.setSize(t.size[0],t.size[1]),t.canvas.style.display=t.useOffScreen?"none":"block",t.el&&(t.el.style.cursor=t.cursorVisibility?t.cursor:"none"),t.containerSize=null})),e.recreateSwapChain=()=>{t.context&&(t.context.unconfigure(),t.presentationFormat=navigator.gpu.getPreferredCanvasFormat(t.adapter),t.context.configure({device:t.device.getHandle(),format:t.presentationFormat,alphaMode:"premultiplied",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_DST,width:t.size[0],height:t.size[1]}),t._configured=!0)},e.getCurrentTexture=()=>t.context.getCurrentTexture(),e.buildPass=n=>{if(n){if(!t.renderable)return;e.prepareNodes(),e.addMissingNodes(t.renderable.getRenderersByReference()),e.removeUnusedNodes(),e.initialize()}else t.initialized&&(t._configured||e.recreateSwapChain(),t.commandEncoder=t.device.createCommandEncoder())},e.initialize=()=>{if(!t.initializing){if(t.initializing=!0,!navigator.gpu)return void wy("WebGPU is not enabled.");e.create3DContextAsync().then((()=>{t.initialized=!0,t.deleted||e.invokeInitialized()}))}},e.setContainer=n=>{t.el&&t.el!==n&&(t.canvas.parentNode!==t.el&&wy("Error: canvas parent node does not match container"),t.el.removeChild(t.canvas),t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)),t.el!==n&&(t.el=n,t.el&&(t.el.appendChild(t.canvas),t.useBackgroundImage&&t.el.appendChild(t.bgImage)),e.modified())},e.getContainer=()=>t.el,e.getContainerSize=()=>{if(!t.containerSize&&t.el){const{width:e,height:n}=t.el.getBoundingClientRect();t.containerSize=[e,n]}return t.containerSize||t.size},e.getFramebufferSize=()=>t.size,e.create3DContextAsync=async()=>{t.adapter=await navigator.gpu.requestAdapter({powerPreference:"high-performance"}),t.deleted||(t.device=ly.newInstance(),t.device.initialize(await t.adapter.requestDevice()),t.deleted?t.device=null:t.context=t.canvas.getContext("webgpu"))},e.releaseGraphicsResources=()=>{const n=wh.newInstance();n.setCurrentOperation("Release"),n.traverse(e,null),t.adapter=null,t.device=null,t.context=null,t.initialized=!1,t.initializing=!1},e.setBackgroundImage=e=>{t.bgImage.src=e.src},e.setUseBackgroundImage=e=>{t.useBackgroundImage=e,t.useBackgroundImage&&!t.el.contains(t.bgImage)?t.el.appendChild(t.bgImage):!t.useBackgroundImage&&t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)},e.captureNextImage=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"image/png",{resetCamera:r=!1,size:o=null,scale:a=1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(t.deleted)return null;t.imageFormat=n;const i=t.notifyStartCaptureImage;return t.notifyStartCaptureImage=!0,t._screenshot={size:o||1!==a?o||t.size.map((e=>e*a)):null},new Promise(((n,o)=>{const a=e.onImageReady((o=>{if(null===t._screenshot.size)t.notifyStartCaptureImage=i,a.unsubscribe(),t._screenshot.placeHolder&&(t.size=t._screenshot.originalSize,e.modified(),t._screenshot.cameras&&t._screenshot.cameras.forEach((e=>{let{restoreParamsFn:t,arg:n}=e;return t(n)})),e.traverseAllPasses(),t.el.removeChild(t._screenshot.placeHolder),t._screenshot.placeHolder.remove(),t._screenshot=null),n(o);else{const n=document.createElement("img");if(n.style=Oy,n.src=o,t._screenshot.placeHolder=t.el.appendChild(n),t.canvas.style.display="none",t._screenshot.originalSize=t.size,t.size=t._screenshot.size,t._screenshot.size=null,e.modified(),r){const e=!0!==r;t._screenshot.cameras=t.renderable.getRenderers().map((t=>{const n=t.getActiveCamera(),o=n.get("focalPoint","position","parallelScale");return{resetCameraArgs:e?{renderer:t}:void 0,resetCameraFn:e?r:t.resetCamera,restoreParamsFn:n.set,arg:JSON.parse(JSON.stringify(o))}})),t._screenshot.cameras.forEach((e=>{let{resetCameraFn:t,resetCameraArgs:n}=e;return t(n)}))}e.traverseAllPasses()}}))}))},e.traverseAllPasses=()=>{if(!t.deleted)if(t.initialized){if(t.renderPasses)for(let n=0;n<t.renderPasses.length;++n)t.renderPasses[n].traverse(e,null);t.commandEncoder&&(t.device.submitCommandEncoder(t.commandEncoder),t.commandEncoder=null,t.notifyStartCaptureImage&&t.device.onSubmittedWorkDone().then((()=>{!async function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.imageFormat;const r=document.createElement("canvas"),o=r.getContext("2d");r.width=t.canvas.width,r.height=t.canvas.height;const a=await e.getPixelsAsync(),i=new ImageData(a.colorValues,a.width,a.height);o.putImageData(i,0,0);const s=t.canvas.getBoundingClientRect();t.renderable.getRenderers().forEach((e=>{e.getViewProps().forEach((e=>{if(e.getContainer){const t=e.getContainer().getElementsByTagName("canvas");for(let e=0;e<t.length;e++){const n=t[e],r=n.getBoundingClientRect(),a=r.x-s.x,i=r.y-s.y;o.drawImage(n,a,i)}}}))}));const l=r.toDataURL(n);r.remove(),e.invokeImageReady(l)}()})))}else{e.initialize();const t=e.onInitialized((()=>{t.unsubscribe(),e.traverseAllPasses()}))}},e.setViewStream=n=>t.viewStream!==n&&(t.subscription&&(t.subscription.unsubscribe(),t.subscription=null),t.viewStream=n,t.viewStream&&(t.renderable.getRenderers()[0].getBackgroundByReference()[3]=0,e.setUseBackgroundImage(!0),t.subscription=t.viewStream.onImageReady((t=>e.setBackgroundImage(t.image))),t.viewStream.setSize(t.size[0],t.size[1]),t.viewStream.invalidateCache(),t.viewStream.render(),e.modified()),!0),e.getUniquePropID=()=>t.nextPropID++,e.getPropFromID=e=>{for(let n=0;n<t.children.length;n++){const r=t.children[n].getPropFromID(e);if(null!==r)return r}return null},e.getPixelsAsync=async()=>{const e=t.device,n=t.renderPasses[0].getOpaquePass().getColorTexture(),r={width:n.getWidth(),height:n.getHeight()};r.colorBufferWidth=32*Math.floor((r.width+31)/32),r.colorBufferSizeInBytes=r.colorBufferWidth*r.height*8;const o=sT.newInstance();o.setDevice(e),o.create(r.colorBufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);const a=t.device.createCommandEncoder();a.copyTextureToBuffer({texture:n.getHandle()},{buffer:o.getHandle(),bytesPerRow:8*r.colorBufferWidth,rowsPerImage:r.height},{width:r.width,height:r.height,depthOrArrayLayers:1}),e.submitCommandEncoder(a);const i=o.mapAsync(GPUMapMode.READ);await i,r.colorValues=new Uint16Array(o.getMappedRange().slice()),o.unmap();const s=new Uint8ClampedArray(r.height*r.width*4);for(let e=0;e<r.height;e++)for(let t=0;t<r.width;t++){const n=4*(e*r.width+t),o=4*(e*r.colorBufferWidth+t);s[n]=255*ku.fromHalf(r.colorValues[o]),s[n+1]=255*ku.fromHalf(r.colorValues[o+1]),s[n+2]=255*ku.fromHalf(r.colorValues[o+2]),s[n+3]=255*ku.fromHalf(r.colorValues[o+3])}return r.colorValues=s,r},e.createSelector=()=>{const t=xy.newInstance();return t.setWebGPURenderWindow(e),t};const r=e.setSize;e.setSize=(t,n)=>{const o=r(t,n);return o&&e.invokeWindowResizeEvent({width:t,height:n}),o},e.delete=Ht.chain(e.delete,e.setViewStream)}(e,t)}),"vtkWebGPURenderWindow");var My;_m("WebGPU",Ry),My=Ry,Cy.vtkRenderWindow=My;const Ey=Sh(),Vy={margin:"0",padding:"0",position:"absolute",top:"0",left:"0",width:"100%",height:"100%",overflow:"hidden"},Dy={position:"absolute",left:"25px",top:"25px",backgroundColor:"white",borderRadius:"5px",listStyle:"none",padding:"5px 10px",margin:"0",display:"block",border:"solid 1px black",maxWidth:"calc(100% - 70px)",maxHeight:"calc(100% - 60px)",overflow:"auto"};function Ly(e,t){Object.keys(t).forEach((n=>{e.style[n]=t[n]}))}const By={background:[.32,.34,.43],containerStyle:null,controlPanelStyle:null,listenWindowResize:!0,resizeCallback:null,controllerVisibility:!0};function Ny(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,By,n),Ht.obj(e,t),Ht.get(e,t,["renderWindow","renderer","apiSpecificRenderWindow","interactor","rootContainer","container","controlContainer"]),function(e,t){t.classHierarchy.push("vtkFullScreenRenderWindow");const n=document.querySelector("body");function r(t){"c"===String.fromCharCode(t.charCode)&&e.toggleControllerVisibility()}t.rootContainer||(t.rootContainer=n),t.container||(t.container=document.createElement("div"),Ly(t.container,t.containerStyle||Vy),t.rootContainer.appendChild(t.container)),t.rootContainer===n&&(document.documentElement.style.height="100%",n.style.height="100%",n.style.padding="0",n.style.margin="0"),t.renderWindow=zm.newInstance(),t.renderer=Nm.newInstance(),t.renderWindow.addRenderer(t.renderer),t.apiSpecificRenderWindow=t.renderWindow.newAPISpecificView(Ey.viewAPI??t.defaultViewAPI),t.apiSpecificRenderWindow.setContainer(t.container),t.renderWindow.addView(t.apiSpecificRenderWindow),t.interactor=ah.newInstance(),t.interactor.setInteractorStyle(bh.newInstance()),t.interactor.setView(t.apiSpecificRenderWindow),t.interactor.initialize(),t.interactor.bindEvents(t.container),e.setBackground=t.renderer.setBackground,e.removeController=()=>{const e=t.controlContainer;e&&e.parentNode.removeChild(e)},e.setControllerVisibility=e=>{t.controllerVisibility=e,t.controlContainer&&(t.controlContainer.style.display=e?"block":"none")},e.toggleControllerVisibility=()=>{e.setControllerVisibility(!t.controllerVisibility)},e.addController=n=>{t.controlContainer=document.createElement("div"),Ly(t.controlContainer,t.controlPanelStyle||Dy),t.rootContainer.appendChild(t.controlContainer),t.controlContainer.innerHTML=n,e.setControllerVisibility(t.controllerVisibility),t.rootContainer.addEventListener("keypress",r)},e.setBackground(...t.background),e.addRepresentation=e=>{e.getActors().forEach((e=>{t.renderer.addActor(e)}))},e.removeRepresentation=e=>{e.getActors().forEach((e=>t.renderer.removeActor(e)))},e.delete=Ht.chain(e.setContainer,t.apiSpecificRenderWindow.delete,(()=>{t.rootContainer?.removeEventListener("keypress",r),window.removeEventListener("resize",e.resize)}),e.delete),e.resize=()=>{const e=t.container.getBoundingClientRect(),n=window.devicePixelRatio||1;t.apiSpecificRenderWindow.setSize(Math.floor(e.width*n),Math.floor(e.height*n)),t.resizeCallback&&t.resizeCallback(e),t.renderWindow.render()},e.setResizeCallback=n=>{t.resizeCallback=n,e.resize()},t.listenWindowResize&&window.addEventListener("resize",e.resize),e.resize()}(e,t)}var Fy={newInstance:Ht.newInstance(Ny),extend:Ny},_y={ColorSpace:{RGB:0,HSV:1,LAB:2,DIVERGING:3},Scale:{LINEAR:0,LOG10:1}};const{ColorSpace:ky,Scale:Gy}=_y,{ScalarMappingTarget:Uy}=il,{vtkDebugMacro:zy,vtkErrorMacro:Wy,vtkWarningMacro:Hy}=Ht;function jy(e,t){const n=e[0],r=e[1],o=e[2],a=Math.sqrt(n*n+r*r+o*o),i=a>.001?Math.acos(n/a):0,s=i>.001?Math.atan2(o,r):0;t[0]=a,t[1]=i,t[2]=s}function Ky(e,t){if(e[0]>=t-.1)return e[2];const n=e[1]*Math.sqrt(t*t-e[0]*e[0])/(e[0]*Math.sin(e[1]));return e[2]>-.3*Math.PI?e[2]+n:e[2]-n}function $y(e,t,n,r){const o=[],a=[];va(t,o),va(n,a);const i=[],s=[];jy(o,i),jy(a,s);let l=e;if(i[1]>.05&&s[1]>.05&&function(e,t){let n=e-t;for(n<0&&(n=-n);n>=2*Math.PI;)n-=2*Math.PI;return n>Math.PI&&(n=2*Math.PI-n),n}(i[2],s[2])>.33*Math.PI){let t=Math.max(i[0],s[0]);t=Math.max(88,t),e<.5?(s[0]=t,s[1]=0,s[2]=0,l*=2):(i[0]=t,i[1]=0,i[2]=0,l=2*l-1)}i[1]<.05&&s[1]>.05?i[2]=Ky(s,i[0]):s[1]<.05&&i[1]>.05&&(s[2]=Ky(i,s[0]));const c=[];c[0]=(1-l)*i[0]+l*s[0],c[1]=(1-l)*i[1]+l*s[1],c[2]=(1-l)*i[2]+l*s[2];const u=[];!function(e,t){const n=e[0],r=e[1],o=e[2];t[0]=n*Math.cos(r),t[1]=n*Math.sin(r)*Math.cos(o),t[2]=n*Math.sin(r)*Math.sin(o)}(c,u),Ta(u,r)}const qy={clamping:!0,colorSpace:ky.RGB,hSVWrap:!0,scale:Gy.LINEAR,nanColor:null,belowRangeColor:null,aboveRangeColor:null,useAboveRangeColor:!1,useBelowRangeColor:!1,allowDuplicateScalars:!1,table:null,tableSize:0,buildTime:null,nodes:null,discretize:!1,numberOfValues:256};function Xy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,qy,n),il.extend(e,t,n),t.table=[],t.nodes=[],t.nanColor=[.5,0,0,1],t.belowRangeColor=[0,0,0,1],t.aboveRangeColor=[1,1,1,1],t.buildTime={},Ht.obj(t.buildTime),Ht.get(e,t,["buildTime","mappingRange"]),Ht.setGet(e,t,["useAboveRangeColor","useBelowRangeColor","discretize","numberOfValues",{type:"enum",name:"colorSpace",enum:ky},{type:"enum",name:"scale",enum:Gy}]),Ht.setArray(e,t,["nanColor","belowRangeColor","aboveRangeColor"],4),Ht.getArray(e,t,["nanColor","belowRangeColor","aboveRangeColor"]),function(e,t){t.classHierarchy.push("vtkColorTransferFunction"),e.getSize=()=>t.nodes.length,e.addRGBPoint=(t,n,r,o)=>e.addRGBPointLong(t,n,r,o,.5,0),e.addRGBPointLong=function(n,r,o,a){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;if(i<0||i>1)return Wy("Midpoint outside range [0.0, 1.0]"),-1;if(s<0||s>1)return Wy("Sharpness outside range [0.0, 1.0]"),-1;t.allowDuplicateScalars||e.removePoint(n);const l={x:n,r:r,g:o,b:a,midpoint:i,sharpness:s};t.nodes.push(l),e.sortAndUpdateRange();let c=0;for(;c<t.nodes.length&&t.nodes[c].x!==n;c++);return c<t.nodes.length?c:-1},e.addHSVPoint=(t,n,r,o)=>e.addHSVPointLong(t,n,r,o,.5,0),e.addHSVPointLong=function(t,n,r,o){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const s=[];return pa([n,r,o],s),e.addRGBPoint(t,s[0],s[1],s[2],a,i)},e.setNodes=n=>{if(t.nodes!==n){const r=JSON.stringify(t.nodes);t.nodes=n;const o=JSON.stringify(t.nodes);if(e.sortAndUpdateRange()||r!==o)return e.modified(),!0}return!1},e.sortAndUpdateRange=()=>{const n=JSON.stringify(t.nodes);t.nodes.sort(((e,t)=>e.x-t.x));const r=JSON.stringify(t.nodes),o=e.updateRange();return o||n===r?o:(e.modified(),!0)},e.updateRange=()=>{const n=[2];n[0]=t.mappingRange[0],n[1]=t.mappingRange[1];const r=t.nodes.length;return r?(t.mappingRange[0]=t.nodes[0].x,t.mappingRange[1]=t.nodes[r-1].x):(t.mappingRange[0]=0,t.mappingRange[1]=0),(n[0]!==t.mappingRange[0]||n[1]!==t.mappingRange[1])&&(e.modified(),!0)},e.removePoint=n=>{let r=0;for(;r<t.nodes.length&&t.nodes[r].x!==n;r++);const o=r;if(r>=t.nodes.length)return-1;let a=!1;return t.nodes.splice(r,1),0!==r&&r!==t.nodes.length||(a=e.updateRange()),a||e.modified(),o},e.movePoint=(n,r)=>{if(n!==r){e.removePoint(r);for(let o=0;o<t.nodes.length;o++)if(t.nodes[o].x===n){t.nodes[o].x=r,e.sortAndUpdateRange();break}}},e.removeAllPoints=()=>{t.nodes=[],e.sortAndUpdateRange()},e.addRGBSegment=(n,r,o,a,i,s,l,c)=>{e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n&&t.nodes[e].x<=i?t.nodes.splice(e,1):e++;e.addRGBPointLong(n,r,o,a,.5,0),e.addRGBPointLong(i,s,l,c,.5,0),e.modified()},e.addHSVSegment=(t,n,r,o,a,i,s,l)=>{const c=[i,s,l],u=[],d=[];pa([n,r,o],u),pa(c,d),e.addRGBSegment(t,u[0],u[1],u[2],a,d[0],d[1],d[2])},e.mapValue=t=>{const n=[];return e.getColor(t,n),[Math.floor(255*n[0]+.5),Math.floor(255*n[1]+.5),Math.floor(255*n[2]+.5),255]},e.getColor=(n,r)=>{if(t.indexedLookup){const t=e.getSize(),o=e.getAnnotatedValueIndexInternal(n);if(o<0||0===t){const t=e.getNanColorByReference();r[0]=t[0],r[1]=t[1],r[2]=t[2]}else{const n=[];e.getNodeValue(o%t,n),r[0]=n[1],r[1]=n[2],r[2]=n[3]}}else e.getTable(n,n,1,r)},e.getRedValue=t=>{const n=[];return e.getColor(t,n),n[0]},e.getGreenValue=t=>{const n=[];return e.getColor(t,n),n[1]},e.getBlueValue=t=>{const n=[];return e.getColor(t,n),n[2]},e.logScaleEnabled=()=>t.scale===Gy.LOG10,e.usingLogScale=()=>e.logScaleEnabled()&&t.mappingRange[0]>0,e.getTable=(n,r,o,a)=>{const i=e.usingLogScale(),s=i?Math.log10(Number(n)):Number(n),l=i?Math.log10(Number(r)):Number(r);if(Pa(s)||Pa(l)){for(let e=0;e<o;e++)a[3*e+0]=t.nanColor[0],a[3*e+1]=t.nanColor[1],a[3*e+2]=t.nanColor[2];return}let c=0;const u=t.nodes.length;let d=0,p=0,f=0;0!==u&&(d=t.nodes[u-1].r,p=t.nodes[u-1].g,f=t.nodes[u-1].b);let g=0,m=0,h=0;const v=[0,0,0],T=[0,0,0];let y=0,b=0;const x=[];let C=t.mappingRange;i&&(C=[Math.log10(t.mappingRange[0]),Math.log10(t.mappingRange[1])]);for(let n=0;n<o;n++){const r=3*n;if(g=o>1?s+n/(o-1)*(l-s):.5*(s+l),t.discretize){const e=C;if(g>=e[0]&&g<=e[1]){const n=t.numberOfValues,r=e[1]-e[0];if(n<=1)g=e[0]+r/2;else{const t=(g-e[0])/r,o=Co(n*t);g=e[0]+o/(n-1)*r}}}for(;c<u&&g>t.nodes[c].x;)c++,c<u&&(m=t.nodes[c-1].x,h=t.nodes[c].x,v[0]=t.nodes[c-1].r,T[0]=t.nodes[c].r,v[1]=t.nodes[c-1].g,T[1]=t.nodes[c].g,v[2]=t.nodes[c-1].b,T[2]=t.nodes[c].b,y=t.nodes[c-1].midpoint,b=t.nodes[c-1].sharpness,y<1e-5&&(y=1e-5),y>.99999&&(y=.99999));if(g>C[1])a[r]=0,a[r+1]=0,a[r+2]=0,t.clamping&&(e.getUseAboveRangeColor()?(a[r]=t.aboveRangeColor[0],a[r+1]=t.aboveRangeColor[1],a[r+2]=t.aboveRangeColor[2]):(a[r]=d,a[r+1]=p,a[r+2]=f));else if(g<C[0]||Ia(g)&&g<0)a[r]=0,a[r+1]=0,a[r+2]=0,t.clamping&&(e.getUseBelowRangeColor()?(a[r]=t.belowRangeColor[0],a[r+1]=t.belowRangeColor[1],a[r+2]=t.belowRangeColor[2]):u>0&&(a[r]=t.nodes[0].r,a[r+1]=t.nodes[0].g,a[r+2]=t.nodes[0].b));else if(0===c&&(Math.abs(g-s)<1e-6||t.discretize))u>0?(a[r]=t.nodes[0].r,a[r+1]=t.nodes[0].g,a[r+2]=t.nodes[0].b):(a[r]=0,a[r+1]=0,a[r+2]=0);else{let e=0;if(e=(g-m)/(h-m),e=e<y?.5*e/y:.5+.5*(e-y)/(1-y),b>.99){if(e<.5){a[r]=v[0],a[r+1]=v[1],a[r+2]=v[2];continue}a[r]=T[0],a[r+1]=T[1],a[r+2]=T[2];continue}if(b<.01){if(t.colorSpace===ky.RGB)a[r]=(1-e)*v[0]+e*T[0],a[r+1]=(1-e)*v[1]+e*T[1],a[r+2]=(1-e)*v[2]+e*T[2];else if(t.colorSpace===ky.HSV){const n=[],o=[];da(v,n),da(T,o),t.hSVWrap&&(n[0]-o[0]>.5||o[0]-n[0]>.5)&&(n[0]>o[0]?n[0]-=1:o[0]-=1);const i=[];i[0]=(1-e)*n[0]+e*o[0],i[0]<0&&(i[0]+=1),i[1]=(1-e)*n[1]+e*o[1],i[2]=(1-e)*n[2]+e*o[2],pa(i,x),a[r]=x[0],a[r+1]=x[1],a[r+2]=x[2]}else if(t.colorSpace===ky.LAB){const t=[],n=[];va(v,t),va(T,n);const o=[];o[0]=(1-e)*t[0]+e*n[0],o[1]=(1-e)*t[1]+e*n[1],o[2]=(1-e)*t[2]+e*n[2],Ta(o,x),a[r]=x[0],a[r+1]=x[1],a[r+2]=x[2]}else t.colorSpace===ky.DIVERGING?($y(e,v,T,x),a[r]=x[0],a[r+1]=x[1],a[r+2]=x[2]):Wy("ColorSpace set to invalid value.",t.colorSpace);continue}e<.5?e=.5*(2*e)**(1+10*b):e>.5&&(e=1-.5*(2*(1-e))**(1+10*b));const n=e*e,o=n*e,i=2*o-3*n+1,s=-2*o+3*n,l=o-2*n+e,c=o-n;let u,d;if(t.colorSpace===ky.RGB)for(let e=0;e<3;e++)u=T[e]-v[e],d=(1-b)*u,a[r+e]=i*v[e]+s*T[e]+l*d+c*d;else if(t.colorSpace===ky.HSV){const e=[],n=[];da(v,e),da(T,n),t.hSVWrap&&(e[0]-n[0]>.5||n[0]-e[0]>.5)&&(e[0]>n[0]?e[0]-=1:n[0]-=1);const o=[];for(let t=0;t<3;t++)u=n[t]-e[t],d=(1-b)*u,o[t]=i*e[t]+s*n[t]+l*d+c*d,0===t&&o[t]<0&&(o[t]+=1);pa(o,x),a[r]=x[0],a[r+1]=x[1],a[r+2]=x[2]}else if(t.colorSpace===ky.LAB){const e=[],t=[];va(v,e),va(T,t);const n=[];for(let r=0;r<3;r++)u=t[r]-e[r],d=(1-b)*u,n[r]=i*e[r]+s*t[r]+l*d+c*d;Ta(n,x),a[r]=x[0],a[r+1]=x[1],a[r+2]=x[2]}else t.colorSpace===ky.DIVERGING?($y(e,v,T,x),a[r]=x[0],a[r+1]=x[1],a[r+2]=x[2]):Wy("ColorSpace set to invalid value.");for(let e=0;e<3;e++)a[r+e]=a[r+e]<0?0:a[r+e],a[r+e]=a[r+e]>1?1:a[r+e]}}},e.getUint8Table=function(n,r,o){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(e.getMTime()<=t.buildTime&&t.tableSize===o&&t.tableWithAlpha!==a)return t.table;if(0===t.nodes.length)return Wy("Attempting to lookup a value with no points in the function"),t.table;const i=a?4:3;t.tableSize===o&&t.tableWithAlpha===a||(t.table=new Uint8Array(o*i),t.tableSize=o,t.tableWithAlpha=a);const s=[];e.getTable(n,r,o,s);for(let e=0;e<o;e++)t.table[e*i+0]=Math.floor(255*s[3*e+0]+.5),t.table[e*i+1]=Math.floor(255*s[3*e+1]+.5),t.table[e*i+2]=Math.floor(255*s[3*e+2]+.5),a&&(t.table[e*i+3]=255);return t.buildTime.modified(),t.table},e.buildFunctionFromArray=n=>{e.removeAllPoints();const r=n.getNumberOfComponents();for(let e=0;e<n.getNumberOfTuples();e++)switch(r){case 3:t.nodes.push({x:e,r:n.getComponent(e,0),g:n.getComponent(e,1),b:n.getComponent(e,2),midpoint:.5,sharpness:0});break;case 4:t.nodes.push({x:n.getComponent(e,0),r:n.getComponent(e,1),g:n.getComponent(e,2),b:n.getComponent(e,3),midpoint:.5,sharpness:0});break;case 5:t.nodes.push({x:e,r:n.getComponent(e,0),g:n.getComponent(e,1),b:n.getComponent(e,2),midpoint:n.getComponent(e,4),sharpness:n.getComponent(e,5)});break;case 6:t.nodes.push({x:n.getComponent(e,0),r:n.getComponent(e,1),g:n.getComponent(e,2),b:n.getComponent(e,3),midpoint:n.getComponent(e,4),sharpness:n.getComponent(e,5)})}e.sortAndUpdateRange()},e.buildFunctionFromTable=(n,r,o,a)=>{let i=0;e.removeAllPoints(),o>1&&(i=(r-n)/(o-1));for(let e=0;e<o;e++){const r={x:n+i*e,r:a[3*e],g:a[3*e+1],b:a[3*e+2],sharpness:0,midpoint:.5};t.nodes.push(r)}e.sortAndUpdateRange()},e.getNodeValue=(e,n)=>e<0||e>=t.nodes.length?(Wy("Index out of range!"),-1):(n[0]=t.nodes[e].x,n[1]=t.nodes[e].r,n[2]=t.nodes[e].g,n[3]=t.nodes[e].b,n[4]=t.nodes[e].midpoint,n[5]=t.nodes[e].sharpness,1),e.setNodeValue=(n,r)=>{if(n<0||n>=t.nodes.length)return Wy("Index out of range!"),-1;const o=t.nodes[n].x;return t.nodes[n].x=r[0],t.nodes[n].r=r[1],t.nodes[n].g=r[2],t.nodes[n].b=r[3],t.nodes[n].midpoint=r[4],t.nodes[n].sharpness=r[5],o!==r[0]?e.sortAndUpdateRange():e.modified(),1},e.getNumberOfAvailableColors=()=>{if(t.indexedLookup&&e.getSize())return e.getSize();if(t.tableSize)return t.tableSize;const n=t.nodes?.length??0;return Math.max(4094,n)},e.getIndexedColor=(t,n)=>{const r=e.getSize();if(r>0&&t>=0){const o=[];e.getNodeValue(t%r,o);for(let e=0;e<3;++e)n[e]=o[e+1];return void(n[3]=1)}const o=e.getNanColorByReference();n[0]=o[0],n[1]=o[1],n[2]=o[2],n[3]=1},e.fillFromDataPointer=(t,n)=>{if(!(t<=0)&&n){e.removeAllPoints();for(let r=0;r<t;r++)e.addRGBPoint(n[4*r],n[4*r+1],n[4*r+2],n[4*r+3])}},e.setMappingRange=(n,r)=>{const o=[n,r],a=[n,r],i=e.getRange(),s=e.logScaleEnabled();if(i[1]===o[1]&&i[0]===o[0])return;if(o[1]===o[0])return void Wy("attempt to set zero width color range");s&&(o[0]<=0?console.warn("attempt to set log scale color range with non-positive minimum"):(a[0]=Math.log10(o[0]),a[1]=Math.log10(o[1])));const l=(a[1]-a[0])/(i[1]-i[0]),c=a[0]-i[0]*l;for(let e=0;e<t.nodes.length;++e)t.nodes[e].x=t.nodes[e].x*l+c;t.mappingRange[0]=o[0],t.mappingRange[1]=o[1],e.modified()},e.adjustRange=n=>{const r=e.getRange(),o=[];r[0]<n[0]?(e.getColor(n[0],o),e.addRGBPoint(n[0],o[0],o[1],o[2])):(e.getColor(r[0],o),e.addRGBPoint(n[0],o[0],o[1],o[2])),r[1]>n[1]?(e.getColor(n[1],o),e.addRGBPoint(n[1],o[0],o[1],o[2])):(e.getColor(r[1],o),e.addRGBPoint(n[1],o[0],o[1],o[2])),e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n[0]&&t.nodes[e].x<=n[1]?t.nodes.splice(e,1):++e;return 1},e.estimateMinNumberOfSamples=(t,n)=>{const r=e.findMinimumXDistance();return Math.ceil((n-t)/r)},e.findMinimumXDistance=()=>{if(t.nodes.length<2)return-1;let e=Number.MAX_VALUE;for(let n=0;n<t.nodes.length-1;n++){const r=t.nodes[n+1].x-t.nodes[n].x;r<e&&(e=r)}return e},e.mapScalarsThroughTable=(n,r,o,a)=>{0!==e.getSize()?t.indexedLookup?e.mapDataIndexed(n,r,o,a):e.mapData(n,r,o,a):zy("Transfer Function Has No Points!")},e.mapData=(t,n,r,o)=>{if(0===e.getSize())return void Hy("Transfer Function Has No Points!");const a=Math.floor(255*e.getAlpha()+.5),i=t.getNumberOfTuples(),s=t.getNumberOfComponents(),l=n.getData(),c=t.getData(),u=[];if(r===Uy.RGBA)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[4*t]=Math.floor(255*u[0]+.5),l[4*t+1]=Math.floor(255*u[1]+.5),l[4*t+2]=Math.floor(255*u[2]+.5),l[4*t+3]=a}if(r===Uy.RGB)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[3*t]=Math.floor(255*u[0]+.5),l[3*t+1]=Math.floor(255*u[1]+.5),l[3*t+2]=Math.floor(255*u[2]+.5)}if(r===Uy.LUMINANCE)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[t]=Math.floor(76.5*u[0]+150.45*u[1]+28.05*u[2]+.5)}if(r===Uy.LUMINANCE_ALPHA)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[2*t]=Math.floor(76.5*u[0]+150.45*u[1]+28.05*u[2]+.5),l[2*t+1]=a}},e.applyColorMap=n=>{const r=JSON.stringify(t.colorSpace);n.ColorSpace&&(t.colorSpace=ky[n.ColorSpace.toUpperCase()],void 0===t.colorSpace&&(Wy(`ColorSpace ${n.ColorSpace} not supported, using RGB instead`),t.colorSpace=ky.RGB));let o=r!==JSON.stringify(t.colorSpace);const a=o||JSON.stringify(t.nanColor);if(n.NanColor)for(t.nanColor=[].concat(n.NanColor);t.nanColor.length<4;)t.nanColor.push(1);o=o||a!==JSON.stringify(t.nanColor);const i=o||JSON.stringify(t.nodes);if(n.RGBPoints){const e=n.RGBPoints.length;t.nodes=[];const r=.5,o=0;for(let a=0;a<e;a+=4)t.nodes.push({x:n.RGBPoints[a],r:n.RGBPoints[a+1],g:n.RGBPoints[a+2],b:n.RGBPoints[a+3],midpoint:r,sharpness:o})}const s=e.sortAndUpdateRange(),l=!s&&(o||i!==JSON.stringify(t.nodes));return l&&e.modified(),s||l}}(e,t)}var Yy={newInstance:Ht.newInstance(Xy,"vtkColorTransferFunction"),extend:Xy,..._y},Zy={OrientationModes:{DIRECTION:0,ROTATION:1,MATRIX:2},ScaleModes:{SCALE_BY_CONSTANT:0,SCALE_BY_MAGNITUDE:1,SCALE_BY_COMPONENTS:2}};const{OrientationModes:Qy,ScaleModes:Jy}=Zy,{vtkErrorMacro:eb}=Ht,tb={orient:!0,orientationMode:Qy.DIRECTION,orientationArray:null,scaling:!0,scaleFactor:1,scaleMode:Jy.SCALE_BY_MAGNITUDE,scaleArray:null,matrixArray:null,normalArray:null,colorArray:null};function nb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,tb,n),Fl.extend(e,t,n),Ht.algo(e,t,2,0),t.buildTime={},Ht.obj(t.buildTime,{mtime:0}),t.boundsTime={},Ht.obj(t.boundsTime,{mtime:0}),Ht.setGet(e,t,["orient","orientationMode","orientationArray","scaleArray","scaleFactor","scaleMode","scaling"]),Ht.get(e,t,["colorArray","matrixArray","normalArray","buildTime"]),function(e,t){t.classHierarchy.push("vtkGlyph3DMapper"),e.getOrientationModeAsString=()=>Ht.enumToString(Qy,t.orientationMode),e.setOrientationModeToDirection=()=>e.setOrientationMode(Qy.DIRECTION),e.setOrientationModeToRotation=()=>e.setOrientationMode(Qy.ROTATION),e.setOrientationModeToMatrix=()=>e.setOrientationMode(Qy.MATRIX),e.getOrientationArrayData=()=>{const n=e.getInputData(0);return n&&n.getPointData()?t.orientationArray?n.getPointData().getArray(t.orientationArray):n.getPointData().getVectors():null},e.getScaleModeAsString=()=>Ht.enumToString(Jy,t.scaleMode),e.setScaleModeToScaleByMagnitude=()=>e.setScaleMode(Jy.SCALE_BY_MAGNITUDE),e.setScaleModeToScaleByComponents=()=>e.setScaleMode(Jy.SCALE_BY_COMPONENTS),e.setScaleModeToScaleByConstant=()=>e.setScaleMode(Jy.SCALE_BY_CONSTANT),e.getScaleArrayData=()=>{const n=e.getInputData(0);return n&&n.getPointData()?t.scaleArray?n.getPointData().getArray(t.scaleArray):n.getPointData().getScalars():null},e.getBounds=()=>{const n=e.getInputData(0),r=e.getInputData(1);return n&&r?(e.buildArrays(),t.bounds):Ra()},e.buildArrays=()=>{const n=e.getInputData(0),r=e.getInputData(1);if(t.buildTime.getMTime()<r.getMTime()||t.buildTime.getMTime()<n.getMTime()||t.buildTime.getMTime()<e.getMTime()){const o=n.getPoints().getData();let a=e.getScaleArrayData(),i=null,s=0;a&&(i=a.getData(),s=a.getNumberOfComponents()),t.scaling&&a&&t.scaleMode===Jy.SCALE_BY_COMPONENTS&&3!==a.getNumberOfComponents()&&(eb("Cannot scale by components since scale array does not have 3 components."),a=null);const l=r.getBounds(),c=[];Fi.getCorners(l,c),t.bounds[0]=Fi.INIT_BOUNDS[0],t.bounds[1]=Fi.INIT_BOUNDS[1],t.bounds[2]=Fi.INIT_BOUNDS[2],t.bounds[3]=Fi.INIT_BOUNDS[3],t.bounds[4]=Fi.INIT_BOUNDS[4],t.bounds[5]=Fi.INIT_BOUNDS[5];const u=new Float64Array(3),d=e.getOrientationArrayData(),p=g(new Float64Array(16)),f=[],m=[],h=o.length/3;t.matrixArray=new Float32Array(16*h);const v=t.matrixArray.buffer;t.normalArray=new Float32Array(9*h);const T=t.normalArray.buffer,w=[],O=[];for(let e=0;e<h;++e){const n=new Float32Array(v,64*e,16);if(f[0]=o[3*e],f[1]=o[3*e+1],f[2]=o[3*e+2],b(n,p,f),d)switch(d.getTuple(e,O),t.orientationMode){case Qy.MATRIX:y(n,n,[...O.slice(0,3),0,...O.slice(3,6),0,...O.slice(6,9),0,0,0,0,1]);break;case Qy.ROTATION:I(n,n,O[2]),S(n,n,O[0]),A(n,n,O[1]);break;case Qy.DIRECTION:if(0===O[1]&&0===O[2])O[0]<0&&A(n,n,3.1415926);else{const e=_o(O),t=[];t[0]=(O[0]+e)/2,t[1]=O[1]/2,t[2]=O[2]/2,C(n,n,3.1415926,t)}}if(t.scaling){if(m[0]=t.scaleFactor,m[1]=t.scaleFactor,m[2]=t.scaleFactor,a)switch(t.scaleMode){case Jy.SCALE_BY_MAGNITUDE:for(let t=0;t<s;++t)w[t]=i[e*s+t];m[0]*=_o(w,s),m[1]=m[0],m[2]=m[0];break;case Jy.SCALE_BY_COMPONENTS:for(let t=0;t<s;++t)w[t]=i[e*s+t];m[0]*=w[0],m[1]*=w[1],m[2]*=w[2];case Jy.SCALE_BY_CONSTANT:}0===m[0]&&(m[0]=1e-10),0===m[1]&&(m[1]=1e-10),0===m[2]&&(m[2]=1e-10),x(n,n,m)}for(let e=0;e<8;++e)wn(u,c[e],n),u[0]<t.bounds[0]&&(t.bounds[0]=u[0]),u[1]<t.bounds[2]&&(t.bounds[2]=u[1]),u[2]<t.bounds[4]&&(t.bounds[4]=u[2]),u[0]>t.bounds[1]&&(t.bounds[1]=u[0]),u[1]>t.bounds[3]&&(t.bounds[3]=u[1]),u[2]>t.bounds[5]&&(t.bounds[5]=u[2]);const r=new Float32Array(T,36*e,9);se(r,n),ge(r,r),fe(r,r)}const P=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]),t.colorArray=null;const R=e.getLookupTable();R&&P&&(R.build(),t.colorArray=R.mapScalars(P,t.colorMode,0)),t.buildTime.modified()}},e.getPrimitiveCount=()=>{const t=e.getInputData(1),n=e.getInputData().getPoints().getNumberOfValues()/3;return{points:n*t.getPoints().getNumberOfValues()/3,verts:n*(t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells()),lines:n*(t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells()),triangles:n*(t.getPolys().getNumberOfValues()-3*t.getLines().getNumberOfCells())}},e.setSourceConnection=t=>e.setInputConnection(t,1)}(e,t)}var rb={newInstance:Ht.newInstance(nb,"vtkGlyph3DMapper"),extend:nb,...Zy};const{vtkErrorMacro:ob}=Ht,ab={range:[0,0],clamping:!0,allowDuplicateScalars:!1};function ib(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ab,n),Ht.obj(e,t),t.nodes=[],Ht.setGet(e,t,["allowDuplicateScalars","clamping"]),Ht.setArray(e,t,["range"],2),Ht.getArray(e,t,["range"]),function(e,t){t.classHierarchy.push("vtkPiecewiseFunction"),e.getSize=()=>t.nodes.length,e.getType=()=>{let e,n=0,r=0;t.nodes.length>0&&(n=t.nodes[0].y);for(let o=1;o<t.nodes.length;o++){if(e=t.nodes[o].y,e!==n)if(e>n)switch(r){case 0:case 1:r=1;break;default:r=3}else switch(r){case 0:case 2:r=2;break;default:r=3}if(n=e,3===r)break}switch(r){case 0:return"Constant";case 1:return"NonDecreasing";case 2:return"NonIncreasing";default:return"Varied"}},e.getDataPointer=()=>{const e=t.nodes.length;if(t.function=null,e>0){t.function=[];for(let n=0;n<e;n++)t.function[2*n]=t.nodes[n].x,t.function[2*n+1]=t.nodes[n].y}return t.function},e.getFirstNonZeroValue=()=>{if(0===t.nodes.length)return 0;let e=1,n=0,r=0;for(;r<t.nodes.length;r++)if(0!==t.nodes[r].y){e=0;break}return n=e?Number.MAX_VALUE:r>0?t.nodes[r-1].x:t.clamping?-Number.MAX_VALUE:t.nodes[0].x,n},e.getNodeValue=(e,n)=>{const r=t.nodes.length;return e<0||e>=r?(ob("Index out of range!"),-1):(n[0]=t.nodes[e].x,n[1]=t.nodes[e].y,n[2]=t.nodes[e].midpoint,n[3]=t.nodes[e].sharpness,1)},e.setNodeValue=(n,r)=>{const o=t.nodes.length;if(n<0||n>=o)return ob("Index out of range!"),-1;const a=t.nodes[n].x;return t.nodes[n].x=r[0],t.nodes[n].y=r[1],t.nodes[n].midpoint=r[2],t.nodes[n].sharpness=r[3],a!==r[0]?e.sortAndUpdateRange():e.modified(),1},e.addPoint=(t,n)=>e.addPointLong(t,n,.5,0),e.addPointLong=(n,r,o,a)=>{if(o<0||o>1)return ob("Midpoint outside range [0.0, 1.0]"),-1;if(a<0||a>1)return ob("Sharpness outside range [0.0, 1.0]"),-1;t.allowDuplicateScalars||e.removePoint(n);const i={x:n,y:r,midpoint:o,sharpness:a};let s;for(t.nodes.push(i),e.sortAndUpdateRange(),s=0;s<t.nodes.length&&t.nodes[s].x!==n;s++);return s<t.nodes.length?s:-1},e.setNodes=n=>{t.nodes!==n&&(t.nodes=n,e.sortAndUpdateRange())},e.sortAndUpdateRange=()=>{t.nodes.sort(((e,t)=>e.x-t.x)),e.updateRange()||e.modified()},e.updateRange=()=>{const n=t.range.slice(),r=t.nodes.length;return r?(t.range[0]=t.nodes[0].x,t.range[1]=t.nodes[r-1].x):(t.range[0]=0,t.range[1]=0),(n[0]!==t.range[0]||n[1]!==t.range[1])&&(e.modified(),!0)},e.removePoint=n=>{let r;for(r=0;r<t.nodes.length&&t.nodes[r].x!==n;r++);if(r>=t.nodes.length)return-1;const o=r;let a=!1;return t.nodes.splice(r,1),0!==r&&r!==t.nodes.length||(a=e.updateRange()),a||e.modified(),o},e.removeAllPoints=()=>{t.nodes=[],e.sortAndUpdateRange()},e.addSegment=(n,r,o,a)=>{e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n&&t.nodes[e].x<=o?t.nodes.splice(e,1):e++;e.addPoint(n,r,.5,0),e.addPoint(o,a,.5,0)},e.getValue=t=>{const n=[];return e.getTable(t,t,1,n),n[0]},e.adjustRange=n=>{if(n.length<2)return 0;const r=e.getRange();r[0]<n[0]?e.addPoint(n[0],e.getValue(n[0])):e.addPoint(n[0],e.getValue(r[0])),r[1]>n[1]?e.addPoint(n[1],e.getValue(n[1])):e.addPoint(n[1],e.getValue(r[1])),e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n[0]&&t.nodes[e].x<=n[1]?t.nodes.splice(e,1):++e;return e.sortAndUpdateRange(),1},e.estimateMinNumberOfSamples=(t,n)=>{const r=e.findMinimumXDistance();return Math.ceil((n-t)/r)},e.findMinimumXDistance=()=>{const e=t.nodes.length;if(e<2)return-1;let n=t.nodes[1].x-t.nodes[0].x;for(let r=0;r<e-1;r++){const e=t.nodes[r+1].x-t.nodes[r].x;e<n&&(n=e)}return n},e.getTable=function(e,n,r,o){let a,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,s=0;const l=t.nodes.length;let c=0;0!==l&&(c=t.nodes[l-1].y);let u=0,d=0,p=0,f=0,g=0,m=0,h=0;for(a=0;a<r;a++){const v=i*a;for(u=r>1?e+a/(r-1)*(n-e):.5*(e+n);s<l&&u>t.nodes[s].x;)s++,s<l&&(d=t.nodes[s-1].x,p=t.nodes[s].x,f=t.nodes[s-1].y,g=t.nodes[s].y,m=t.nodes[s-1].midpoint,h=t.nodes[s-1].sharpness,m<1e-5&&(m=1e-5),m>.99999&&(m=.99999));if(s>=l)o[v]=t.clamping?c:0;else if(0===s)o[v]=t.clamping?t.nodes[0].y:0;else{let e=(u-d)/(p-d);if(e=e<m?.5*e/m:.5+.5*(e-m)/(1-m),h>.99){if(e<.5){o[v]=f;continue}o[v]=g;continue}if(h<.01){o[v]=(1-e)*f+e*g;continue}e<.5?e=.5*(2*e)**(1+10*h):e>.5&&(e=1-.5*(2*(1-e))**(1+10*h));const t=e*e,n=t*e,r=2*n-3*t+1,a=-2*n+3*t,i=n-2*t+e,s=n-t,l=(1-h)*(g-f);o[v]=r*f+a*g+i*l+s*l;const c=f<g?f:g,T=f>g?f:g;o[v]=o[v]<c?c:o[v],o[v]=o[v]>T?T:o[v]}}}}(e,t)}var sb={newInstance:Ht.newInstance(ib,"vtkPiecewiseFunction"),extend:ib};const{InterpolationType:lb,OpacityMode:cb,FilterMode:ub,ColorMixPreset:db}=If,{vtkErrorMacro:pb}=Ht;function fb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,(e=>({colorMixPreset:db.DEFAULT,independentComponents:!0,interpolationType:lb.FAST_LINEAR,shade:!1,ambient:.1,diffuse:.7,specular:.2,specularPower:10,useLabelOutline:!1,labelOutlineThickness:[1],labelOutlineOpacity:1,ipScalarRange:[-1e6,1e6],filterMode:ub.OFF,preferSizeOverAccuracy:!1,computeNormalFromOpacity:!1,volumetricScatteringBlending:0,globalIlluminationReach:0,anisotropy:0,localAmbientOcclusion:!1,LAOKernelSize:15,LAOKernelRadius:7,updatedExtents:[],...e}))(n)),Ht.obj(e,t),!t.componentData){t.componentData=[];for(let e=0;e<4;++e)t.componentData.push({colorChannels:1,grayTransferFunction:null,rGBTransferFunction:null,scalarOpacity:null,scalarOpacityUnitDistance:1,opacityMode:cb.FRACTIONAL,gradientOpacityMinimumValue:0,gradientOpacityMinimumOpacity:0,gradientOpacityMaximumValue:1,gradientOpacityMaximumOpacity:1,useGradientOpacity:!1,componentWeight:1,forceNearestInterpolation:!1})}Ht.setGet(e,t,["colorMixPreset","independentComponents","interpolationType","shade","ambient","diffuse","specular","specularPower","useLabelOutline","labelOutlineOpacity","filterMode","preferSizeOverAccuracy","computeNormalFromOpacity","volumetricScatteringBlending","globalIlluminationReach","anisotropy","localAmbientOcclusion","LAOKernelSize","LAOKernelRadius","updatedExtents"]),Ht.setGetArray(e,t,["ipScalarRange"],2),Ht.setGetArray(e,t,["labelOutlineThickness"]),function(e,t){t.classHierarchy.push("vtkVolumeProperty");const n={...e};e.getMTime=()=>{let e,n=t.mtime;for(let r=0;r<4;r++)1===t.componentData[r].colorChannels?t.componentData[r].grayTransferFunction&&(e=t.componentData[r].grayTransferFunction.getMTime(),n=n>e?n:e):3===t.componentData[r].colorChannels&&t.componentData[r].rGBTransferFunction&&(e=t.componentData[r].rGBTransferFunction.getMTime(),n=n>e?n:e),t.componentData[r].scalarOpacity&&(e=t.componentData[r].scalarOpacity.getMTime(),n=n>e?n:e),t.componentData[r].gradientOpacity&&(t.componentData[r].disableGradientOpacity||(e=t.componentData[r].gradientOpacity.getMTime(),n=n>e?n:e));return n},e.getColorChannels=e=>e<0||e>3?(pb("Bad index - must be between 0 and 3"),0):t.componentData[e].colorChannels,e.setGrayTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=!1;return t.componentData[n].grayTransferFunction!==r&&(t.componentData[n].grayTransferFunction=r,o=!0),1!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=1,o=!0),o&&e.modified(),o},e.getGrayTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].grayTransferFunction&&(t.componentData[n].grayTransferFunction=sb.newInstance(),t.componentData[n].grayTransferFunction.addPoint(0,0),t.componentData[n].grayTransferFunction.addPoint(1024,1),1!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=1),e.modified()),t.componentData[n].grayTransferFunction},e.setRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=!1;return t.componentData[n].rGBTransferFunction!==r&&(t.componentData[n].rGBTransferFunction=r,o=!0),3!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=3,o=!0),o&&e.modified(),o},e.getRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].rGBTransferFunction&&(t.componentData[n].rGBTransferFunction=Yy.newInstance(),t.componentData[n].rGBTransferFunction.addRGBPoint(0,0,0,0),t.componentData[n].rGBTransferFunction.addRGBPoint(1024,1,1,1),3!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=3),e.modified()),t.componentData[n].rGBTransferFunction},e.setScalarOpacity=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return t.componentData[n].scalarOpacity!==r&&(t.componentData[n].scalarOpacity=r,e.modified(),!0)},e.getScalarOpacity=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].scalarOpacity&&(t.componentData[n].scalarOpacity=sb.newInstance(),t.componentData[n].scalarOpacity.addPoint(0,1),t.componentData[n].scalarOpacity.addPoint(1024,1),e.modified()),t.componentData[n].scalarOpacity},e.setComponentWeight=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(n<0||n>=4)return pb("Invalid index"),!1;const o=Math.min(1,Math.max(0,r));return t.componentData[n].componentWeight!==o&&(t.componentData[n].componentWeight=o,e.modified(),!0)},e.getComponentWeight=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e<0||e>=4?(pb("Invalid index"),0):t.componentData[e].componentWeight},e.setInterpolationTypeToNearest=()=>e.setInterpolationType(lb.NEAREST),e.setInterpolationTypeToLinear=()=>e.setInterpolationType(lb.LINEAR),e.setInterpolationTypeToFastLinear=()=>e.setInterpolationType(lb.FAST_LINEAR),e.getInterpolationTypeAsString=()=>Ht.enumToString(lb,t.interpolationType),["useGradientOpacity","scalarOpacityUnitDistance","gradientOpacityMinimumValue","gradientOpacityMinimumOpacity","gradientOpacityMaximumValue","gradientOpacityMaximumOpacity","opacityMode","forceNearestInterpolation"].forEach((n=>{const r=Ht.capitalize(n);e[`set${r}`]=(r,o)=>t.componentData[r][`${n}`]!==o&&(t.componentData[r][`${n}`]=o,e.modified(),!0)})),["useGradientOpacity","scalarOpacityUnitDistance","gradientOpacityMinimumValue","gradientOpacityMinimumOpacity","gradientOpacityMaximumValue","gradientOpacityMaximumOpacity","opacityMode","forceNearestInterpolation"].forEach((n=>{const r=Ht.capitalize(n);e[`get${r}`]=e=>t.componentData[e][`${n}`]})),e.setAverageIPScalarRange=(t,n)=>{console.warn("setAverageIPScalarRange is deprecated use setIpScalarRange"),e.setIpScalarRange(t,n)},e.getFilterModeAsString=()=>Ht.enumToString(ub,t.filterMode),e.setFilterModeToOff=()=>{e.setFilterMode(ub.OFF)},e.setFilterModeToNormalized=()=>{e.setFilterMode(ub.NORMALIZED)},e.setFilterModeToRaw=()=>{e.setFilterMode(ub.RAW)},e.setGlobalIlluminationReach=e=>n.setGlobalIlluminationReach(xa(e,0,1)),e.setVolumetricScatteringBlending=e=>n.setVolumetricScatteringBlending(xa(e,0,1)),e.setAnisotropy=e=>n.setAnisotropy(xa(e,-.99,.99)),e.setLAOKernelSize=e=>n.setLAOKernelSize(Co(xa(e,1,32))),e.setLAOKernelRadius=e=>n.setLAOKernelRadius(e>=1?e:1)}(e,t)}var gb={newInstance:Ht.newInstance(fb,"vtkVolumeProperty"),extend:fb,...If};const mb={mapper:null};function hb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,mb,n),Ki.extend(e,t,n),t.boundsMTime={},Ht.obj(t.boundsMTime),Ht.setGet(e,t,["mapper"]),function(e,t){t.classHierarchy.push("vtkVolume"),e.getVolumes=()=>[e],e.makeProperty=gb.newInstance,e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}return e}}(e,t)}var vb={newInstance:Ht.newInstance(hb,"vtkVolume"),extend:hb};const{BlendMode:Tb}=Of,yb=["getAnisotropy","getComputeNormalFromOpacity","getFilterMode","getFilterModeAsString","getGlobalIlluminationReach","getIpScalarRange","getIpScalarRangeByReference","getLAOKernelRadius","getLAOKernelSize","getLocalAmbientOcclusion","getPreferSizeOverAccuracy","getVolumetricScatteringBlending","setAnisotropy","setAverageIPScalarRange","setComputeNormalFromOpacity","setFilterMode","setFilterModeToNormalized","setFilterModeToOff","setFilterModeToRaw","setGlobalIlluminationReach","setIpScalarRange","setIpScalarRangeFrom","setLAOKernelRadius","setLAOKernelSize","setLocalAmbientOcclusion","setPreferSizeOverAccuracy","setVolumetricScatteringBlending"],bb={createRadonTransferFunction:function(e,t,n,r,o){let a=null;return o?(a=o,a.removeAllPoints()):a=sb.newInstance(),a.addPointLong(-1024,0,1,1),a.addPoint(e,t),a.addPoint(n,r),a}};function xb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,(e=>({bounds:[...Fi.INIT_BOUNDS],sampleDistance:1,imageSampleDistance:1,maximumSamplesPerRay:1e3,autoAdjustSampleDistances:!0,initialInteractionScale:1,interactionSampleDistanceFactor:1,blendMode:Tb.COMPOSITE_BLEND,volumeShadowSamplingDistFactor:5,colorTextureWidth:1024,opacityTextureWidth:1024,labelOutlineTextureWidth:1024,...e}))(n)),xs(e,t,n),Ht.setGet(e,t,["sampleDistance","imageSampleDistance","maximumSamplesPerRay","autoAdjustSampleDistances","initialInteractionScale","interactionSampleDistanceFactor","blendMode","volumeShadowSamplingDistFactor","colorTextureWidth","opacityTextureWidth","labelOutlineTextureWidth"]),Ht.event(e,t,"lightingActivated"),function(e,t){t.classHierarchy.push("vtkVolumeMapper");const n={...e};e.getBounds=()=>(t.static||e.update(),t.bounds=[...e.getInputData().getBounds()],t.bounds),e.setBlendModeToComposite=()=>{e.setBlendMode(Tb.COMPOSITE_BLEND)},e.setBlendModeToMaximumIntensity=()=>{e.setBlendMode(Tb.MAXIMUM_INTENSITY_BLEND)},e.setBlendModeToMinimumIntensity=()=>{e.setBlendMode(Tb.MINIMUM_INTENSITY_BLEND)},e.setBlendModeToAverageIntensity=()=>{e.setBlendMode(Tb.AVERAGE_INTENSITY_BLEND)},e.setBlendModeToAdditiveIntensity=()=>{e.setBlendMode(Tb.ADDITIVE_INTENSITY_BLEND)},e.setBlendModeToRadonTransform=()=>{e.setBlendMode(Tb.RADON_TRANSFORM_BLEND)},e.getBlendModeAsString=()=>Ht.enumToString(Tb,t.blendMode),e.setVolumeShadowSamplingDistFactor=e=>n.setVolumeShadowSamplingDistFactor(e>=1?e:1),yb.forEach((t=>{e[t]=()=>{throw new Error(`The method "volumeMapper.${t}()" doesn't exist anymore. It is a rendering property that has been moved to the volume property. Replace your code with:\nvolumeActor.getProperty().${t}()\n`)}}))}(e,t)}var Cb={newInstance:Ht.newInstance(xb,"vtkVolumeMapper"),extend:xb,...bb};const{InterpolationType:Sb}=ef,{vtkErrorMacro:Ab}=Ht;function Ib(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,(e=>({independentComponents:!1,interpolationType:Sb.LINEAR,colorWindow:255,colorLevel:127.5,ambient:1,diffuse:0,opacity:1,useLookupTableScalarRange:!1,useLabelOutline:!1,labelOutlineThickness:[1],labelOutlineOpacity:1,updatedExtents:[],...e}))(n)),Ht.obj(e,t),!t.componentData){t.componentData=[];for(let e=0;e<4;e++)t.componentData.push({rGBTransferFunction:null,piecewiseFunction:null,componentWeight:1})}Ht.setGet(e,t,["independentComponents","interpolationType","colorWindow","colorLevel","ambient","diffuse","opacity","useLookupTableScalarRange","useLabelOutline","labelOutlineOpacity","updatedExtents"]),Ht.setGetArray(e,t,["labelOutlineThickness"]),function(e,t){t.classHierarchy.push("vtkImageProperty"),e.getMTime=()=>{let e,n=t.mtime;for(let r=0;r<4;r++)t.componentData[r].rGBTransferFunction&&(e=t.componentData[r].rGBTransferFunction.getMTime(),n=n>e?n:e),t.componentData[r].piecewiseFunction&&(e=t.componentData[r].piecewiseFunction.getMTime(),n=n>e?n:e);return n},e.setRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=n,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return Number.isInteger(n)||(o=n,r=0),t.componentData[r].rGBTransferFunction!==o&&(t.componentData[r].rGBTransferFunction=o,e.modified(),!0)},e.getRGBTransferFunction=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.componentData[e].rGBTransferFunction},e.setPiecewiseFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=n,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return Number.isInteger(n)||(o=n,r=0),t.componentData[r].piecewiseFunction!==o&&(t.componentData[r].piecewiseFunction=o,e.modified(),!0)},e.getPiecewiseFunction=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.componentData[e].piecewiseFunction},e.setScalarOpacity=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=t,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return Number.isInteger(t)||(r=t,n=0),e.setPiecewiseFunction(n,r)},e.getScalarOpacity=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e.getPiecewiseFunction(t)},e.setComponentWeight=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(n<0||n>=4)return Ab("Invalid index"),!1;const o=Math.min(1,Math.max(0,r));return t.componentData[n].componentWeight!==o&&(t.componentData[n].componentWeight=o,e.modified(),!0)},e.getComponentWeight=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e<0||e>=4?(Ab("Invalid index"),0):t.componentData[e].componentWeight},e.setInterpolationTypeToNearest=()=>e.setInterpolationType(Sb.NEAREST),e.setInterpolationTypeToLinear=()=>e.setInterpolationType(Sb.LINEAR),e.getInterpolationTypeAsString=()=>Ht.enumToString(Sb,t.interpolationType)}(e,t)}var wb={newInstance:Ht.newInstance(Ib,"vtkImageProperty"),extend:Ib};const Ob={mapper:null,forceOpaque:!1,forceTranslucent:!1};function Pb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ob,n),Ki.extend(e,t,n),t.boundsMTime={},Ht.obj(t.boundsMTime),Ht.setGet(e,t,["mapper","forceOpaque","forceTranslucent"]),function(e,t){t.classHierarchy.push("vtkImageSlice"),e.getActors=()=>e,e.getImages=()=>e,e.getIsOpaque=()=>{if(t.forceOpaque)return!0;if(t.forceTranslucent)return!1;t.properties[0]||e.getProperty();let n=t.properties[0].getOpacity()>=1;return n=n&&(!t.mapper||t.mapper.getIsOpaque()),n},e.hasTranslucentPolygonalGeometry=()=>!1,e.makeProperty=wb.newInstance,e.getBoundsForSlice=(n,r)=>{const o=t.mapper.getBoundsForSlice(n,r);if(!Fi.isValid(o))return o;e.computeMatrix();const a=new Float64Array(16);return m(a,t.matrix),Fi.transformBounds(o,a)},e.getMinXBound=()=>e.getBounds()[0],e.getMaxXBound=()=>e.getBounds()[1],e.getMinYBound=()=>e.getBounds()[2],e.getMaxYBound=()=>e.getBounds()[3],e.getMinZBound=()=>e.getBounds()[4],e.getMaxZBound=()=>e.getBounds()[5],e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}return t.properties.forEach((t=>{e=Math.max(e,t.getMTime());const n=t.getRGBTransferFunction();null!==n&&(e=Math.max(e,n.getMTime()))})),e},e.getSupportsSelection=()=>!!t.mapper&&t.mapper.getSupportsSelection()}(e,t)}var Rb={newInstance:Ht.newInstance(Pb,"vtkImageSlice"),extend:Pb};const Mb={slice:0,customDisplayExtent:[0,0,0,0,0,0],useCustomExtents:!1,backgroundColor:[0,0,0,1],colorTextureWidth:1024,opacityTextureWidth:1024,labelOutlineTextureWidth:1024};var Eb=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Mb,n),xs(e,t,n),Ht.setGet(e,t,["slice","useCustomExtents","colorTextureWidth","opacityTextureWidth","labelOutlineTextureWidth"]),Ht.setGetArray(e,t,["customDisplayExtent"],6),Ht.setGetArray(e,t,["backgroundColor"],4),function(e,t){t.classHierarchy.push("vtkAbstractImageMapper"),e.getIsOpaque=()=>!0,e.getCurrentImage=()=>null,e.getBoundsForSlice=()=>(Ht.vtkErrorMacro("vtkAbstractImageMapper.getBoundsForSlice - NOT IMPLEMENTED"),Ra())}(e,t)};function Vb(e,t,n){const r=n.getCurrentImage(),o=r.getExtent(),a=[o[0],o[2],o[4]],{ijkMode:i}=n.getClosestIJKAxis();let s=n.isA("vtkImageArrayMapper")?n.getSubSlice():n.getSlice();i!==n.getSlicingMode()&&(s=n.getSliceAtPosition(s)),a[i]+=s;const l=[0,0,0];r.indexToWorld(a,l),a[i]+=1;const c=[0,0,0];r.indexToWorld(a,c),c[0]-=l[0],c[1]-=l[1],c[2]-=l[2],Sn(c,c);const u=ti.intersectWithLine(e,t,l,c);if(u.intersection){const e=u.x,t=[0,0,0];return r.worldToIndex(e,t),{t:u.t,absoluteIJK:t}}return null}const{staticOffsetAPI:Db,otherStaticMethods:Lb}=bl,{SlicingMode:Bb}=af;const Nb={slicingMode:Bb.NONE,closestIJKAxis:{ijkMode:Bb.NONE,flip:!1},renderToRectangle:!1,sliceAtFocalPoint:!1,preferSizeOverAccuracy:!1};function Fb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Nb,n),Eb(e,t,n),Ht.get(e,t,["slicingMode"]),Ht.setGet(e,t,["closestIJKAxis","renderToRectangle","sliceAtFocalPoint","preferSizeOverAccuracy"]),bl.implementCoincidentTopologyMethods(e,t),function(e,t){function n(){let n;switch(t.slicingMode){case Bb.X:n=0;break;case Bb.Y:n=1;break;case Bb.Z:n=2;break;default:return void(t.closestIJKAxis={ijkMode:t.slicingMode,flip:!1})}const r=Ma(e.getCurrentImage().getDirection());let o=0;for(;o<3&&0===r[n+3*o];++o);const a=r[n+3*o]<0;t.closestIJKAxis={ijkMode:o,flip:a}}t.classHierarchy.push("vtkImageMapper"),e.getSliceAtPosition=n=>{const r=e.getCurrentImage();let o;if(3===n.length)o=n;else if(Number.isFinite(n)){const e=r.getBounds();switch(t.slicingMode){case Bb.X:o=[n,(e[3]+e[2])/2,(e[5]+e[4])/2];break;case Bb.Y:o=[(e[1]+e[0])/2,n,(e[5]+e[4])/2];break;case Bb.Z:o=[(e[1]+e[0])/2,(e[3]+e[2])/2,n]}}const a=[0,0,0];r.worldToIndex(o,a);const i=r.getExtent(),{ijkMode:s}=e.getClosestIJKAxis();let l=0;switch(s){case Bb.I:l=xa(a[0],i[0],i[1]);break;case Bb.J:l=xa(a[1],i[2],i[3]);break;case Bb.K:l=xa(a[2],i[4],i[5]);break;default:return 0}return l},e.setSliceFromCamera=n=>{const r=n.getFocalPoint();switch(t.slicingMode){case Bb.I:case Bb.J:case Bb.K:{const t=e.getSliceAtPosition(r);e.setSlice(t)}break;case Bb.X:e.setSlice(r[0]);break;case Bb.Y:e.setSlice(r[1]);break;case Bb.Z:e.setSlice(r[2])}},e.setXSlice=t=>{e.setSlicingMode(Bb.X),e.setSlice(t)},e.setYSlice=t=>{e.setSlicingMode(Bb.Y),e.setSlice(t)},e.setZSlice=t=>{e.setSlicingMode(Bb.Z),e.setSlice(t)},e.setISlice=t=>{e.setSlicingMode(Bb.I),e.setSlice(t)},e.setJSlice=t=>{e.setSlicingMode(Bb.J),e.setSlice(t)},e.setKSlice=t=>{e.setSlicingMode(Bb.K),e.setSlice(t)},e.getSlicingModeNormal=()=>{const n=[0,0,0],r=e.getCurrentImage().getDirection();switch(t.slicingMode){case Bb.X:n[0]=1;break;case Bb.Y:n[1]=1;break;case Bb.Z:n[2]=1;break;case Bb.I:jo(r,[1,0,0],n);break;case Bb.J:jo(r,[0,1,0],n);break;case Bb.K:jo(r,[0,0,1],n)}return n},e.setSlicingMode=r=>{t.slicingMode!==r&&(t.slicingMode=r,e.getCurrentImage()&&n(),e.modified())},e.getClosestIJKAxis=()=>(void 0!==t.closestIJKAxis&&t.closestIJKAxis.ijkMode!==Bb.NONE||!e.getCurrentImage()||n(),t.closestIJKAxis),e.getBounds=()=>{const n=e.getCurrentImage();if(!n)return Ra();if(!t.useCustomExtents)return n.getBounds();const r=t.customDisplayExtent.slice(),{ijkMode:o}=e.getClosestIJKAxis();let a=t.slice;switch(o!==t.slicingMode&&(a=e.getSliceAtPosition(t.slice)),o){case Bb.I:r[0]=a,r[1]=a;break;case Bb.J:r[2]=a,r[3]=a;break;case Bb.K:r[4]=a,r[5]=a}return n.extentToBounds(r)},e.getBoundsForSlice=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.slice,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const o=e.getCurrentImage();if(!o)return Ra();const a=o.getSpatialExtent(),{ijkMode:i}=e.getClosestIJKAxis();let s=n;switch(i!==t.slicingMode&&(s=e.getSliceAtPosition(n)),i){case Bb.I:a[0]=s-r,a[1]=s+r;break;case Bb.J:a[2]=s-r,a[3]=s+r;break;case Bb.K:a[4]=s-r,a[5]=s+r}return o.extentToBounds(a)},e.intersectWithLineForPointPicking=(t,n)=>function(e,t,n){const r=Vb(e,t,n);if(r){const e=n.getCurrentImage().getExtent(),t=[Math.round(r.absoluteIJK[0]),Math.round(r.absoluteIJK[1]),Math.round(r.absoluteIJK[2])];return t[0]<e[0]||t[0]>e[1]||t[1]<e[2]||t[1]>e[3]||t[2]<e[4]||t[2]>e[5]?null:{t:r.t,ijk:t}}return null}(t,n,e),e.intersectWithLineForCellPicking=(t,n)=>function(e,t,n){const r=Vb(e,t,n);if(r){const e=n.getCurrentImage().getExtent(),t=r.absoluteIJK,o=[Math.floor(t[0]),Math.floor(t[1]),Math.floor(t[2])];if(o[0]<e[0]||o[0]>e[1]-1||o[1]<e[2]||o[1]>e[3]-1||o[2]<e[4]||o[2]>(e[5]?e[5]-1:e[5]))return null;const a=[t[0]-o[0],t[1]-o[1],t[2]-o[2]];return{t:r.t,ijk:o,pCoords:a}}return null}(t,n,e),e.getCurrentImage=()=>e.getInputData()}(e,t)}var _b={newInstance:Ht.newInstance(Fb,"vtkImageMapper"),extend:Fb,...Db,...Lb,...af};const{vtkErrorMacro:kb}=Ht;function Gb(e,t,n,r){e.set(function(e,t){let n=0;return e.map(((e,r)=>r===n?(n+=e+1,e):e+t))}(t,n),r)}const Ub={outputPointsPrecision:Os.DEFAULT};function zb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ub,n),Ht.setGet(e,t,["outputPointsPrecision"]),Ht.obj(e,t),Ht.algo(e,t,1,1),function(e,t){t.classHierarchy.push("vtkAppendPolyData"),e.requestData=(n,r)=>{const o=e.getNumberOfInputPorts();if(!o)return void kb("No input specified.");if(1===o)return void(r[0]=n[0]);const a=kc.newInstance();let i=0,s=0,l=1,c=1,u=0,d=0,p=0,f=0,g=!0,m=!0,h=!0;for(let e=0;e<o;e++){const t=n[e];if(!t)continue;const r=t.getPoints().getNumberOfPoints();i+=r,u+=t.getVerts().getNumberOfValues(),d+=t.getLines().getNumberOfValues(),p+=t.getStrips().getNumberOfValues(),f+=t.getPolys().getNumberOfValues(),r&&(c&&(c=0,s=t.getPoints().getDataType()),l=t.getPoints().getDataType(),s=s>l?s:l);const o=t.getPointData();o?(g=g&&null!==o.getNormals(),m=m&&null!==o.getTCoords(),h=h&&null!==o.getScalars()):(g=!1,m=!1,h=!1)}t.outputPointsPrecision===Os.SINGLE?s=is.FLOAT:t.outputPointsPrecision===Os.DOUBLE&&(s=is.DOUBLE);const v=$l.newInstance({dataType:s});v.setNumberOfPoints(i);const T=v.getData(),y=new Uint32Array(u),b=new Uint32Array(d),x=new Uint32Array(p),C=new Uint32Array(f);let S=null,A=null,I=null;const w=n[o-1];if(g){const e=w.getPointData().getNormals();S=Ts.newInstance({numberOfComponents:3,numberOfTuples:i,size:3*i,dataType:e.getDataType(),name:e.getName()})}if(m){const e=w.getPointData().getTCoords();A=Ts.newInstance({numberOfComponents:2,numberOfTuples:i,size:2*i,dataType:e.getDataType(),name:e.getName()})}if(h){const e=w.getPointData().getScalars();I=Ts.newInstance({numberOfComponents:e.getNumberOfComponents(),numberOfTuples:i,size:i*e.getNumberOfComponents(),dataType:e.getDataType(),name:e.getName()})}i=0,u=0,d=0,p=0,f=0;for(let e=0;e<o;e++){const t=n[e];T.set(t.getPoints().getData(),3*i),Gb(y,t.getVerts().getData(),i,u),u+=t.getVerts().getNumberOfValues(),Gb(b,t.getLines().getData(),i,d),d+=t.getLines().getNumberOfValues(),Gb(x,t.getStrips().getData(),i,p),p+=t.getStrips().getNumberOfValues(),Gb(C,t.getPolys().getData(),i,f),f+=t.getPolys().getNumberOfValues();const r=t.getPointData();if(g){const e=r.getNormals();S.getData().set(e.getData(),3*i)}if(m){const e=r.getTCoords();A.getData().set(e.getData(),2*i)}if(h){const e=r.getScalars();I.getData().set(e.getData(),i*I.getNumberOfComponents())}i+=t.getPoints().getNumberOfPoints()}a.setPoints(v),a.getVerts().setData(y),a.getLines().setData(b),a.getStrips().setData(x),a.getPolys().setData(C),S&&a.getPointData().setNormals(S),A&&a.getPointData().setTCoords(A),I&&a.getPointData().setScalars(I),r[0]=a}}(e,t)}var Wb={newInstance:Ht.newInstance(zb,"vtkAppendPolyData"),extend:zb};const Hb={height:1,radius:.5,resolution:6,center:[0,0,0],direction:[1,0,0],capping:!0,pointType:"Float64Array"};function jb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Hb,n),Ht.obj(e,t),Ht.setGet(e,t,["height","radius","resolution","capping"]),Ht.setGetArray(e,t,["center","direction"],3),Ht.algo(e,t,0,1),function(e,t){t.classHierarchy.push("vtkConeSource"),e.requestData=function(e,n){if(t.deleted)return;let r=n[0];const o=2*Math.PI/t.resolution,a=-t.height/2,i=t.resolution+1,s=4*t.resolution+1+t.resolution;let l=0;const c=Ht.newTypedArray(t.pointType,3*i);let u=0;const d=new Uint32Array(s);c[0]=t.height/2,c[1]=0,c[2]=0,t.capping&&(d[u++]=t.resolution);for(let e=0;e<t.resolution;e++)l++,c[3*l+0]=a,c[3*l+1]=t.radius*Math.cos(e*o),c[3*l+2]=t.radius*Math.sin(e*o),t.capping&&(d[t.resolution-u+++1]=l);for(let e=0;e<t.resolution;e++)d[u++]=3,d[u++]=0,d[u++]=e+1,d[u++]=e+2>t.resolution?1:e+2;Fp().translate(...t.center).rotateFromDirections([1,0,0],t.direction).apply(c),r=kc.newInstance(),r.getPoints().setData(c,3),r.getPolys().setData(d,1),n[0]=r}}(e,t)}var Kb={newInstance:Ht.newInstance(jb,"vtkConeSource"),extend:jb};const $b={height:1,initAngle:0,radius:1,resolution:6,center:[0,0,0],direction:[0,1,0],capping:!0,pointType:"Float64Array"};function qb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,$b,n),Ht.obj(e,t),Ht.setGet(e,t,["height","initAngle","otherRadius","radius","resolution","capping"]),Ht.setGetArray(e,t,["center","direction"],3),Ht.algo(e,t,0,1),function(e,t){t.classHierarchy.push("vtkCylinderSource"),e.requestData=function(e,n){if(t.deleted)return;let r=n[0];const o=2*Math.PI/t.resolution;let a=2*t.resolution,i=5*t.resolution;t.capping&&(a=4*t.resolution,i=7*t.resolution+2);const s=Ht.newTypedArray(t.pointType,3*a);let l=0;const c=new Uint32Array(i),u=new Float32Array(3*a),d=Ts.newInstance({numberOfComponents:3,values:u,name:"Normals"}),p=new Float32Array(2*a),f=Ts.newInstance({numberOfComponents:2,values:p,name:"TCoords"}),g=[0,0,0],m=[0,0,0],h=[0,0,0],v=[0,0,0],T=[0,0],y=[0,0],b=null==t.otherRadius?t.radius:t.otherRadius;for(let e=0;e<t.resolution;e++){g[0]=Math.cos(e*o+t.initAngle),m[0]=g[0],h[0]=t.radius*g[0]+t.center[0],v[0]=h[0],T[0]=Math.abs(2*e/t.resolution-1),y[0]=T[0],h[1]=.5*t.height+t.center[1],v[1]=-.5*t.height+t.center[1],T[1]=0,y[1]=1,g[2]=-Math.sin(e*o+t.initAngle),m[2]=g[2],h[2]=b*g[2]+t.center[2],v[2]=h[2];const n=2*e;for(let e=0;e<3;e++)u[3*n+e]=g[e],u[3*(n+1)+e]=m[e],s[3*n+e]=h[e],s[3*(n+1)+e]=v[e],e<2&&(p[2*n+e]=T[e],p[2*(n+1)+e]=y[e])}for(let e=0;e<t.resolution;e++){c[l++]=4,c[l++]=2*e,c[l++]=2*e+1;const n=(2*e+3)%(2*t.resolution);c[l++]=n,c[l++]=n-1}if(t.capping){for(let e=0;e<t.resolution;e++){h[0]=t.radius*Math.cos(e*o+t.initAngle),v[0]=h[0],T[0]=h[0],y[0]=h[0],h[0]+=t.center[0],v[0]+=t.center[0],g[1]=1,m[1]=-1,h[1]=.5*t.height+t.center[1],v[1]=-.5*t.height+t.center[1],h[2]=-b*Math.sin(e*o+t.initAngle),v[2]=h[2],T[1]=h[2],y[1]=h[2],h[2]+=t.center[2],v[2]+=t.center[2];const n=2*t.resolution+e,r=3*t.resolution+t.resolution-e-1;for(let e=0;e<3;e++)u[3*n+e]=g[e],u[3*r+e]=m[e],s[3*n+e]=h[e],s[3*r+e]=v[e],e<2&&(p[2*n+e]=T[e],p[2*r+e]=y[e])}c[l++]=t.resolution;for(let e=0;e<t.resolution;e++)c[l++]=2*t.resolution+e;c[l++]=t.resolution;for(let e=0;e<t.resolution;e++)c[l++]=3*t.resolution+e}Fp().translate(...t.center).rotateFromDirections([0,1,0],t.direction).translate(...t.center.map((e=>-1*e))).apply(s),r=kc.newInstance(),r.getPoints().setData(s,3),r.getPolys().setData(c,1),r.getPointData().setNormals(d),r.getPointData().setTCoords(f),n[0]=r}}(e,t)}var Xb={newInstance:Ht.newInstance(qb,"vtkCylinderSource"),extend:qb};const Yb={tipResolution:6,tipRadius:.1,tipLength:.35,shaftResolution:6,shaftRadius:.03,invert:!1,direction:[1,0,0],pointType:"Float64Array"};function Zb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Yb,n),Ht.obj(e,t),Ht.setGet(e,t,["tipResolution","tipRadius","tipLength","shaftResolution","shaftRadius","invert"]),Ht.setGetArray(e,t,["direction"],3),Ht.algo(e,t,0,1),function(e,t){t.classHierarchy.push("vtkArrowSource"),e.requestData=function(e,n){if(t.deleted)return;const r=Xb.newInstance({capping:!0});r.setResolution(t.shaftResolution),r.setRadius(t.shaftRadius),r.setHeight(1-t.tipLength),r.setCenter(0,.5*(1-t.tipLength),0);const o=r.getOutputData(),a=o.getPoints().getData(),i=o.getPointData().getNormals().getData();Np().rotateZ(-90).apply(a).apply(i);const s=Kb.newInstance();s.setResolution(t.tipResolution),s.setHeight(t.tipLength),s.setRadius(t.tipRadius);const l=s.getOutputData(),c=l.getPoints().getData();Fp().translate(1-.5*t.tipLength,0,0).apply(c);const u=Wb.newInstance();u.setInputData(o),u.addInputData(l);const d=u.getOutputData(),p=d.getPoints().getData();Fp().translate(.5*t.tipLength-.5,0,0).apply(p),t.invert?(Fp().rotateFromDirections([1,0,0],t.direction).scale(-1,-1,-1).apply(p),n[0]=d):(Fp().rotateFromDirections([1,0,0],t.direction).scale(1,1,1).apply(p),n[0]=u.getOutputData())}}(e,t)}var Qb={newInstance:Ht.newInstance(Zb,"vtkArrowSource"),extend:Zb};function Jb(e){const t=e.getPoints().getBounds(),n=[.5*-(t[0]+t[1]),.5*-(t[2]+t[3]),.5*-(t[4]+t[5])];Np().translate(...n).apply(e.getPoints().getData())}function ex(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r=e.getPoints().getBounds(),o=[0,0,0];o[t]=n?-r[2*t+1]:-r[2*t],Np().translate(...o).apply(e.getPoints().getData())}function tx(e,t,n,r){const o=e.getPoints().getData().length,a=new Uint8ClampedArray(o);let i=0;for(;i<o;)a[i++]=t,a[i++]=n,a[i++]=r;e.getPointData().setScalars(Ts.newInstance({name:"color",numberOfComponents:3,values:a}))}function nx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};os.extend(e,t,function(e){return{config:{recenter:!0,tipResolution:60,tipRadius:.1,tipLength:.2,shaftResolution:60,shaftRadius:.03,invert:!1,...e?.config},xConfig:{color:[255,0,0],invert:!1,...e?.xConfig},yConfig:{color:[255,255,0],invert:!1,...e?.yConfig},zConfig:{color:[0,128,0],invert:!1,...e?.zConfig}}}(n)),Ht.setGet(e,t,["config","xConfig","yConfig","zConfig"]),function(e,t){t.classHierarchy.push("vtkAxesActor");const n=Fl.newInstance();e.setMapper(n),e.update=()=>{let e={...t.config,...t.xConfig};const r=Qb.newInstance({direction:[1,0,0],...e}).getOutputData();t.config.recenter?Jb(r):ex(r,0,e.invert),tx(r,...e.color),e={...t.config,...t.yConfig};const o=Qb.newInstance({direction:[0,1,0],...e}).getOutputData();t.config.recenter?Jb(o):ex(o,1,e.invert),tx(o,...e.color),e={...t.config,...t.zConfig};const a=Qb.newInstance({direction:[0,0,1],...e}).getOutputData();t.config.recenter?Jb(a):ex(a,2,e.invert),tx(a,...e.color);const i=Wb.newInstance();i.setInputData(r),i.addInputData(o),i.addInputData(a),n.setInputConnection(i.getOutputPort())},e.update();const r=Ht.debounce(e.update,0);e.setXAxisColor=t=>e.setXConfig({...e.getXConfig(),color:t}),e.setYAxisColor=t=>e.setYConfig({...e.getYConfig(),color:t}),e.setZAxisColor=t=>e.setZConfig({...e.getZConfig(),color:t}),e.getXAxisColor=()=>t.getXConfig().color,e.getYAxisColor=()=>t.getYConfig().color,e.getZAxisColor=()=>t.getZConfig().color,t._onConfigChanged=r,t._onXConfigChanged=r,t._onYConfigChanged=r,t._onZConfigChanged=r}(e,t)}var rx={newInstance:Ht.newInstance(nx,"vtkAxesActor"),extend:nx};const ox="resetcamera",ax="orientation",ix={MODE_RESET_CAMERA:ox,MODE_ORIENTATION:ax,MODE_SAME:"same"};const sx={mode:ax,focalPoint:[0,0,0],distance:6.8,active:!0};function lx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,sx,n),vt(e,t),St(e,t,["mode","active","srcRenderer","dstRenderer","distance"]),wt(e,t,["focalPoint"],3,0),function(e,t){t.classHierarchy.push("vtkCameraSynchronizer");const n=new Float64Array(9),r=new Float64Array(3),o=[];function a(){for(;o.length;)o.pop().unsubscribe();if(!t.srcRenderer||!t.dstRenderer)return;const n=t.srcRenderer.getActiveCamera(),r=t.srcRenderer.getRenderWindow().getInteractor();o.push(n.onModified((()=>{r.isAnimating()||e.update()}))),o.push(r.onAnimation(e.update)),o.push(r.onEndAnimation(e.update))}t._onSrcRendererChanged=a,t._onDstRendererChanged=a,e.update=()=>{if(!t.active||!t.srcRenderer||!t.dstRenderer)return;const e=t.srcRenderer.getActiveCamera(),o=t.dstRenderer.getActiveCamera(),a=(i=e.getReferenceByName("position"),s=e.getReferenceByName("focalPoint"),l=e.getReferenceByName("viewUp"),(n[0]!==i[0]||n[1]!==i[1]||n[2]!==i[2]||n[3]!==s[0]||n[4]!==s[1]||n[5]!==s[2]||n[6]!==l[0]||n[7]!==l[1]||n[8]!==l[2])&&(n[0]=i[0],n[1]=i[1],n[2]=i[2],n[3]=s[0],n[4]=s[1],n[5]=s[2],n[6]=l[0],n[7]=l[1],n[8]=l[2],n));var i,s,l;a&&(t.mode===ax?(r[0]=a[0]-a[3],r[1]=a[1]-a[4],r[2]=a[2]-a[5],ko(r),o.setPosition(t.focalPoint[0]+t.distance*r[0],t.focalPoint[1]+t.distance*r[1],t.focalPoint[2]+t.distance*r[2]),o.setFocalPoint(t.focalPoint[0],t.focalPoint[1],t.focalPoint[2]),o.setViewUp(a[6],a[7],a[8])):(o.setPosition(a[0],a[1],a[2]),o.setFocalPoint(a[3],a[4],a[5]),o.setViewUp(a[6],a[7],a[8])),t.mode===ox&&t.dstRenderer.resetCamera())},e.delete=Vt((()=>e.setSrcRenderer(null)),e.delete),a()}(e,t)}var cx={newInstance:Et(lx,"vtkCameraSynchronizer"),extend:lx,SynchronizationMode:ix};const ux={},dx={CameraSync:class{constructor(e,t){this.ctx=e,this.behavior=cx.newInstance(this.getProperties(t)),this.behavior.update()}getProperties(e){let{actorBounds:t,srcRenderer:n,dstRenderer:r}=e;return{distance:3.4*Math.max(t[1]-t[0],t[3]-t[2],t[5]-t[4]),focalPoint:[.5*(t[0]+t[1]),.5*(t[2]+t[3]),.5*(t[4]+t[5])],mode:cx.SynchronizationMode.MODE_ORIENTATION,srcRenderer:this.ctx.getInstance(n),dstRenderer:this.ctx.getInstance(r)}}update(e){this.behavior.set(this.getProperties(e)),this.behavior.update()}delete(){this.behavior.delete()}}};var px=function(e,t,n){const r=e.get("synchronizedViewId").synchronizedViewId;if(!t.behaviors||!r)return;ux[r]||(ux[r]={});const o=ux[r];if(t.behaviors.autoOrientation){const t=e.getRenderers();if(!o.autoOrientationAxes&&2===t.length){let e=null,n=null;for(let r=0;r<t.length;r++){const o=t[r];o.getInteractive()?e=o:n=o}e&&n&&(o.autoOrientationAxes=cx.newInstance({srcRenderer:e,dstRenderer:n}))}o.autoOrientationAxes&&2!==t.length&&(o.autoOrientationAxes.delete(),delete o.autoOrientationAxes)}const a=Object.keys(t.behaviors),i=Object.keys(o);for(let e=0;e<a.length;e++){const r=a[e];if(o[r])o[r].update(t.behaviors[r]);else{const e=t.behaviors[r];dx[e.type]?o[r]=new dx[e.type](n,e):console.log("No mapping for",e)}}for(let e=0;e<i.length;e++){const n=a[e];t.behaviors[n]||(o[n].delete(),delete o[n])}};const fx={},gx=/instance:\${([^}]+)}/,mx={},hx=[],vx={},Tx={vtkPoints:$l,vtkCellArray:zl,vtkDataArray:Ts};function yx(e){return e.map((e=>gx.exec(e))).filter((e=>e)).map((e=>e[1]))}function bx(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return e.dependencies&&e.dependencies.forEach((e=>{t.push(e.id),bx(e,t)})),t}function xx(e,t,n,r){if(!t)return Promise.reject(new Error("No instance provided."));const o=fx[e];return o&&o.update?o.update(t,n,r):Promise.reject(new Error(`No updater for ${e}`))}function Cx(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=fx[e];return n&&n.build?n.build(t):(console.log("No builder for",e),null)}function Sx(){Object.keys(fx).forEach((e=>{delete fx[e]}))}function Ax(e){if(1===e[1].length)return-1===hx.indexOf(e[1][0]);let t=!1;for(let n=0;n<e[1].length;n++)t=t||-1===hx.indexOf(e[1][n]);return t}function Ix(e,t,n){n.start(),e.set(t.properties),t.dependencies&&t.dependencies.forEach((e=>{const{id:t,type:r}=e;if(vx[r]){const{key:n,value:o}=vx[r];if(!n||e.properties[n]===o)return void hx.push((e=>`instance:\${${e}}`)(t))}let o=n.getInstance(t);o||(o=Cx(r,{managedInstanceId:t}),n.registerInstance(t,o)),xx(r,o,e,n)})),t.calls&&t.calls.filter(Ax).forEach((t=>{var r;e[t[0]].apply(null,(r=n,t[1].map((e=>{const t=gx.exec(e);return t?r.getInstance(t[1]):e}))))}));const r=[];if(t.arrays){const o=[],a=Object.values(t.arrays).map((t=>(n.start(),n.getArray(t.hash,t.dataType,n).then(function(e,t,n){return r=>{const o=t.registration?t.registration:"addArray",a=t.location?e.getReferenceByName(t.location):e;let i=null;if(i=t.location?e.getReferenceByName(t.location).getArray(t.name):e[`get${o.substring(3)}`](),i)return i.getData()!==r&&n.push([i.setData,[r,t.numberOfComponents]]),i;const s=t.vtkClass?t.vtkClass:"vtkDataArray",l=Tx[s].newInstance({...t,values:r});return n.push([a[o],[l]]),l}}(e,t,o)).catch((e=>{console.log("Error fetching array",JSON.stringify(t),e)})).finally(n.end))));n.start(),r.push(Promise.all(a).then((()=>(o.length&&e.modified(),function(e){for(;e.length;){const[t,n]=e.shift();t(...n)}}(o),!0))).catch((e=>{console.error("Error in array handling for state",JSON.stringify(t),e)})).finally(n.end))}return n.end(),Promise.all(r)}function wx(e,t,n){mx[t.id]||Ix(e,t,n),mx[t.id]=!0}function Ox(e,t){const n=[],r=e.getNumberOfArrays();for(let o=0;o<r;o++){const r=e.getArray(o).getName();t.has(r)||n.push(r)}for(let t=0;t<n.length;t++)e.removeArray(n[t])}function Px(e){const t=e.name?`_${e.name}`:"";return`${e.hash}_${e.dataType}${t}`}function Rx(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return(t,n,r)=>{r.start();const o={...n.properties};n.arrays||(n.arrays={});for(let t=0;t<e.length;t++){const r=e[t];if(n.properties[r]){const e=n.properties[r];e.registration=`set${lt(r)}`;const t=Px(e);n.arrays[t]=e,delete o[r]}}const a=n.properties.fields||[];for(let e=0;e<a.length;e++){const t=a[e],r=Px(t);n.arrays[r]=t}delete o.fields;const i={pointData:new Set,cellData:new Set,fieldData:new Set};a.forEach((e=>{let{location:t,name:n}=e;i[t].add(n)})),Ox(t.getPointData(),i.pointData),Ox(t.getCellData(),i.cellData);const s={...n};s.properties=o;const l=Ix(t,s,r);return r.end(),l}}const Mx=Rx(["points","polys","verts","lines","strips"]),Ex=Rx([]);function Vx(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Ix;Cx||xx?fx[e]={build:t,update:n}:delete fx[e]}const Dx={vtkMapper:["vtkOpenGLPolyDataMapper","vtkCompositePolyDataMapper2","vtkDataSetMapper"],vtkProperty:["vtkOpenGLProperty"],vtkRenderer:["vtkOpenGLRenderer"],vtkCamera:["vtkOpenGLCamera"],vtkColorTransferFunction:["vtkPVDiscretizableColorTransferFunction"],vtkActor:["vtkOpenGLActor","vtkPVLODActor"],vtkLight:["vtkOpenGLLight","vtkPVLight"],vtkTexture:["vtkOpenGLTexture"],vtkImageMapper:["vtkOpenGLImageSliceMapper"],vtkVolumeMapper:["vtkFixedPointVolumeRayCastMapper"]},Lx={vtkAxesActor:{build:rx.newInstance,update:Ix},vtkRenderWindow:{build:zm.newInstance,update:function(e,t,n){t.calls&&t.calls.filter(Ax).filter((e=>"removeRenderer"===e[0])).forEach((e=>{yx(e[1]).forEach((e=>{n.getInstance(e).getViewProps().forEach((e=>{const t=e.get("flattenedDepIds").flattenedDepIds;t&&t.forEach((e=>n.unregisterInstance(e))),n.unregisterInstance(n.getInstanceId(e))}))}))})),e.render(),Ix(e,t,n),px(e,t,n)}},vtkRenderer:{build:Nm.newInstance,update:function(e,t,n){Ix(e,t,n);const r=new Set;t.dependencies&&t.dependencies.forEach((e=>{const t=n.getInstance(e.id);if(t){const n=bx(e);t.set({flattenedDepIds:n},!0),n.forEach((e=>r.add(e)))}}));const o=new Set;t.calls&&t.calls.filter(Ax).filter((e=>"removeViewProp"===e[0])).forEach((e=>{yx(e[1]).forEach((e=>{const t=n.getInstance(e).get("flattenedDepIds").flattenedDepIds;t&&t.forEach((e=>o.add(e))),o.add(e)}))})),[...o].filter((e=>!r.has(e))).forEach((e=>n.unregisterInstance(e)))}},vtkLookupTable:{build:ul.newInstance,update:Ix},vtkCamera:{build:Cm.newInstance,update:wx},vtkPolyData:{build:kc.newInstance,update:Mx},vtkImageData:{build:Ks.newInstance,update:Ex},vtkMapper:{build:Fl.newInstance,update:Ix},vtkGlyph3DMapper:{build:rb.newInstance,update:Ix},vtkProperty:{build:ts.newInstance,update:Ix},vtkActor:{build:os.newInstance,update:Ix},vtkLight:{build:Im.newInstance,update:Ix},vtkColorTransferFunction:{build:Yy.newInstance,update:function(e,t,n){if(n.start(),t.properties.nodes){const n=t.properties.nodes.map((e=>{let[t,n,r,o,a,i]=e;return{x:t,r:n,g:r,b:o,midpoint:a,sharpness:i}}));e.set({...t.properties,nodes:n},!0)}else e.set(t.properties);n.end()}},vtkTexture:{build:zc.newInstance,update:Ix},vtkVolume:{build:vb.newInstance,update:Ix},vtkVolumeMapper:{build:Cb.newInstance,update:Ix},vtkVolumeProperty:{build:gb.newInstance,update:Ix},vtkImageSlice:{build:Rb.newInstance,update:Ix},vtkImageMapper:{build:_b.newInstance,update:Ix},vtkImageProperty:{build:wb.newInstance,update:Ix},vtkPiecewiseFunction:{build:sb.newInstance,update:function(e,t,n){if(n.start(),t.properties.nodes){const n=t.properties.nodes.map((e=>{let[t,n,r,o]=e;return{x:t,y:n,midpoint:r,sharpness:o}}));e.set({...t.properties,nodes:n},!0),e.sortAndUpdateRange()}else e.set(t.properties);n.end()}},vtkCubeAxesActor:{build:au.newInstance,update:Ix},vtkScalarBarActor:{build:kd.newInstance,update:Ix}};function Bx(){(!(arguments.length>0&&void 0!==arguments[0])||arguments[0])&&Sx(),Object.keys(Lx).forEach((e=>{const t=Lx[e];Vx(e,t.build,t.update)}))}function Nx(){Object.keys(Dx).forEach((e=>{Dx[e].forEach((t=>{fx[t]=fx[e]}))}))}Bx(),Nx(),vx.vtkPVLight={};var Fx={build:Cx,update:xx,genericUpdater:Ix,oneTimeGenericUpdater:wx,setTypeMapping:Vx,clearTypeMapping:Sx,getSupportedTypes:function(){return Object.keys(fx)},clearOneTimeUpdaters:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];if(0===t.length)return void Object.keys(mx).forEach((e=>{delete mx[e]}));let r=t;return 1===r.length&&Array.isArray(r[0])&&(r=r[0]),r.forEach((e=>{delete mx[e]})),r},updateRenderWindow:function(e,t,n){return xx("vtkRenderWindow",e,t,n)},excludeInstance:function(e,t,n){vx[e]={key:t,value:n}},setDefaultMapping:Bx,applyDefaultAliases:Nx,alwaysUpdateCamera:function(){Vx("vtkCamera",Cm.newInstance),Nx()}};const _x={};function kx(){const e={};let t=null;return{setFetchArrayFunction:function(e){t=e},getArray:function(n,r,o){const a=e[n];return a?(a.mtimes[o.getActiveViewId()]=o.getMTime(),new Promise(((e,t)=>{e(a.array)}))):t?new Promise(((a,i)=>{t(n).then((t=>{let i=t;if("string"==typeof t&&(i=yg.toArrayBuffer(t)),i instanceof Blob){const t=new FileReader;t.onload=()=>{const i=it(r,t.result),s={[o.getActiveViewId()]:o.getMTime()};e[n]={mtimes:s,array:i},a(i)},t.readAsArrayBuffer(i)}else{const t=it(r,i),s={[o.getActiveViewId()]:o.getMTime()};e[n]={mtimes:s,array:t},a(t)}}),(e=>{console.log("Error getting data array:"),console.log(e),i(e)}))})):Promise.reject(new Error('No array fetcher found, please use "setArrayFetcher" to provide one'))},emptyCachedArrays:function(){Object.keys(e).forEach((t=>{delete e[t]}))},freeOldArrays:function(t,n){const r=n.getMTime()-t;Object.keys(e).filter((t=>e[t].mtimes[n.getActiveViewId()])).filter((t=>e[t].mtimes[n.getActiveViewId()]<r)).forEach((t=>{delete e[t]}))}}}function Gx(){const e={};return{getInstance:function(t){return e[t]},getInstanceId:function(t){let n=null;return Object.keys(e).forEach((r=>{t===e[r]&&(n=r)})),n},registerInstance:function(t,n){e[t]=n,n.set({remoteId:t},!0,!0)},unregisterInstance:function(t){delete e[t]},emptyCachedInstances:function(){Object.keys(e).forEach((t=>{delete e[t]}))}}}function Ux(){let e=0;const t={start(){e+=1,t.invokeProgressEvent(e)},end(){e-=1,t.invokeProgressEvent(e),0===e&&t.invokeProgressDone()},resetProgress(){e=0}},n={};return Mt(t,n,"progressEvent"),Mt(t,n,"progressDone"),t}function zx(){const e={};let t="default";return{getMTime:function(n){return e[n||t]||1},incrementMTime:function(n){const r=n||t;e[r]||(e[r]=1),e[r]+=1},setActiveViewId:function(e){t=e},getActiveViewId:function(){return t}}}function Wx(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"default",t=_x[e];return t||(t={...kx(),...Gx(),...Ux(),...zx()},_x[e]=t),t}function Hx(e,t){let n=-1,r=100;const o=e=>e.get("managedInstanceId").managedInstanceId,a=()=>Lt(e,o);function i(t){e.set({synchronizedViewId:t},!0,!0)}function s(){return e.get("synchronizedViewId").synchronizedViewId}return{synchronize:function(o){s()||i(o.id);const a=o.mtime||0;return s()===o.id&&n<a?new Promise(((i,s)=>{const l=t.onProgressDone((()=>{l.unsubscribe(),e.render(),i(!0)}));n=a,t.setActiveViewId(o.id),t.incrementMTime(),Fx.updateRenderWindow(e,o,t),t.freeOldArrays(r,t)})):Promise.resolve(!1)},setSynchronizedViewId:i,getSynchronizedViewId:s,updateGarbageCollectorThreshold:function(e){r=e},getManagedInstanceIds:a,clearOneTimeUpdaters:function(){Fx.clearOneTimeUpdaters(a())}}}const jx={synchronizerContextName:"default",synchronizerContext:null,synchronizedViewId:null};function Kx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,jx,n),zm.extend(e,t),yt(e,t,["synchronizerContext"]),function(e,t){t.classHierarchy.push("vtkSynchronizableRenderWindow"),t.synchronizerContext||(t.synchronizerContext=Wx(t.synchronizerContextName));const n=Hx(e,t.synchronizerContext);Object.keys(n).forEach((t=>{e[t]?e[t]=Vt(e[t],n[t]):e[t]=n[t]}))}(e,t)}var $x={newInstance:Et(Kx,"vtkSynchronizableRenderWindow"),extend:Kx,getSynchronizerContext:Wx,setSynchronizerContext:function(e,t){_x[e]=t},clearSynchronizerContext:function(e){if(e&&_x[e]&&delete _x[e],!e){const e=Object.keys(_x);for(let t=0;t<e.length;t++)delete _x[e[t]]}},decorate:function(e){const t=Hx(e,Wx(arguments.length>1&&void 0!==arguments[1]?arguments[1]:"default"));return{...t,...e,delete:Vt(e.delete,t.delete)}},createInstanceMap:Gx,createArrayHandler:kx,createProgressHandler:Ux,createSceneMtimeHandler:zx,vtkObjectManager:Fx};const{vtkErrorMacro:qx,vtkDebugMacro:Xx}=Ht;let Yx=0;function Zx(e){const t=document.querySelector(`.webResource[data-url="${e}"]`);return t?t.innerHTML:null}function Qx(e){return"/"===e[0]?e.substr(1):e}const Jx={fetchJSON:function(e,t){return new Promise(((e,n)=>{const r=Zx(Qx(t));null===r?n(new Error(`No such JSON ${t}`)):e(JSON.parse(r))}))},fetchText:function(e,t){return new Promise(((e,n)=>{const r=Zx(t);null===r?n(new Error(`No such text ${t}`)):e(r)}))},fetchArray:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return new Promise(((o,a)=>{const i=Qx([t,n.ref.basepath,r.compression?`${n.ref.id}.gz`:n.ref.id].join("/")),s=Zx(i);if(null===s)a(new Error(`No such array ${i}`));else{if("string"===n.dataType){let e=atob(s);r.compression&&(e=im(rm(e))),n.values=JSON.parse(e)}else{const e=new Uint8Array(yg.toArrayBuffer(s));n.buffer=new ArrayBuffer(e.length),new Uint8Array(n.buffer).set(e),r.compression&&("string"===n.dataType||"JSON"===n.dataType?n.buffer=im(rm(new Uint8Array(n.buffer))):n.buffer=rm(new Uint8Array(n.buffer)).buffer),"JSON"===n.ref.encode?n.values=JSON.parse(n.buffer):(pm!==n.ref.encode&&pm&&(Xx(`Swap bytes of ${n.name}`),fm(n.buffer,as[n.dataType])),n.values=Ht.newTypedArray(n.dataType,n.buffer)),n.values.length!==n.size&&qx(`Error in FetchArray: ${n.name} does not have the proper array size. Got ${n.values.length}, instead of ${n.size}`)}delete n.ref,0==--Yx&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),o(n)}}))},fetchImage:function(e,t){return new Promise(((e,n)=>{const r=function(e){return document.querySelector(`.webResource[data-url="${e}"]`)}(t);r?e(r):n(new Error(`No such image ${t}`))}))}};xg("html",(e=>Jx));const{vtkErrorMacro:eC,vtkDebugMacro:tC}=Ht;function nC(e){return function(e){return"/"===e[0]?e.substr(1):e}(function(e){return new URL(e,"http://any").pathname}(e))}const rC=function(e){let t=!1,n=0,r=null,o="";var a;return(a=e.zipContent,new Promise(((e,t)=>{"string"==typeof a?e(function(e,t){if(t){for(var n=new Sg(e.length),r=0;r<e.length;++r)n[r]=e.charCodeAt(r);return n}if(om)return om.encode(e);var o=e.length,a=new Sg(e.length+(e.length>>1)),i=0,s=function(e){a[i++]=e};for(r=0;r<o;++r){if(i+5>a.length){var l=new Sg(i+8+(o-r<<1));l.set(a),a=l}var c=e.charCodeAt(r);c<128||t?s(c):c<2048?(s(192|c>>6),s(128|63&c)):c>55295&&c<57344?(s(240|(c=65536+(1047552&c)|1023&e.charCodeAt(++r))>>18),s(128|c>>12&63),s(128|c>>6&63),s(128|63&c)):(s(224|c>>12),s(128|c>>6&63),s(128|63&c))}return Kg(a,0,i)}(a)):a instanceof Blob?e(a.arrayBuffer().then((e=>new Uint8Array(e)))):a instanceof ArrayBuffer?e(new Uint8Array(a)):a?.buffer instanceof ArrayBuffer?e(new Uint8Array(a.buffer)):t(new Error("Invalid datatype to unpack."))}))).then((n=>{r=um(n),t=!0;const a=[];Object.keys(r).forEach((e=>{e.endsWith("index.json")&&a.push(e)})),a.sort(((e,t)=>e.length-t.length)),o=a[0].replace(/index\.json$/,""),e.callback&&e.callback(r)})),{fetchArray(e,a,i){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return new Promise(((l,c)=>{t||eC("ERROR!!! zip not ready...");const u=nC([a,i.ref.basepath,s.compression?`${i.ref.id}.gz`:i.ref.id].join("/"));function d(){delete i.ref,0==--n&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),l(i)}1==++n&&e?.invokeBusy&&e.invokeBusy(!0);const p=r[`${o}${u}`];if("string"!==i.dataType||s.compression){const e=function(e,t,n){return r=>{e.buffer=new ArrayBuffer(r.length),new Uint8Array(e.buffer).set(r),t&&("string"===e.dataType||"JSON"===e.dataType?e.buffer=im(rm(new Uint8Array(e.buffer))):e.buffer=rm(new Uint8Array(e.buffer)).buffer),"JSON"===e.ref.encode?e.values=JSON.parse(e.buffer):(pm!==e.ref.encode&&pm&&(tC(`Swap bytes of ${e.name}`),fm(e.buffer,as[e.dataType])),e.values=Ht.newTypedArray(e.dataType,e.buffer)),e.values.length!==e.size&&eC(`Error in FetchArray: ${e.name} does not have the proper array size. Got ${e.values.length}, instead of ${e.size}`),n()}}(i,s.compression,d);e(p)}else{const e=function(e,t,n){return r=>{e.values=t?JSON.parse(im(rm(r))):JSON.parse(r),n()}}(i,s.compression,d);e(im(p))}}))},fetchJSON(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=nC(n);t||eC("ERROR!!! zip not ready...");const s=r[`${o}${i}`];if(a.compression){if("gz"===a.compression){const e=im(rm(s));return Promise.resolve(JSON.parse(e))}return Promise.reject(new Error("Invalid compression"))}return Promise.resolve(JSON.parse(im(s)))},fetchText(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=nC(n);t||eC("ERROR!!! zip not ready...");const s=r[`${o}${i}`];return a.compression?"gz"===a.compression?Promise.resolve(im(um(s))):Promise.reject(new Error("Invalid compression")):Promise.resolve(im(s))},fetchImage(e,n){const a=nC(n);t||eC("ERROR!!! zip not ready...");const i=r[`${o}${a}`];return new Promise(((e,t)=>{const n=new Image;n.onload=()=>e(n),n.onerror=t;const r=Tg(i.buffer);n.src=`data:image/${function(e){const t=e.split(".").pop().toLowerCase();return"jpg"===t?"jpeg":t}(a)};base64,${r}`}))},fetchBinary(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=nC(n);t||eC("ERROR!!! zip not ready...");const s=r[`${o}${i}`];return a.compression?"gz"===a.compression?Promise.resolve(rm(s).buffer):Promise.reject(new Error("Invalid compression")):Promise.resolve(s.buffer)}}};xg("zip",(e=>rC(e)));var oC=n(911),aC=n.n(oC),iC=n(893),sC=n.n(iC),lC=n(383),cC=n.n(lC),uC=n(884),dC=n.n(uC),pC=n(88),fC=n.n(pC),gC=n(997),mC=n.n(gC),hC=n(96),vC={};vC.styleTagTransform=mC(),vC.setAttributes=dC(),vC.insert=cC().bind(null,"head"),vC.domAPI=sC(),vC.insertStyleElement=fC(),aC()(hC.A,vC);var TC=hC.A&&hC.A.locals?hC.A.locals:void 0;let yC=!0;function bC(e){e.preventDefault(),e.stopPropagation()}function xC(e,t){yC=!1,function(e){for(;e.firstChild;)e.removeChild(e.firstChild)}(e);const r=Fy.newInstance({background:[1,1,1],rootContainer:e,containerStyle:{height:"100%",width:"100%",position:"absolute"}}).getRenderWindow(),o=$x.getSynchronizerContext(),a=$x.decorate(r);function i(e){o.setFetchArrayFunction((t=>Promise.resolve(e.hashes[t].content))),console.log(Object.keys(e)),a.synchronize(e.scene),a.render()}if(n.g.renderWindow=r,t.fileURL||t.url){const n=document.createElement("div");n.setAttribute("class",TC.progress),e.appendChild(n);const r=e=>{if(e.lengthComputable){const t=Math.floor(100*e.loaded/e.total);n.innerHTML=`Loading ${t}%`}else n.innerHTML=Ht.formatBytesToProperUnit(e.loaded)};t.fileURL?Tm.fetchBinary(t.fileURL,{progressCallback:r}).then((t=>{e.removeChild(n);const r=Cg.get("zip",{zipContent:t,callback:e=>{r.fetchJSON(null,"index.json").then(i)}})})):Tm.fetchJSON(t.url,{progressCallback:r}).then((t=>{e.removeChild(n),i(t)}))}else if(t.file){const e=Cg.get("zip",{zipContent:t.file,callback:t=>{e.fetchJSON(null,"index.json").then(i)}})}else if(t.base64Str){const e=yg.toArrayBuffer(t.base64Str),n=Cg.get("zip",{zipContent:e,callback:e=>{n.fetchJSON(null,"index.json").then(i)}})}}function CC(e){yC=!1;const t=document.querySelector(".content"),n=document.querySelector("body"),r=e||t||n;r!==e?(r.classList.add(TC.fullScreen),n.style.margin="0",n.style.padding="0"):(n.style.margin="0",n.style.padding="0");const o=document.createElement("div");o.innerHTML=`<div class="${TC.bigFileDrop}"/><input type="file" accept=".zip,.vtksz" style="display: none;"/>`,r.appendChild(o);const a=o.querySelector("input");function i(e){bC(e);const t=e.dataTransfer,n=e.target.files||t.files;if(1===n.length){r.removeChild(o);const e=n[0].name.split(".").slice(-1)[0];xC(r,{file:n[0],ext:e})}}a.addEventListener("change",i),o.addEventListener("drop",i),o.addEventListener("click",(e=>a.click())),o.addEventListener("dragover",bC)}const SC=Sh();if(SC.url||SC.fileURL){const e=document.querySelector(".content"),t=document.querySelector("body"),n=e||t;n&&(n.classList.add(TC.fullScreen),t.style.margin="0",t.style.padding="0"),yC=!1,function(e){if(!window.frameElement)return e(),!0;window.frameElement.getClientRects().length>0?e():function(e,t){new window.parent.IntersectionObserver(((e,n)=>{e.forEach((e=>{e.intersectionRatio>0&&(t(),n.disconnect())}))})).observe(e)}(window.frameElement,e)}((()=>xC(n,SC)))}setTimeout((()=>{yC&&CC()}),100),window.OfflineLocalView={initLocalFileLoader:CC,load:xC}},613:function(e){"use strict";e.exports=function(e){var t=[];return t.toString=function(){return this.map((function(t){var n="",r=void 0!==t[5];return t[4]&&(n+="@supports (".concat(t[4],") {")),t[2]&&(n+="@media ".concat(t[2]," {")),r&&(n+="@layer".concat(t[5].length>0?" ".concat(t[5]):""," {")),n+=e(t),r&&(n+="}"),t[2]&&(n+="}"),t[4]&&(n+="}"),n})).join("")},t.i=function(e,n,r,o,a){"string"==typeof e&&(e=[[null,e,void 0]]);var i={};if(r)for(var s=0;s<this.length;s++){var l=this[s][0];null!=l&&(i[l]=!0)}for(var c=0;c<e.length;c++){var u=[].concat(e[c]);r&&i[u[0]]||(void 0!==a&&(void 0===u[5]||(u[1]="@layer".concat(u[5].length>0?" ".concat(u[5]):""," {").concat(u[1],"}")),u[5]=a),n&&(u[2]?(u[1]="@media ".concat(u[2]," {").concat(u[1],"}"),u[2]=n):u[2]=n),o&&(u[4]?(u[1]="@supports (".concat(u[4],") {").concat(u[1],"}"),u[4]=o):u[4]="".concat(o)),t.push(u))}},t}},336:function(e){"use strict";e.exports=function(e,t){return t||(t={}),e?(e=String(e.__esModule?e.default:e),/^['"].*['"]$/.test(e)&&(e=e.slice(1,-1)),t.hash&&(e+=t.hash),/["'() \t\n]|(%20)/.test(e)||t.needQuotes?'"'.concat(e.replace(/"/g,'\\"').replace(/\n/g,"\\n"),'"'):e):e}},20:function(e){"use strict";e.exports=function(e){return e[1]}},555:function(e,t,n){"use strict";var r=n(382),o="function"==typeof Symbol&&"symbol"==typeof Symbol("foo"),a=Object.prototype.toString,i=Array.prototype.concat,s=Object.defineProperty,l=s&&function(){var e={};try{for(var t in s(e,"x",{enumerable:!1,value:e}),e)return!1;return e.x===e}catch(e){return!1}}(),c=function(e,t,n,r){var o;(!(t in e)||"function"==typeof(o=r)&&"[object Function]"===a.call(o)&&r())&&(l?s(e,t,{configurable:!0,enumerable:!1,value:n,writable:!0}):e[t]=n)},u=function(e,t){var n=arguments.length>2?arguments[2]:{},a=r(t);o&&(a=i.call(a,Object.getOwnPropertySymbols(t)));for(var s=0;s<a.length;s+=1)c(e,a[s],t[a[s]],n[a[s]])};u.supportsDescriptors=!!l,e.exports=u},77:function(e,t,n){"use strict";e.exports=function(){if("object"==typeof globalThis)return globalThis;var e;try{e=this||new Function("return this")()}catch(e){if("object"==typeof window)return window;if("object"==typeof self)return self;if(void 0!==n.g)return n.g}return e}()},730:function(e){"use strict";e.exports=function e(t,n){if(t===n)return!0;if(t&&n&&"object"==typeof t&&"object"==typeof n){if(t.constructor!==n.constructor)return!1;var r,o,a;if(Array.isArray(t)){if((r=t.length)!=n.length)return!1;for(o=r;0!=o--;)if(!e(t[o],n[o]))return!1;return!0}if(t.constructor===RegExp)return t.source===n.source&&t.flags===n.flags;if(t.valueOf!==Object.prototype.valueOf)return t.valueOf()===n.valueOf();if(t.toString!==Object.prototype.toString)return t.toString()===n.toString();if((r=(a=Object.keys(t)).length)!==Object.keys(n).length)return!1;for(o=r;0!=o--;)if(!Object.prototype.hasOwnProperty.call(n,a[o]))return!1;for(o=r;0!=o--;){var i=a[o];if(!e(t[i],n[i]))return!1}return!0}return t!=t&&n!=n}},979:function(e){"use strict";"undefined"!=typeof self?e.exports=self:"undefined"!=typeof window?e.exports=window:e.exports=Function("return this")()},59:function(e,t,n){"use strict";var r=n(555),o=n(979),a=n(920),i=n(482),s=a(),l=function(){return s};r(l,{getPolyfill:a,implementation:o,shim:i}),e.exports=l},920:function(e,t,n){"use strict";var r=n(979);e.exports=function(){return"object"==typeof n.g&&n.g&&n.g.Math===Math&&n.g.Array===Array?n.g:r}},482:function(e,t,n){"use strict";var r=n(555),o=n(920);e.exports=function(){var e=o();if(r.supportsDescriptors){var t=Object.getOwnPropertyDescriptor(e,"globalThis");t&&(!t.configurable||!t.enumerable&&t.writable&&globalThis===e)||Object.defineProperty(e,"globalThis",{configurable:!0,enumerable:!1,value:e,writable:!0})}else"object"==typeof globalThis&&globalThis===e||(e.globalThis=e);return e}},982:function(e,t,n){"use strict";var r;if(!Object.keys){var o=Object.prototype.hasOwnProperty,a=Object.prototype.toString,i=n(642),s=Object.prototype.propertyIsEnumerable,l=!s.call({toString:null},"toString"),c=s.call((function(){}),"prototype"),u=["toString","toLocaleString","valueOf","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","constructor"],d=function(e){var t=e.constructor;return t&&t.prototype===e},p={$applicationCache:!0,$console:!0,$external:!0,$frame:!0,$frameElement:!0,$frames:!0,$innerHeight:!0,$innerWidth:!0,$onmozfullscreenchange:!0,$onmozfullscreenerror:!0,$outerHeight:!0,$outerWidth:!0,$pageXOffset:!0,$pageYOffset:!0,$parent:!0,$scrollLeft:!0,$scrollTop:!0,$scrollX:!0,$scrollY:!0,$self:!0,$webkitIndexedDB:!0,$webkitStorageInfo:!0,$window:!0},f=function(){if("undefined"==typeof window)return!1;for(var e in window)try{if(!p["$"+e]&&o.call(window,e)&&null!==window[e]&&"object"==typeof window[e])try{d(window[e])}catch(e){return!0}}catch(e){return!0}return!1}();r=function(e){var t=null!==e&&"object"==typeof e,n="[object Function]"===a.call(e),r=i(e),s=t&&"[object String]"===a.call(e),p=[];if(!t&&!n&&!r)throw new TypeError("Object.keys called on a non-object");var g=c&&n;if(s&&e.length>0&&!o.call(e,0))for(var m=0;m<e.length;++m)p.push(String(m));if(r&&e.length>0)for(var h=0;h<e.length;++h)p.push(String(h));else for(var v in e)g&&"prototype"===v||!o.call(e,v)||p.push(String(v));if(l)for(var T=function(e){if("undefined"==typeof window||!f)return d(e);try{return d(e)}catch(e){return!1}}(e),y=0;y<u.length;++y)T&&"constructor"===u[y]||!o.call(e,u[y])||p.push(u[y]);return p}}e.exports=r},382:function(e,t,n){"use strict";var r=Array.prototype.slice,o=n(642),a=Object.keys,i=a?function(e){return a(e)}:n(982),s=Object.keys;i.shim=function(){if(Object.keys){var e=function(){var e=Object.keys(arguments);return e&&e.length===arguments.length}(1,2);e||(Object.keys=function(e){return o(e)?s(r.call(e)):s(e)})}else Object.keys=i;return Object.keys||i},e.exports=i},642:function(e){"use strict";var t=Object.prototype.toString;e.exports=function(e){var n=t.call(e),r="[object Arguments]"===n;return r||(r="[object Array]"!==n&&null!==e&&"object"==typeof e&&"number"==typeof e.length&&e.length>=0&&"[object Function]"===t.call(e.callee)),r}},318:function(e,t,n){var r=n(767),o=n(698),a=n(744),i=n(402),s=n(576),l=n(886),c=n(262);c.alea=r,c.xor128=o,c.xorwow=a,c.xorshift7=i,c.xor4096=s,c.tychei=l,e.exports=c},767:function(e,t,n){var r;!function(e,o){function a(e){var t,n=this,r=(t=4022871197,function(e){e=String(e);for(var n=0;n<e.length;n++){var r=.02519603282416938*(t+=e.charCodeAt(n));r-=t=r>>>0,t=(r*=t)>>>0,t+=4294967296*(r-=t)}return 2.3283064365386963e-10*(t>>>0)});n.next=function(){var e=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=e-(n.c=0|e)},n.c=1,n.s0=r(" "),n.s1=r(" "),n.s2=r(" "),n.s0-=r(e),n.s0<0&&(n.s0+=1),n.s1-=r(e),n.s1<0&&(n.s1+=1),n.s2-=r(e),n.s2<0&&(n.s2+=1),r=null}function i(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function s(e,t){var n=new a(e),r=t&&t.state,o=n.next;return o.int32=function(){return 4294967296*n.next()|0},o.double=function(){return o()+11102230246251565e-32*(2097152*o()|0)},o.quick=o,r&&("object"==typeof r&&i(r,n),o.state=function(){return i(n,{})}),o}o&&o.exports?o.exports=s:n.amdD&&n.amdO?void 0===(r=function(){return s}.call(t,n,t,o))||(o.exports=r):this.alea=s}(0,e=n.nmd(e),n.amdD)},886:function(e,t,n){var r;!function(e,o){function a(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,o=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^o,o=o-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^o,t.a=o-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function i(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function s(e,t){var n=new a(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&("object"==typeof r&&i(r,n),o.state=function(){return i(n,{})}),o}o&&o.exports?o.exports=s:n.amdD&&n.amdO?void 0===(r=function(){return s}.call(t,n,t,o))||(o.exports=r):this.tychei=s}(0,e=n.nmd(e),n.amdD)},698:function(e,t,n){var r;!function(e,o){function a(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function s(e,t){var n=new a(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&("object"==typeof r&&i(r,n),o.state=function(){return i(n,{})}),o}o&&o.exports?o.exports=s:n.amdD&&n.amdO?void 0===(r=function(){return s}.call(t,n,t,o))||(o.exports=r):this.xor128=s}(0,e=n.nmd(e),n.amdD)},576:function(e,t,n){var r;!function(e,o){function a(e){var t=this;t.next=function(){var e,n,r=t.w,o=t.X,a=t.i;return t.w=r=r+1640531527|0,n=o[a+34&127],e=o[a=a+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=o[a]=n^e,t.i=a,n+(r^r>>>16)|0},function(e,t){var n,r,o,a,i,s=[],l=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,l=Math.max(l,t.length)),o=0,a=-32;a<l;++a)t&&(r^=t.charCodeAt((a+32)%t.length)),0===a&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,a>=0&&(i=i+1640531527|0,o=0==(n=s[127&a]^=r+i)?o+1:0);for(o>=128&&(s[127&(t&&t.length||0)]=-1),o=127,a=512;a>0;--a)r=s[o+34&127],n=s[o=o+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,s[o]=r^n;e.w=i,e.X=s,e.i=o}(t,e)}function i(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function s(e,t){null==e&&(e=+new Date);var n=new a(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(r.X&&i(r,n),o.state=function(){return i(n,{})}),o}o&&o.exports?o.exports=s:n.amdD&&n.amdO?void 0===(r=function(){return s}.call(t,n,t,o))||(o.exports=r):this.xor4096=s}(0,e=n.nmd(e),n.amdD)},402:function(e,t,n){var r;!function(e,o){function a(e){var t=this;t.next=function(){var e,n,r=t.x,o=t.i;return e=r[o],n=(e^=e>>>7)^e<<24,n^=(e=r[o+1&7])^e>>>10,n^=(e=r[o+3&7])^e>>>3,n^=(e=r[o+4&7])^e<<7,e=r[o+7&7],n^=(e^=e<<13)^e<<9,r[o]=n,t.i=o+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function i(e,t){return t.x=e.x.slice(),t.i=e.i,t}function s(e,t){null==e&&(e=+new Date);var n=new a(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(r.x&&i(r,n),o.state=function(){return i(n,{})}),o}o&&o.exports?o.exports=s:n.amdD&&n.amdO?void 0===(r=function(){return s}.call(t,n,t,o))||(o.exports=r):this.xorshift7=s}(0,e=n.nmd(e),n.amdD)},744:function(e,t,n){var r;!function(e,o){function a(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function s(e,t){var n=new a(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&("object"==typeof r&&i(r,n),o.state=function(){return i(n,{})}),o}o&&o.exports?o.exports=s:n.amdD&&n.amdO?void 0===(r=function(){return s}.call(t,n,t,o))||(o.exports=r):this.xorwow=s}(0,e=n.nmd(e),n.amdD)},262:function(e,t,n){var r;!function(o,a,i){var s,l=256,c=i.pow(l,6),u=i.pow(2,52),d=2*u,p=255;function f(e,t,n){var r=[],p=v(h((t=1==t?{entropy:!0}:t||{}).entropy?[e,T(a)]:null==e?function(){try{var e;return s&&(e=s.randomBytes)?e=e(l):(e=new Uint8Array(l),(o.crypto||o.msCrypto).getRandomValues(e)),T(e)}catch(e){var t=o.navigator,n=t&&t.plugins;return[+new Date,o,n,o.screen,T(a)]}}():e,3),r),f=new g(r),y=function(){for(var e=f.g(6),t=c,n=0;e<u;)e=(e+n)*l,t*=l,n=f.g(1);for(;e>=d;)e/=2,t/=2,n>>>=1;return(e+n)/t};return y.int32=function(){return 0|f.g(4)},y.quick=function(){return f.g(4)/4294967296},y.double=y,v(T(f.S),a),(t.pass||n||function(e,t,n,r){return r&&(r.S&&m(r,f),e.state=function(){return m(f,{})}),n?(i.random=e,t):e})(y,p,"global"in t?t.global:this==i,t.state)}function g(e){var t,n=e.length,r=this,o=0,a=r.i=r.j=0,i=r.S=[];for(n||(e=[n++]);o<l;)i[o]=o++;for(o=0;o<l;o++)i[o]=i[a=p&a+e[o%n]+(t=i[o])],i[a]=t;(r.g=function(e){for(var t,n=0,o=r.i,a=r.j,i=r.S;e--;)t=i[o=p&o+1],n=n*l+i[p&(i[o]=i[a=p&a+t])+(i[a]=t)];return r.i=o,r.j=a,n})(l)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function h(e,t){var n,r=[],o=typeof e;if(t&&"object"==o)for(n in e)try{r.push(h(e[n],t-1))}catch(e){}return r.length?r:"string"==o?e:e+"\0"}function v(e,t){for(var n,r=e+"",o=0;o<r.length;)t[p&o]=p&(n^=19*t[p&o])+r.charCodeAt(o++);return T(t)}function T(e){return String.fromCharCode.apply(0,e)}if(v(i.random(),a),e.exports){e.exports=f;try{s=n(1)}catch(e){}}else void 0===(r=function(){return f}.call(t,n,t,e))||(e.exports=r)}("undefined"!=typeof self?self:this,[],Math)},292:function(e){e.exports=function(){"use strict";var e=["0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f"];function t(e,t){var n=e[0],r=e[1],o=e[2],a=e[3];r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[0]-680876936|0)<<7|n>>>25)+r|0)&r|~n&o)+t[1]-389564586|0)<<12|a>>>20)+n|0)&n|~a&r)+t[2]+606105819|0)<<17|o>>>15)+a|0)&a|~o&n)+t[3]-1044525330|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[4]-176418897|0)<<7|n>>>25)+r|0)&r|~n&o)+t[5]+1200080426|0)<<12|a>>>20)+n|0)&n|~a&r)+t[6]-1473231341|0)<<17|o>>>15)+a|0)&a|~o&n)+t[7]-45705983|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[8]+1770035416|0)<<7|n>>>25)+r|0)&r|~n&o)+t[9]-1958414417|0)<<12|a>>>20)+n|0)&n|~a&r)+t[10]-42063|0)<<17|o>>>15)+a|0)&a|~o&n)+t[11]-1990404162|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[12]+1804603682|0)<<7|n>>>25)+r|0)&r|~n&o)+t[13]-40341101|0)<<12|a>>>20)+n|0)&n|~a&r)+t[14]-1502002290|0)<<17|o>>>15)+a|0)&a|~o&n)+t[15]+1236535329|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[1]-165796510|0)<<5|n>>>27)+r|0)&o|r&~o)+t[6]-1069501632|0)<<9|a>>>23)+n|0)&r|n&~r)+t[11]+643717713|0)<<14|o>>>18)+a|0)&n|a&~n)+t[0]-373897302|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[5]-701558691|0)<<5|n>>>27)+r|0)&o|r&~o)+t[10]+38016083|0)<<9|a>>>23)+n|0)&r|n&~r)+t[15]-660478335|0)<<14|o>>>18)+a|0)&n|a&~n)+t[4]-405537848|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[9]+568446438|0)<<5|n>>>27)+r|0)&o|r&~o)+t[14]-1019803690|0)<<9|a>>>23)+n|0)&r|n&~r)+t[3]-187363961|0)<<14|o>>>18)+a|0)&n|a&~n)+t[8]+1163531501|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[13]-1444681467|0)<<5|n>>>27)+r|0)&o|r&~o)+t[2]-51403784|0)<<9|a>>>23)+n|0)&r|n&~r)+t[7]+1735328473|0)<<14|o>>>18)+a|0)&n|a&~n)+t[12]-1926607734|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[5]-378558|0)<<4|n>>>28)+r|0)^r^o)+t[8]-2022574463|0)<<11|a>>>21)+n|0)^n^r)+t[11]+1839030562|0)<<16|o>>>16)+a|0)^a^n)+t[14]-35309556|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[1]-1530992060|0)<<4|n>>>28)+r|0)^r^o)+t[4]+1272893353|0)<<11|a>>>21)+n|0)^n^r)+t[7]-155497632|0)<<16|o>>>16)+a|0)^a^n)+t[10]-1094730640|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[13]+681279174|0)<<4|n>>>28)+r|0)^r^o)+t[0]-358537222|0)<<11|a>>>21)+n|0)^n^r)+t[3]-722521979|0)<<16|o>>>16)+a|0)^a^n)+t[6]+76029189|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[9]-640364487|0)<<4|n>>>28)+r|0)^r^o)+t[12]-421815835|0)<<11|a>>>21)+n|0)^n^r)+t[15]+530742520|0)<<16|o>>>16)+a|0)^a^n)+t[2]-995338651|0)<<23|r>>>9)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[0]-198630844|0)<<6|n>>>26)+r|0)|~o))+t[7]+1126891415|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[14]-1416354905|0)<<15|o>>>17)+a|0)|~n))+t[5]-57434055|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[12]+1700485571|0)<<6|n>>>26)+r|0)|~o))+t[3]-1894986606|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[10]-1051523|0)<<15|o>>>17)+a|0)|~n))+t[1]-2054922799|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[8]+1873313359|0)<<6|n>>>26)+r|0)|~o))+t[15]-30611744|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[6]-1560198380|0)<<15|o>>>17)+a|0)|~n))+t[13]+1309151649|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[4]-145523070|0)<<6|n>>>26)+r|0)|~o))+t[11]-1120210379|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[2]+718787259|0)<<15|o>>>17)+a|0)|~n))+t[9]-343485551|0)<<21|r>>>11)+o|0,e[0]=n+e[0]|0,e[1]=r+e[1]|0,e[2]=o+e[2]|0,e[3]=a+e[3]|0}function n(e){var t,n=[];for(t=0;t<64;t+=4)n[t>>2]=e.charCodeAt(t)+(e.charCodeAt(t+1)<<8)+(e.charCodeAt(t+2)<<16)+(e.charCodeAt(t+3)<<24);return n}function r(e){var t,n=[];for(t=0;t<64;t+=4)n[t>>2]=e[t]+(e[t+1]<<8)+(e[t+2]<<16)+(e[t+3]<<24);return n}function o(e){var r,o,a,i,s,l,c=e.length,u=[1732584193,-271733879,-1732584194,271733878];for(r=64;r<=c;r+=64)t(u,n(e.substring(r-64,r)));for(o=(e=e.substring(r-64)).length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],r=0;r<o;r+=1)a[r>>2]|=e.charCodeAt(r)<<(r%4<<3);if(a[r>>2]|=128<<(r%4<<3),r>55)for(t(u,a),r=0;r<16;r+=1)a[r]=0;return i=(i=8*c).toString(16).match(/(.*?)(.{0,8})$/),s=parseInt(i[2],16),l=parseInt(i[1],16)||0,a[14]=s,a[15]=l,t(u,a),u}function a(t){var n,r="";for(n=0;n<4;n+=1)r+=e[t>>8*n+4&15]+e[t>>8*n&15];return r}function i(e){var t;for(t=0;t<e.length;t+=1)e[t]=a(e[t]);return e.join("")}function s(e){return/[\u0080-\uFFFF]/.test(e)&&(e=unescape(encodeURIComponent(e))),e}function l(e){var t,n=[],r=e.length;for(t=0;t<r-1;t+=2)n.push(parseInt(e.substr(t,2),16));return String.fromCharCode.apply(String,n)}function c(){this.reset()}return i(o("hello")),"undefined"==typeof ArrayBuffer||ArrayBuffer.prototype.slice||function(){function e(e,t){return(e=0|e||0)<0?Math.max(e+t,0):Math.min(e,t)}ArrayBuffer.prototype.slice=function(t,n){var r,o,a,i,s=this.byteLength,l=e(t,s),c=s;return undefined!==n&&(c=e(n,s)),l>c?new ArrayBuffer(0):(r=c-l,o=new ArrayBuffer(r),a=new Uint8Array(o),i=new Uint8Array(this,l,r),a.set(i),o)}}(),c.prototype.append=function(e){return this.appendBinary(s(e)),this},c.prototype.appendBinary=function(e){this._buff+=e,this._length+=e.length;var r,o=this._buff.length;for(r=64;r<=o;r+=64)t(this._hash,n(this._buff.substring(r-64,r)));return this._buff=this._buff.substring(r-64),this},c.prototype.end=function(e){var t,n,r=this._buff,o=r.length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(t=0;t<o;t+=1)a[t>>2]|=r.charCodeAt(t)<<(t%4<<3);return this._finish(a,o),n=i(this._hash),e&&(n=l(n)),this.reset(),n},c.prototype.reset=function(){return this._buff="",this._length=0,this._hash=[1732584193,-271733879,-1732584194,271733878],this},c.prototype.getState=function(){return{buff:this._buff,length:this._length,hash:this._hash.slice()}},c.prototype.setState=function(e){return this._buff=e.buff,this._length=e.length,this._hash=e.hash,this},c.prototype.destroy=function(){delete this._hash,delete this._buff,delete this._length},c.prototype._finish=function(e,n){var r,o,a,i=n;if(e[i>>2]|=128<<(i%4<<3),i>55)for(t(this._hash,e),i=0;i<16;i+=1)e[i]=0;r=(r=8*this._length).toString(16).match(/(.*?)(.{0,8})$/),o=parseInt(r[2],16),a=parseInt(r[1],16)||0,e[14]=o,e[15]=a,t(this._hash,e)},c.hash=function(e,t){return c.hashBinary(s(e),t)},c.hashBinary=function(e,t){var n=i(o(e));return t?l(n):n},c.ArrayBuffer=function(){this.reset()},c.ArrayBuffer.prototype.append=function(e){var n,o,a,i,s,l=(o=this._buff.buffer,a=e,i=!0,(s=new Uint8Array(o.byteLength+a.byteLength)).set(new Uint8Array(o)),s.set(new Uint8Array(a),o.byteLength),i?s:s.buffer),c=l.length;for(this._length+=e.byteLength,n=64;n<=c;n+=64)t(this._hash,r(l.subarray(n-64,n)));return this._buff=n-64<c?new Uint8Array(l.buffer.slice(n-64)):new Uint8Array(0),this},c.ArrayBuffer.prototype.end=function(e){var t,n,r=this._buff,o=r.length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(t=0;t<o;t+=1)a[t>>2]|=r[t]<<(t%4<<3);return this._finish(a,o),n=i(this._hash),e&&(n=l(n)),this.reset(),n},c.ArrayBuffer.prototype.reset=function(){return this._buff=new Uint8Array(0),this._length=0,this._hash=[1732584193,-271733879,-1732584194,271733878],this},c.ArrayBuffer.prototype.getState=function(){var e,t=c.prototype.getState.call(this);return t.buff=(e=t.buff,String.fromCharCode.apply(null,new Uint8Array(e))),t},c.ArrayBuffer.prototype.setState=function(e){return e.buff=function(e,t){var n,r=e.length,o=new ArrayBuffer(r),a=new Uint8Array(o);for(n=0;n<r;n+=1)a[n]=e.charCodeAt(n);return t?a:o}(e.buff,!0),c.prototype.setState.call(this,e)},c.ArrayBuffer.prototype.destroy=c.prototype.destroy,c.ArrayBuffer.prototype._finish=c.prototype._finish,c.ArrayBuffer.hash=function(e,n){var o=i(function(e){var n,o,a,i,s,l,c=e.length,u=[1732584193,-271733879,-1732584194,271733878];for(n=64;n<=c;n+=64)t(u,r(e.subarray(n-64,n)));for(o=(e=n-64<c?e.subarray(n-64):new Uint8Array(0)).length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],n=0;n<o;n+=1)a[n>>2]|=e[n]<<(n%4<<3);if(a[n>>2]|=128<<(n%4<<3),n>55)for(t(u,a),n=0;n<16;n+=1)a[n]=0;return i=(i=8*c).toString(16).match(/(.*?)(.{0,8})$/),s=parseInt(i[2],16),l=parseInt(i[1],16)||0,a[14]=s,a[15]=l,t(u,a),u}(new Uint8Array(e)));return n?l(o):o},c}()},96:function(e,t,n){"use strict";var r=n(20),o=n.n(r),a=n(613),i=n.n(a),s=n(336),l=n.n(s),c=new URL(n(183),n.b),u=i()(o()),d=l()(c);u.push([e.id,".viewer-module-fullScreen_bbk9Y {\n  position: absolute;\n  width: 100vw;\n  height: 100vh;\n  top: 0;\n  left: 0;\n  overflow: hidden;\n  background: black;\n  margin: 0;\n  padding: 0;\n  z-index: -1;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n.viewer-module-fullParentSize_ETopO {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  top: 0;\n  left: 0;\n  overflow: hidden;\n}\n\n.viewer-module-bigFileDrop_aqCgh {\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n  background-color: white;\n  background-image: url("+d+");\n  background-repeat: no-repeat;\n  background-position: center;\n  background-size: contain;\n  border-radius: 10px;\n  width: 50px;\n  padding: calc(50vh - 2em) calc(50vw - 25px - 2em);\n  cursor: pointer;\n}\n\n.viewer-module-progress_cYjQJ {\n  flex: none;\n  font-size: 50px;\n  color: black;\n  z-index: 1;\n  background: rgba(128,128,128,.5);\n  padding: 20px;\n  border-radius: 10px;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n\nbody {\n  margin: 0;\n}\n\nhtml { \n  overflow: hidden; \n}\n",""]),u.locals={fullScreen:"viewer-module-fullScreen_bbk9Y",fullParentSize:"viewer-module-fullParentSize_ETopO",bigFileDrop:"viewer-module-bigFileDrop_aqCgh",progress:"viewer-module-progress_cYjQJ"},t.A=u},50:function(e,t,n){var r=n(422),o=n(77);void 0===o.OfflineLocalView&&(o.OfflineLocalView=r),e.exports=r},911:function(e){"use strict";var t=[];function n(e){for(var n=-1,r=0;r<t.length;r++)if(t[r].identifier===e){n=r;break}return n}function r(e,r){for(var a={},i=[],s=0;s<e.length;s++){var l=e[s],c=r.base?l[0]+r.base:l[0],u=a[c]||0,d="".concat(c," ").concat(u);a[c]=u+1;var p=n(d),f={css:l[1],media:l[2],sourceMap:l[3],supports:l[4],layer:l[5]};if(-1!==p)t[p].references++,t[p].updater(f);else{var g=o(f,r);r.byIndex=s,t.splice(s,0,{identifier:d,updater:g,references:1})}i.push(d)}return i}function o(e,t){var n=t.domAPI(t);return n.update(e),function(t){if(t){if(t.css===e.css&&t.media===e.media&&t.sourceMap===e.sourceMap&&t.supports===e.supports&&t.layer===e.layer)return;n.update(e=t)}else n.remove()}}e.exports=function(e,o){var a=r(e=e||[],o=o||{});return function(e){e=e||[];for(var i=0;i<a.length;i++){var s=n(a[i]);t[s].references--}for(var l=r(e,o),c=0;c<a.length;c++){var u=n(a[c]);0===t[u].references&&(t[u].updater(),t.splice(u,1))}a=l}}},383:function(e){"use strict";var t={};e.exports=function(e,n){var r=function(e){if(void 0===t[e]){var n=document.querySelector(e);if(window.HTMLIFrameElement&&n instanceof window.HTMLIFrameElement)try{n=n.contentDocument.head}catch(e){n=null}t[e]=n}return t[e]}(e);if(!r)throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");r.appendChild(n)}},88:function(e){"use strict";e.exports=function(e){var t=document.createElement("style");return e.setAttributes(t,e.attributes),e.insert(t,e.options),t}},884:function(e,t,n){"use strict";e.exports=function(e){var t=n.nc;t&&e.setAttribute("nonce",t)}},893:function(e){"use strict";e.exports=function(e){var t=e.insertStyleElement(e);return{update:function(n){!function(e,t,n){var r="";n.supports&&(r+="@supports (".concat(n.supports,") {")),n.media&&(r+="@media ".concat(n.media," {"));var o=void 0!==n.layer;o&&(r+="@layer".concat(n.layer.length>0?" ".concat(n.layer):""," {")),r+=n.css,o&&(r+="}"),n.media&&(r+="}"),n.supports&&(r+="}");var a=n.sourceMap;a&&"undefined"!=typeof btoa&&(r+="\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(a))))," */")),t.styleTagTransform(r,e,t.options)}(t,e,n)},remove:function(){!function(e){if(null===e.parentNode)return!1;e.parentNode.removeChild(e)}(t)}}}},997:function(e){"use strict";e.exports=function(e,t){if(t.styleSheet)t.styleSheet.cssText=e;else{for(;t.firstChild;)t.removeChild(t.firstChild);t.appendChild(document.createTextNode(e))}}},183:function(e,t,n){"use strict";e.exports=n.p+"138e7b1469f64156810a.jpg"},1:function(){}},t={};function n(r){var o=t[r];if(void 0!==o)return o.exports;var a=t[r]={id:r,loaded:!1,exports:{}};return e[r].call(a.exports,a,a.exports,n),a.loaded=!0,a.exports}n.m=e,n.amdD=function(){throw new Error("define cannot be used indirect")},n.amdO={},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,{a:t}),t},n.d=function(e,t){for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.nmd=function(e){return e.paths=[],e.children||(e.children=[]),e},n.p="",n.b=document.baseURI||self.location.href,n.nc=void 0,n(50)}();
</script>
<script>
var container = document.querySelector('.content');
var base64Str = "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";

OfflineLocalView.load(container, { base64Str });
</script>
</body>
</html>
